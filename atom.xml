<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Nightfade's Techlog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://nightfade.github.io/"/>
  <updated>2016-01-18T08:04:26.000Z</updated>
  <id>http://nightfade.github.io/</id>
  
  <author>
    <name><![CDATA[Nightfade]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[多线程内存模型和C++1x Atomic]]></title>
    <link href="http://nightfade.github.io/2015/09/15/cpp1x-atomic/"/>
    <id>http://nightfade.github.io/2015/09/15/cpp1x-atomic/</id>
    <published>2015-09-15T03:36:00.000Z</published>
    <updated>2016-01-18T08:04:26.000Z</updated>
    <content type="html"><![CDATA[<p>本文主要总结了《<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/" target="_blank" rel="external">为什么程序员需要关心顺序一致性（Sequential Consistency）而不是Cache一致性（Cache Coherence？）</a>》，《<a href="http://www.parallellabs.com/2011/08/27/c-plus-plus-memory-model/" target="_blank" rel="external">浅析C++多线程内存模型</a>》，《<a href="http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync" target="_blank" rel="external">Memory model synchronization modes</a>》，《<a href="http://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="external">std::memory_order</a>》</p>
<h1 id="Sequential_Consistency"><a href="#Sequential_Consistency" class="headerlink" title="Sequential Consistency"></a>Sequential Consistency</h1><h2 id="u4EC0_u4E48_u662FSequential_Consistency"><a href="#u4EC0_u4E48_u662FSequential_Consistency" class="headerlink" title="什么是Sequential Consistency"></a>什么是<code>Sequential Consistency</code></h2><p><code>Sequential Consistency</code>的作者Lamport给的严格定义是：</p>
<blockquote>
<p>… the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.</p>
</blockquote>
<p><code>Sequential Consistency</code>其实就是规定了两件事情：</p>
<ol>
<li>每个线程内部的指令都是按照程序规定的顺序（program order）执行的（单个线程的视角）。</li>
<li>线程执行的交错顺序可以是任意的，但是所有线程所看见的整个程序的总体执行顺序都是一样的（整个程序的视角）。</li>
</ol>
<p>假设我们有两个线程（线程1和线程2）分别运行在两个CPU上，有两个初始值为0的全局共享变量x和y，两个线程分别执行下面两条指令：</p>
<p>初始条件：<code>x = y = 0;</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">线程1</th>
<th style="text-align:center">线程2 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x = 1</td>
<td style="text-align:center">y = 1</td>
</tr>
<tr>
<td style="text-align:center">r1 = y</td>
<td style="text-align:center">r2 = x</td>
</tr>
<tr>
<td style="text-align:center"><strong><strong><em>__</em></strong></strong></td>
<td style="text-align:center"><strong><strong><em>__</em></strong></strong></td>
</tr>
</tbody>
</table>
<p>因为多线程程序是交错执行的，所以程序可能有如下几种执行顺序：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Execution 1</th>
<th style="text-align:center">Execution 2</th>
<th style="text-align:center">Execution 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x = 1;</td>
<td style="text-align:center">y = 1;</td>
<td style="text-align:center">x = 1;</td>
</tr>
<tr>
<td style="text-align:center">r1 = y;</td>
<td style="text-align:center">r2 = x;</td>
<td style="text-align:center">y = 1;</td>
</tr>
<tr>
<td style="text-align:center">y = 1;</td>
<td style="text-align:center">x = 1;</td>
<td style="text-align:center">r1 = y;</td>
</tr>
<tr>
<td style="text-align:center">r2 = x;</td>
<td style="text-align:center">r1 = y;</td>
<td style="text-align:center">r2 = x;</td>
</tr>
<tr>
<td style="text-align:center">结果:r1==0 and r2 == 1</td>
<td style="text-align:center">结果: r1 == 1 and r2 == 0</td>
<td style="text-align:center">结果: r1 == 1 and r2 == 1</td>
</tr>
<tr>
<td style="text-align:center"><strong><strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong></strong></td>
<td style="text-align:center"><strong><strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong></strong></td>
<td style="text-align:center"><strong><strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong></strong></td>
</tr>
</tbody>
</table>
<p>上面三种情况并没包括所有可能的执行顺序，但是它们已经包括所有可能出现的结果了，所以我们只举上面三个例子。我们注意到这个程序只可能出现上面三种结果，但是不可能出现<code>r1==0 and r2==0</code>的情况。</p>
<p>其实说简单点，SC就是我们最容易理解的那个多线程程序执行顺序的模型。</p>
<h2 id="u4E3A_u4EC0_u4E48_u8981_u5173_u5FC3Sequential_Consistency"><a href="#u4E3A_u4EC0_u4E48_u8981_u5173_u5FC3Sequential_Consistency" class="headerlink" title="为什么要关心Sequential Consistency"></a>为什么要关心<code>Sequential Consistency</code></h2><p>现在的CPU和编译器会对代码做各种各样的优化，有时候它们可能会为了优化性能而把程序员在写程序时规定的代码执行顺序(program order)打乱。<br>例如编译器可能会做如下优化，即把线程1的两条语序调换执行顺序：</p>
<p>初始条件：<code>x = y = 0;</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">线程 1</th>
<th style="text-align:center">线程 2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r1 = y;</td>
<td style="text-align:center">y=1;</td>
</tr>
<tr>
<td style="text-align:center">x = 1;</td>
<td style="text-align:center">r2 = x;</td>
</tr>
<tr>
<td style="text-align:center"><strong><strong>___</strong></strong></td>
<td style="text-align:center"><strong><strong>___</strong></strong></td>
</tr>
</tbody>
</table>
<p>那么这个时候程序如果按如下顺序执行就可能就会出现<code>r1==r2==0</code>这样程序员认为”不正确“的结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Execution 4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r1 = y;</td>
</tr>
<tr>
<td style="text-align:center">y = 1;</td>
</tr>
<tr>
<td style="text-align:center">r2 = x;</td>
</tr>
<tr>
<td style="text-align:center">x = 1;</td>
</tr>
<tr>
<td style="text-align:center"><strong><strong><strong>_</strong></strong></strong></td>
</tr>
</tbody>
</table>
<p>为什么编译器会做这样的优化呢？因为读一个在内存中而不是在cache中的共享变量需要很多周期，所以编译器就”自作聪明“的让读操作先执行，从而隐藏掉一些指令执行的latency，提高程序的性能。实际上这种类似的技术是在单核时代非常普遍的优化方法，但是在进入多核时代后编译器没跟上发展，导致了对多线程程序进行了违反SC的错误优化。</p>
<p>我们发现为了保证多线程的正确性，我们希望程序能按照SC模型执行；但是SC的对性能的损失太大了，CPU硬件和编译器为了提高性能就必须要做优化啊！为了既保证正确性又保证性能，在经过十几年的研究后一个新的新的模型出炉了：sequential consistency for data race free programs。简单地说这个模型的原理就是对没有data race的程序可以保证它是遵循SC的，这个模型在多线程程序的正确性和性能间找到了一个平衡点。</p>
<p>说简单点，就是由程序员用同步原语（例如锁或者atomic的同步变量）来保证你程序是没有data race的，这样CPU和编译器就会保证你程序是按你所想的那样执行的（即SC），是正确的。换句话说，程序员只需要恰当地使用具有<code>acquire</code>和<code>release</code>语义的同步原语标记那些真正需要同步的变量和操作，就等于告诉CPU和编译器你们不要对这些标记出来的操作和变量做违反SC的优化，而其它未被标记的地方你们可以随便优化，这样既保证了正确性又保证了CPU和编译器可以做尽可能多的性能优化。</p>
<p>从根源上来讲，在串行时代，编译器和CPU对代码所进行的乱序执行的优化对程序员都是封装好了的，无痛的，所以程序员不需要关心这些代码在执行时被乱序成什么样子，因为这些都被编译器和CPU封装起来了，你不用担心内部细节，它最终表现出来的行为就是按你想要的那种方式执行的。但是进入多核时代，程序员、编译器、CPU三者之间未能达成一致，所以CPU、编译器就会时不时地给你捣蛋，故作聪明的做一些优化，让你的程序不会按照你想要的方式执行，是错误的。</p>
<h1 id="C++1x_u4E2D_u5F15_u5165_u7684atomic_u7C7B_u578B"><a href="#C++1x_u4E2D_u5F15_u5165_u7684atomic_u7C7B_u578B" class="headerlink" title="C++1x中引入的atomic类型"></a>C++1x中引入的<code>atomic</code>类型</h1><p>C++1x除了提供传统的锁、条件变量等同步机制之外，还引入了新的<code>atomic</code>类型。相对于传统的<code>mutex</code>锁来说，<code>atomic</code>类型更底层，具备更好的性能，因此能用于实现诸如Lock Free等高性能并行算法。</p>
<p>对常见的数据类型，C++1x都提供了与之相对应的<code>atomic</code>类型。以<code>bool</code>类型举例，与之相对应的<code>atomic_bool</code>类型具备两个新属性：原子性与顺序性。顾名思义，原子性的意思是说<code>atomic_bool</code>的操作都是不可分割的，原子的；而顺序性则指定了对该变量的操作何时对其他线程可见。</p>
<p>在C++1x中，为了满足对性能的追求，<code>atomic</code>类型提供了三种顺序属性：<code>sequential consistency ordering</code>（即顺序一致性），<code>acquire release ordering</code>以及<code>relaxed ordering</code>。因为<code>sequential consistency</code>是最易理解的模型，所以默认情况下所有<code>atomic</code>类型的操作都会使<code>sequential consistency</code>顺序。当然，顺序一致性的性能相对来说比较差，所以程序员还可以使用对顺序性要求稍弱一些的<code>acquire release ordering</code>与最弱的<code>relaxed ordering</code>。</p>
<p>在下面这个例子中，<code>atomic_bool</code>类型的变量<code>data_ready</code>就被用来实现两个线程间的同步操作。需要注意的是，对<code>data_ready</code>的写操作仍然可以通过直接使用赋值操作符（即“<code>=</code>”）来进行，但是对其的读操作就必须调用<code>load()</code>函数来进行。在默认的情况下，所有<code>atomic</code>类型变量的顺序性都是顺序一致性（即sequential consistency）。在这个例子中，因为<code>data_ready</code>的顺序性被规定为顺序一致性，所以线程1中对<code>data_ready</code>的写操作会与线程2中对<code>data_ready</code>的读操作构建起<code>synchronize-with</code>的同步关系，即#2-&gt;#3。又因为<code>writer_thread()</code>中的代码顺序规定了#1在#2之前发生，即#1-&gt;#2；而且<code>reader_thread</code>中的代码顺序规定了#3-&gt;#4，所以就有了#1-&gt;#2-&gt;#3-&gt;#4这样的顺序关系，从而可以保证在#4中读取<code>data</code>的值时，#1已经执行完毕，即#4一定能读到#1写入的值（10）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="keyword">atomic_bool</span> <span class="title">data_ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer_thread</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    data.push_back(<span class="number">10</span>); <span class="comment">// #1：对data的写操作</span></span><br><span class="line">    data_ready = <span class="literal">true</span>; <span class="comment">// #2：对data_ready的写操作</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader_thread</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!data_ready.load()) <span class="comment">// #3：对data_ready的读操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep(<span class="built_in">std</span>::milliseconds(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ”data is ” &lt;&lt; data[<span class="number">0</span>] &lt;&lt; ”\n”; <span class="comment">// #4：对data的读操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信很多朋友会纳闷，这样的执行顺序不是显然的么？其实不然。如果我们把<code>data_ready</code>的顺序性制定为<code>relaxed ordering</code>的话，编译器和CPU就可以自由地做违反顺序一致性的乱序优化，从而导致#1不一定在#2之前被执行，最终导致#4中读到的<code>data</code>的值不为10。</p>
<p>简单的来说，在<code>atomic</code>类型提供的三种顺序属性中，<code>acquire release ordering</code>对顺序性的约束程度介于<code>sequential consistency</code>（顺序一致性）和<code>relaxed ordering</code>之间，因为它不要求全局一致性，但是具有<code>synchronized with</code>的关系。<code>Relaxed ordering</code>最弱，因为它对顺序性不做任何要求。由此可见，除非非常必要，我们一般不建议使用<code>relaxed ordering</code>，因为这不能保证任何顺序性。<br>对于<code>atomic</code>的<code>memory ordering</code>理解起来相对复杂一些，可以参考如下两个链接：<br>《<a href="http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync" target="_blank" rel="external">Memory model synchronization modes</a>》<br>《<a href="http://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="external">std::memory_order</a>》<br>简单（简陋）的总结一下：</p>
<ul>
<li><code>sequential consistency</code>保证了所有原子操作在所有线程之间是顺序一致的。可以把一个<code>sequential consistency</code>的原子操作看做一个<code>fence</code>，在做乱序优化的时候，前后的指令不可以跨越<code>fence</code>。同时，保证不同现成可以看到这些原子操作是一致的顺序。</li>
<li><code>acquire release ordering</code>可以看做是单向的<code>fence</code>，在做乱序优化的时候，标记<code>acquire</code>的原子操作之后的指令不可以被移动到<code>acquire</code>操作之前；<code>release</code>原子操作之前的指令不可以被移动到<code>release</code>操作之后。需要注意的是，不同线程看到的原子操作之间的顺序可能是不一致的（可能是由于某些Processor的cache还没写入内存等原因）。</li>
<li><code>relaxed ordering</code>仅仅保证操作的原子性，通常只用在单纯需要原子性的计数变量。</li>
<li>还有一种<code>acquire ordering</code>的变化<code>consume ordering</code>，仅限制依赖于<code>consume ordering</code>原子操作取到的变量的相关指令不能移动到<code>consume ordering</code>操作之前，对其他指令没有限制。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要总结了《<a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coheren]]>
    </summary>
    
      <category term="CPP" scheme="http://nightfade.github.io/tags/CPP/"/>
    
      <category term="Multithreading" scheme="http://nightfade.github.io/tags/Multithreading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ReactiveCocoa 3.0 初步]]></title>
    <link href="http://nightfade.github.io/2015/09/01/reactivecocoa3-basic/"/>
    <id>http://nightfade.github.io/2015/09/01/reactivecocoa3-basic/</id>
    <published>2015-09-01T01:32:00.000Z</published>
    <updated>2016-01-18T08:04:20.000Z</updated>
    <content type="html"><![CDATA[<p>本文总结了《<a href="http://blog.scottlogic.com/2015/04/24/first-look-reactive-cocoa-3.html" target="_blank" rel="external">A FIRST LOOK AT REACTIVECOCOA 3.0</a>》和《<a href="http://blog.scottlogic.com/2015/04/28/reactive-cocoa-3-continued.html" target="_blank" rel="external">REACTIVECOCOA 3.0 - SIGNAL PRODUCERS AND API CLARITY</a>》中关于<code>ReactiveCocoa 3.0</code>新的Swift API的基本用法。</p>
<p><code>ReactiveCocoa 3.0</code>的Swift API引入了泛型、<code>pipe-forward</code>运算符，并且还运用了<code>curried functions</code>。新的语言特性让<code>ReactiveCocoa</code>变的更好更简洁了。</p>
<h1 id="Creating_Signals"><a href="#Creating_Signals" class="headerlink" title="Creating Signals"></a>Creating Signals</h1><p>和<code>Objective-C</code>版本<code>ReactiveCocoa</code>中的<code>RACSignal</code>对应的是<code>Swift</code>版本中的<code>Signal</code>。关于<code>Signal</code>很重要的一点是这个类是个泛型类：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Signal</span>&lt;<span class="title">T</span>, <span class="title">E</span>: <span class="title">ErrorType</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类型<code>T</code>代表的是信号发出的<code>next</code> <code>event</code>中数据的类型；<code>E</code>表示错误的类型必须是符合<code>ErrorType</code>协议的。<br><code>Swift</code>的<code>Signal</code>创建的方式和<code>Objective-C</code>的<code>RACSignal</code>创建方式很相似：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">createSignal</span><span class="params">()</span></span> -&gt; <span class="type">Signal</span>&lt;<span class="type">String</span>, <span class="type">NoError</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">Signal</span> &#123;</span><br><span class="line">        sink <span class="keyword">in</span></span><br><span class="line">        <span class="type">NSTimer</span>.schedule(repeatInterval: <span class="number">1.0</span>) &#123;</span><br><span class="line">            timer <span class="keyword">in</span></span><br><span class="line">            sendNext(sink, <span class="string">"tick #<span class="subst">\(<span class="built_in">count</span>++)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Signal</code>的构造函数接受一个<code>generator</code>闭包的参数，这个<code>generator</code>被调用并且传入一个<code>sink</code>，在这个例子里<code>sink</code>的类型是<code>SinkOf&lt;Event&lt;String, NoError&gt;&gt;</code>。任何传给这个<code>sink</code>的<code>event</code>都会被<code>signal</code>发射出去。<br><code>sendNext</code>的第二个参数接收传入的值，并且构造成<code>event</code>传给<code>sink</code>。</p>
<h1 id="Observing_Signals"><a href="#Observing_Signals" class="headerlink" title="Observing Signals"></a>Observing Signals</h1><p>观察监听一个<code>Signal</code>有几种不同的方式，最简单的是用<code>observe</code>方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> signal = createSignal()</span><br><span class="line">signal.observe(next: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br></pre></td></tr></table></figure></p>
<p>这段代码的输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tick #0&#10;tick #1&#10;tick #2&#10;tick #3&#10;tick #4</span><br></pre></td></tr></table></figure></p>
<p>或者也可以提供一个<code>Sink</code>来观察<code>Signal</code>的<code>Event</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">createSignal().observe(<span class="type">SinkOf</span> &#123;</span><br><span class="line">    event <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Next</span>(data):</span><br><span class="line">        <span class="built_in">print</span>(data.unbox)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><code>Event</code>类型是一个枚举，其中的<code>Next</code>和<code>Error</code>事件类型包含了其相关值。上面例子中的<code>SinkOf</code>构造函数构造了一个类型是<code>SinkOf&lt;Event&lt;String, NoError&gt;&gt;</code>的<code>sink</code>。<br>由于<code>Swift</code>语言本身的限制，<code>Event</code>中封装的<code>data</code>是用<a href="https://github.com/LlamaKit/LlamaKit/blob/e28d7f6e82fbd5dcd5388b36e2acf4eedb44b4e8/LlamaKit/Result.swift#L156" target="_blank" rel="external"><code>LlamaKit Box Class</code></a>封装起来的，需要用<code>box/unbox</code>来处理一下。(注：<code>Swift 2.0</code>之后这个限制其实已经没有了)。</p>
<h1 id="Transforming_Signals"><a href="#Transforming_Signals" class="headerlink" title="Transforming Signals"></a>Transforming Signals</h1><p><code>Swift</code>的<code>Signal</code>和<code>Objective-C</code>的API另外一个显著的不同点就是对<code>Signal</code>的<code>Transforming</code>，以<code>map</code>操作举例，<code>map</code>函数被实现为一个<code>free function</code>，而不是<code>Signal</code>的成员函数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Signal</span>&lt;<span class="title">T</span>, <span class="title">E</span>: <span class="title">ErrorType</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">map</span><span class="params">(signal: Signal, transform: ...)</span></span> -&gt; <span class="type">Signal</span></span><br></pre></td></tr></table></figure></p>
<p>然而如果用<code>free function</code>做<code>Signal</code>的<code>Transforming</code>，代码就不再是『流式』的了：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> transformedSignal = <span class="built_in">filter</span>(<span class="built_in">map</span>(signal, &#123; ... &#125;), &#123; ... &#125;)</span><br></pre></td></tr></table></figure></p>
<p>所以<code>ReactiveCocoa</code>提供了<code>pipe-forward</code>运算符（从<code>F#</code>借鉴过来的idea）。<br><code>Swift</code>的<code>map</code>实际上是一个<code>curred function</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">map</span><span class="generics">&lt;T, U, E&gt;</span><span class="params">(transform: T -&gt; U)</span></span></span><br><span class="line">                        (signal: <span class="type">Signal</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;) -&gt; <span class="type">Signal</span>&lt;<span class="type">U</span>, <span class="type">E</span>&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，这个方法第一次调用的时候，我们先提供一个<code>transform</code>，从而得到一个新的函数，可以用给定的<code>transform</code>把一个<code>signal</code>映射为一个新的<code>signal</code>。<br><code>pipe-forward</code>运算符允许我们把<code>transform</code>串联起来：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> |&gt; <span class="generics">&lt;T, E, X&gt;</span><span class="params">(signal: Signal&lt;T, E&gt;,</span><br><span class="line">                         transform: Signal&lt;T, E&gt; -&gt; X)</span></span> -&gt; <span class="type">X</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> transform(signal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用<code>pip-forward</code>运算符，我们可以把<code>transforming</code>写成这样：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal</span><br><span class="line">    |&gt; <span class="built_in">map</span> &#123; $<span class="number">0</span>.uppercaseString &#125;</span><br><span class="line">    |&gt; observe(next: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br></pre></td></tr></table></figure></p>
<p><code>free functions</code>比起成员函数有很多好处，其中之一就是不受继承关系的限制。例如<code>Swift</code>的<code>Foundation</code>定义了<code>map</code>函数，可以运用在任何实现了<code>CollectionType</code>协议的类或者结构体上，而不需要有任何继承关系。</p>
<h1 id="Cold_and_Hot_Signals"><a href="#Cold_and_Hot_Signals" class="headerlink" title="Cold and Hot Signals"></a>Cold and Hot Signals</h1><p>在之前版本的<code>ReactiveCocoa</code>中，<code>cold signal</code>和<code>hot signal</code>两个概念都是用<code>RACSignal</code>来表示的，也经常会造成一些困惑。<code>ReactiveCocoa 3.0</code>通过显式的定义两种不同类型（<code>Signal</code>和<code>SignalProducer</code>）把二者区分开。为了理解<code>Signal</code>和<code>SignalProducer</code>之间的区别，我们用个实例比较一下。</p>
<h2 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">createSignal</span><span class="params">()</span></span> -&gt; <span class="type">Signal</span>&lt;<span class="type">String</span>, <span class="type">NoError</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">Signal</span> &#123;</span><br><span class="line">        sink <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Creating the timer signal"</span>)</span><br><span class="line">        <span class="type">NSTimer</span>.schedule(repeatInterval: <span class="number">0.1</span>) &#123;</span><br><span class="line">            timer <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Emitting a next event"</span>)</span><br><span class="line">            sendNext(sink, <span class="string">"tick #<span class="subst">\(<span class="built_in">count</span>++)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> signal = createSignal()</span><br></pre></td></tr></table></figure>
<p>现在我们即使没有为<code>signal</code>增加<code>observer</code>，它依然在创建和发射<code>event</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating the timer signal&#10;Emitting a next event&#10;Emitting a next event&#10;Emitting a next event&#10;...</span><br></pre></td></tr></table></figure></p>
<h2 id="Signal_Producer"><a href="#Signal_Producer" class="headerlink" title="Signal Producer"></a>Signal Producer</h2><p><code>SignalProducer</code>的初始化结构和<code>Signal</code>很类似：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">createSignalProducer</span><span class="params">()</span></span> -&gt; <span class="type">SignalProducer</span>&lt;<span class="type">String</span>, <span class="type">NoError</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">SignalProducer</span> &#123;</span><br><span class="line">        sink, disposable <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Creating the timer signal producer"</span>)</span><br><span class="line">        <span class="type">NSTimer</span>.schedule(repeatInterval: <span class="number">0.1</span>) &#123;</span><br><span class="line">            timer <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Emitting a next event"</span>)</span><br><span class="line">            sendNext(sink, <span class="string">"tick #<span class="subst">\(<span class="built_in">count</span>++)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> signalProducer = createSignalProducer()</span><br></pre></td></tr></table></figure></p>
<p>我们创建了一个<code>SignalProducer</code>但是没有任何的<code>observer</code>，会发现控制台丽没有任何输出，<code>timer</code>也没有被触发。<br><code>SignalProducer</code>可以看做是个工厂，可以通过调用<code>SignalProducer</code>的成员方法<code>start</code>，或者通过<code>pipe-forward</code>运算符调用<code>start</code>这个<code>free function</code>创建一个<code>Signal</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">signalProducer</span><br><span class="line">    |&gt; start(next: &#123;</span><br><span class="line">        <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，对于<code>Signal</code>，即使添加了多个<code>observer</code>，<code>timer</code>也只会触发一次；对于<code>SignalProducer</code>，每次<code>start</code>都会创建一个新的<code>timer</code>。<br>通常我们会用<code>SignalProducer</code>表示一个操作或者任务，<code>start</code>一个<code>SignalProducer</code>会启动这个操作；而<code>Signal</code>用来表示事件流，无论是否有<code>Observer</code>监听。<code>SignalProducer</code>非常适合于网络请求，而<code>Signal</code>则非常适合表示UI的事件流。</p>
<h1 id="Signal_producer_Operations"><a href="#Signal_producer_Operations" class="headerlink" title="Signal producer Operations"></a>Signal producer Operations</h1><p>和<code>Signal</code>一样，<code>SignalProducer</code>的操作也被定义成<code>curried free function</code>。<br>例如用来在pipline中插入副作用的<code>on</code>操作（为了可读性省略了一些函数参数）：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">on</span><span class="generics">&lt;T, E&gt;</span><span class="params">(started: <span class="params">(<span class="params">()</span></span></span></span> -&gt; ())? = <span class="literal">nil</span>, ...)</span><br><span class="line">             (producer: <span class="type">SignalProducer</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;) -&gt; <span class="type">SignalProducer</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>pipe-forward</code>运算符也为<code>SignalProducer</code>进行了重载：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> |&gt; <span class="generics">&lt;T, E, X&gt;</span><span class="params">(producer: SignalProducer&lt;T, E&gt;,</span><br><span class="line">                         transform: SignalProducer&lt;T, E&gt; -&gt; X)</span></span> -&gt; <span class="type">X</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> transform(producer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，我们可以像这样为<code>SignalProducer</code>创建pipeline：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">signalProducer</span><br><span class="line">    |&gt; on(started: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Signal has started"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    |&gt; start(next: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Next received: <span class="subst">\($<span class="number">0</span>)</span>"</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="Applying_Signal_Operations_to_Signal_Producers"><a href="#Applying_Signal_Operations_to_Signal_Producers" class="headerlink" title="Applying Signal Operations to Signal Producers"></a>Applying Signal Operations to Signal Producers</h1><p><code>SignalProducer</code>通过<code>lift</code>方法来复用<code>Signal</code>上的操作，例如<code>map</code>、<code>filter</code>等。<code>lift</code>会将<code>Signal</code>的操作应用在<code>SignalProducer</code>通过<code>start</code>创建的信号上。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> signalProducer = createSignalProducer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapping: <span class="type">Signal</span>&lt;<span class="type">String</span>, <span class="type">NoError</span>&gt; -&gt; <span class="type">Signal</span>&lt;<span class="type">Int</span>, <span class="type">NoError</span>&gt; = <span class="built_in">map</span>(&#123;</span><br><span class="line">    string <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">count</span>(string)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> mappedProducer = signalProducer.lift(mapping)</span><br><span class="line"></span><br><span class="line">mappedProducer</span><br><span class="line">    |&gt; start(next: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Next received: <span class="subst">\($<span class="number">0</span>)</span>"</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p><code>pipe-forward</code>运算符也为<code>SignalProducer</code>做了重载：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> |&gt;<span class="generics">&lt;T, E, U, F&gt;</span><span class="params">(producer: SignalProducer&lt;T, E&gt;, </span><br><span class="line">                          transform: Signal&lt;T, E&gt; -&gt; Signal&lt;U, F&gt;)</span></span> -&gt; <span class="type">SignalProducer</span>&lt;<span class="type">U</span>, <span class="type">F</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> producer.lift(transform)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，<code>Signal</code>的操作都可以直接通过<code>pipe-forward</code>应用在<code>SignalProducer</code>上：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">signalProducer</span><br><span class="line">    |&gt; on(started: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Signal has started"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    |&gt; <span class="built_in">map</span> &#123; <span class="built_in">count</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    |&gt; start(next: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Next received: <span class="subst">\($<span class="number">0</span>)</span>"</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文总结了《<a href="http://blog.scottlogic.com/2015/04/24/first-look-reactive-cocoa-3.html" target="_blank" rel="external">A FIRST LOOK AT REA]]>
    </summary>
    
      <category term="ReactiveCocoa" scheme="http://nightfade.github.io/tags/ReactiveCocoa/"/>
    
      <category term="iOS" scheme="http://nightfade.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Using Swift with Cocoa and Objective-C》学习笔记]]></title>
    <link href="http://nightfade.github.io/2015/08/28/notes-on-using-swift-with-cocoa-and-objective-c/"/>
    <id>http://nightfade.github.io/2015/08/28/notes-on-using-swift-with-cocoa-and-objective-c/</id>
    <published>2015-08-27T22:40:00.000Z</published>
    <updated>2016-01-18T08:04:15.000Z</updated>
    <content type="html"><![CDATA[<p>学习《<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/" target="_blank" rel="external">Using Swift with Cocoa and Objective-C</a>》的笔记。</p>
<h1 id="Interoperability"><a href="#Interoperability" class="headerlink" title="Interoperability"></a>Interoperability</h1><h2 id="Interacting_with_Objective-C_APIs"><a href="#Interacting_with_Objective-C_APIs" class="headerlink" title="Interacting with Objective-C APIs"></a>Interacting with Objective-C APIs</h2><h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><p>在Swift中初始化一个Objective-C的类：</p>
<ul>
<li>Objective-C中的<code>init</code>方法要删掉<code>init</code>前缀，只是表明这个方法是一个构造器。</li>
<li><code>initWith</code>开头的要连“With”一起删除。</li>
<li>删掉<code>initWith</code>之后的<code>selector</code>分片的第一个字母改成小写。并且作为参数名。</li>
<li>不需要调用<code>alloc</code>。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITableView</span> *myTableView = [[<span class="built_in">UITableView</span> alloc] initWithFrame:<span class="built_in">CGRectZero</span> style:<span class="built_in">UITableViewStyleGrouped</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTableView: <span class="type">UITableView</span> = <span class="type">UITableView</span>(frame: <span class="type">CGRectZero</span>, style: .<span class="type">Grouped</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>Objective-C中的工厂方法被映射为Swift中的<code>convenience initializer</code>。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *color = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.5</span> green:<span class="number">0.0</span> blue:<span class="number">0.5</span> alpha:<span class="number">1.0</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = <span class="type">UIColor</span>(red: <span class="number">0.5</span>, green: <span class="number">0.0</span>, blue: <span class="number">0.5</span>, alpha: <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Failable_Initialization"><a href="#Failable_Initialization" class="headerlink" title="Failable Initialization"></a>Failable Initialization</h4><p>Objective-C的构造器可以返回<code>nil</code>告知初始化失败，Swift通过可失败构造器达到相同的目的。Objective-C通过引入<code>Nullability and Optionals</code>语法表明构造器是不是可失败的，如果不可失败，Swift构造器是<code>init</code>，否则<code>init?</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> image = <span class="type">UIImage</span>(contentsOfFile: <span class="string">"MyImage.png"</span>) &#123;</span><br><span class="line">    <span class="comment">// loaded the imagesuccessfully</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// could not load the image</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Accessing_Properties"><a href="#Accessing_Properties" class="headerlink" title="Accessing Properties"></a>Accessing Properties</h3><ul>
<li>Objective-C中不同<code>nullability</code>特性的属性（<code>nonnull</code>，<code>nullable</code>，<code>null-resettable</code>）分别映射到Swift中的<code>optional</code>，<code>nonoptional</code>属性。</li>
<li>Objective-C的<code>readonly</code>属性导入到Swift变成<code>{ get }</code>的计算属性。</li>
<li>Objective-C的<code>weak</code>属性导入到Swift变成<code>weak var</code>属性。</li>
<li>Objective-C的<code>assign</code>、<code>copy</code>、<code>strong</code>、<code>unsafe_unretained</code>属性导入到Swift变成相应的存储属性。</li>
<li>Objective-C中的<code>atomic</code>和<code>nonatomic</code>在Swift中被忽略，全部都是<code>nonatomic</code>。</li>
<li>Objective-C中的<code>getter=</code>和<code>setter=</code>在Swift中被忽略。</li>
</ul>
<h3 id="Working_with_Methods"><a href="#Working_with_Methods" class="headerlink" title="Working with Methods"></a>Working with Methods</h3><ul>
<li>Objective-C中selector的第一部分作为相应Swift方法的方法名出现在括号外。</li>
<li>剩余的selector分片变成相应的参数名出现在括号内。</li>
<li>所有的selector分片在调用的时候都是必须有的。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[myTableView insertSubview:mySubview atIndex:<span class="number">2</span>];</span><br><span class="line">``` </span><br><span class="line">```swift</span><br><span class="line">myTableView<span class="variable">.insertSubview</span>(mySubview, atIndex: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="id_Compatibility"><a href="#id_Compatibility" class="headerlink" title="id Compatibility"></a>id Compatibility</h3><p>Swift有一个<code>AnyObject</code><em>协议</em>用来表示任意类型的对象，等价于Objective-C中的<code>id</code>。可以对其调用任意Objective-C的方法和访问任意属性而不需要强制转换成特定类型。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObjective: <span class="type">AnyObject</span> = <span class="type">UITableViewCell</span>()</span><br><span class="line">myObject = <span class="type">NSDate</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> futureDate = myObject.dateByAddingTimeInterval(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> timeSinceNow = myObject.timeIntervalSinceNow</span><br></pre></td></tr></table></figure></p>
<p>访问<code>AnyObject</code>不存在的方法或属性会触发<code>runtime error</code>，但是可以利用Swift的可选链消除错误。另外，访问<code>AnyObject</code>的属性总是返回一个可空值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myChar = myObject.characterAtIndex?(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
<p>也可以强制转换<code>AnyObject</code>到一个特定类型：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastRefreshDate: <span class="type">AnyObject</span>? = userDefaults.objectForKey(<span class="string">"LastRefreshDate"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> date = lastRefreshDate <span class="keyword">as</span>? <span class="type">NSDate</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Nullability_and_Options"><a href="#Nullability_and_Options" class="headerlink" title="Nullability and Options"></a>Nullability and Options</h3><p>Objective-C中引用对象的指针可以是<code>nil</code>，Swift中所有的对象都是非空的，如果要表示值缺失需要用<code>optional</code>类型。<br>Objective-C引入了<code>nullability</code>记号来表示一个参数、属性或者返回值是否可以<code>nil</code>。</p>
<ul>
<li>声明为<code>_Nonnull</code>或者包裹在<code>NS_ASSUME_NONNULL_BEGIN</code>和<code>NS_ASSUME_NONNULL_END</code>之间的类型被导入为Swift中的<code>non-optional</code>类型。</li>
<li>声明为<code>_Nullable</code>的类型被导入为Swift中的<code>optional</code>类型。</li>
<li>不带<code>nullability</code>记号的类型被导入为Swift肿的隐式<code>optional</code>类型。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (nullable) <span class="keyword">id</span> nullableProperty;</span><br><span class="line"><span class="keyword">@property</span> (nonnull) <span class="keyword">id</span> nonNullProperty;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">id</span> unannotatedProperty;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line">- (<span class="keyword">id</span>)returnsNonNullValue;</span><br><span class="line">- (<span class="keyword">void</span>)takesNonNullParameter:(<span class="keyword">id</span>)value;</span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br><span class="line">- (nullable <span class="keyword">id</span>)returnsNullableValue;</span><br><span class="line">- (<span class="keyword">void</span>)takeNullableParameter:(nullable <span class="keyword">id</span>)value;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)returnsUnannotatedValue;</span><br><span class="line">- (<span class="keyword">void</span>)takesUnannotatedParameter:(<span class="keyword">id</span>)value;</span><br></pre></td></tr></table></figure>
<p>导入为Swift:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableProperty: <span class="type">AnyObject</span>?</span><br><span class="line"><span class="keyword">var</span> nonNullProperty: <span class="type">AnyObject</span></span><br><span class="line"><span class="keyword">var</span> unannotatedProperty: <span class="type">AnyObject</span>!</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsNonNullValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesNonNullParameter</span><span class="params">(value: AnyObject)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsNullableValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>?</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesNullableParameter</span><span class="params">(value: AnyObject?)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsUnannotatedValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>!</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesUnannotatedParameter</span><span class="params">(value: AnyObject!)</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><p>Swift的<code>Extension</code>和Objective-C的<code>Category</code>类似。但是不能用<code>Extension</code>重写Objective-C中已经存在的方法和属性。</p>
<h3 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h3><p>Objective-C中的<code>block</code>被导入为Swift中的<code>closure</code>。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^completionBlock)(<span class="built_in">NSData</span> *, <span class="built_in">NSError</span> *) = ^(<span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>等价于：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> completionBlock: (<span class="type">NSData</span>, <span class="type">NSError</span>) -&gt; <span class="type">Void</span> = &#123; (data, error) <span class="keyword">in</span> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以把Swift的<code>closure</code>传给Objective-C中需要<code>block</code>的方法作为参数。</p>
<p><code>closure</code>捕获变量和<code>block</code>有一点不同：Objective-C中的<code>__block</code>行为在Swift是默认的。</p>
<h3 id="Object_Comparison"><a href="#Object_Comparison" class="headerlink" title="Object Comparison"></a>Object Comparison</h3><p>Swift的<code>==</code>比较运算符会调用Objective-C中<code>NSObject</code>定义的<code>isEqual:</code>方法。对于从<code>NSObject</code>继承来的类，应该实现相应的<code>isEqual:</code>方法。如果想要把对象用作字典的key，还需要实现<code>Hashable</code>协议中的<code>hashValue</code>属性。</p>
<h3 id="Swift_Type_Compatibility"><a href="#Swift_Type_Compatibility" class="headerlink" title="Swift Type Compatibility"></a>Swift Type Compatibility</h3><p>当从Objective-C的类创建一个Swift的类的时候，它的所有成员——属性、方法、下标和构造器都是可用的。但是如果要把Swift的类（不是从Objective-C的类继承来的，或者想改变借口的名字）暴露给Objective-C，就需要显式的指定<code>@objc</code>属性。</p>
<h4 id="Exposing_Swift_Interface_in_Objective-C"><a href="#Exposing_Swift_Interface_in_Objective-C" class="headerlink" title="Exposing Swift Interface in Objective-C"></a>Exposing Swift Interface in Objective-C</h4><p>如果Swift的类是从<code>NSObject</code>或者任意Objective-C的类继承来的，那这个类就自动和Objective-C兼容。否则，用<code>@objc</code>放在Swift的方法、属性、下标、构造器，或者类、枚举的声明之前。<code>@objc</code>还能为方法指定其他名称<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@objc</span>(<span class="type">SomeClass</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> 中文类名: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="preprocessor">@objc</span>(initWithName:)</span><br><span class="line">    <span class="keyword">init</span>(中文参数名: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="preprocessor">@objc</span>(hideNuts:inTree:)</span><br><span class="line">    <span class="func"><span class="keyword">func</span> 中文方法<span class="params">(参数<span class="number">1</span>: Int, 参数<span class="number">2</span>: Int)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Lightweight_Generics"><a href="#Lightweight_Generics" class="headerlink" title="Lightweight Generics"></a>Lightweight Generics</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSDate</span> *&gt; *dates;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *words;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSData</span> *&gt; *cachedData;</span><br></pre></td></tr></table></figure>
<p>Swift将导入为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dates: [<span class="type">NSDate</span>]</span><br><span class="line"><span class="keyword">var</span> words: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"><span class="keyword">var</span> cachedData: [<span class="type">NSURL</span>: <span class="type">NSData</span>]</span><br></pre></td></tr></table></figure></p>
<p>除了Foundation Collection的类以外，Objective-C中的lightweight generics都会被Swfit忽略。</p>
<h3 id="Objective-C_Selectors"><a href="#Objective-C_Selectors" class="headerlink" title="Objective-C Selectors"></a>Objective-C Selectors</h3><p>在Swift中，Objective-C的Selector被结构体<code>Selector</code>所表示。可以直接用字符串字面量构造一个Selector：<code>let mySelector: Selector = &quot;tappedButton:&quot;</code>。因为字符串字面量可以自动转换为Selector，所以可以把一个字符串字面量直接传给任意接收Selector参数的方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myButton.addTarget(<span class="keyword">self</span>, action: <span class="string">"tappedButton:"</span>, forControlEvents: .<span class="type">TouchUpInside</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="Writing_Swift_Classes_with_Objective-C_Behavior"><a href="#Writing_Swift_Classes_with_Objective-C_Behavior" class="headerlink" title="Writing Swift Classes with Objective-C Behavior"></a>Writing Swift Classes with Objective-C Behavior</h2><h3 id="Inheriting_from_Objective-C_Classes"><a href="#Inheriting_from_Objective-C_Classes" class="headerlink" title="Inheriting from Objective-C Classes"></a>Inheriting from Objective-C Classes</h3><p>Swift中可以直接定义Objective-C中类的子类。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySwiftViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要重写父类方法，需要加上<code>override</code>关键字。</p>
<h3 id="Adopting_Protocols"><a href="#Adopting_Protocols" class="headerlink" title="Adopting Protocols"></a>Adopting Protocols</h3><p>Swift可以采用Objective-C中定义的protocol。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySwiftViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为Swift中类的名字空间和protocol的名字空间是统一的，所以在Swift中，<code>NSObject</code>协议被映射为<code>NSObjectProtocol</code>。</p>
<h3 id="Integrating_with_Interface_Builder"><a href="#Integrating_with_Interface_Builder" class="headerlink" title="Integrating with Interface Builder"></a>Integrating with Interface Builder</h3><p>Swift中使用outlets和actions，只需要在属性前插入<code>@IBOutlet</code>或者<code>@IBAction</code>关键字。<code>@IBOutlet</code>使得属性编程隐式可选。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> button: <span class="type">UIButton</span>!</span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> textFields: [<span class="type">UITextField</span>]!</span><br><span class="line">    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">buttonTapped</span>:<span class="params">(<span class="number">_</span>: AnyObject)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"button tapped!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Specifying_Property_Attributes"><a href="#Specifying_Property_Attributes" class="headerlink" title="Specifying Property Attributes"></a>Specifying Property Attributes</h3><h4 id="Strong_and_Weak"><a href="#Strong_and_Weak" class="headerlink" title="Strong and Weak"></a>Strong and Weak</h4><p>Swift属性默认是<code>strong</code>的。用<code>weak</code>关键字指示属性是弱引用，并且该属性是可选类型。</p>
<h4 id="Read/Write_and_Read-Only"><a href="#Read/Write_and_Read-Only" class="headerlink" title="Read/Write and Read-Only"></a>Read/Write and Read-Only</h4><p>Swift里没有<code>readwrite</code>和<code>readonly</code>属性，如果声明存储属性，用<code>let</code>表示只读，用<code>var</code>表示可读可写。如果是计算属性，<code>{ get }</code>表示只读，<code>{ get set }</code>可读可写。</p>
<h4 id="Copy_Semantics"><a href="#Copy_Semantics" class="headerlink" title="Copy Semantics"></a>Copy Semantics</h4><p>Swift中，Objective-C的<code>copy</code>被转换成了<code>@NSCopying</code>，也就是说该属性必须符合<code>NSCopying</code>协议。</p>
<h3 id="Using_Swift_Class_Names_with_Objective-C_APIs"><a href="#Using_Swift_Class_Names_with_Objective-C_APIs" class="headerlink" title="Using Swift Class Names with Objective-C APIs"></a>Using Swift Class Names with Objective-C APIs</h3><p>Swift的类都放在他们所在的module的全局的命名空间里，在Objective-C引用也一样。例如，一个叫<code>MyFramework</code>的framework中的一个Swift的类<code>DataManager</code>的名字是<code>MyFramework.DataManager</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> muyPersonClass: <span class="type">AnyClass</span> = <span class="type">NSClassFromString</span>(<span class="string">"MyGreatApp.Person"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="Working_with_Cocoa_Data_Types"><a href="#Working_with_Cocoa_Data_Types" class="headerlink" title="Working with Cocoa Data Types"></a>Working with Cocoa Data Types</h2><p>Swift会自动的将一些Objective-C的类型转换为Swift的类型，也会把一些Swfit类型转换为Objective-C的类型，也有一些是可以直接互换的。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Swift自动的在<code>String</code>和<code>NSString</code>类型之间转换，不应该在Swift中使用<code>NSString</code>。<br>当Swift导入Objective-C的API的时候，会把所有的<code>NSString</code>类型替换成<code>String</code>。当Objective-C使用Swift类的时候，会把所有<code>String</code>类型替换成<code>NSString</code>。只需要<code>import Foundation</code>就可以开启两种类型的桥接。</p>
<h4 id="Localization"><a href="#Localization" class="headerlink" title="Localization"></a>Localization</h4><p>Swift中用一个函数<code>NSLocalizedString(key:tableName:bundle:value:comment:)</code>替换掉了Objective-C一组宏（<code>NSLocalizedString</code>、<code>NSLocalizedStringFromTable</code>、<code>NSLocalizedStringFromTableInBundle</code>、<code>NSLocalizedStringWithDefaultValue</code>），其中为<code>tableName</code>、<code>bundle</code>、<code>value</code>都提供了默认值。</p>
<h3 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h3><p>Swift自动把<code>Int</code>、<code>Float</code>等数值类型桥接到<code>NSNumber</code>。可以用这些数值类型创建<code>NSNumber</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">42</span></span><br><span class="line"><span class="keyword">let</span> m: <span class="type">NSNumber</span> = n</span><br></pre></td></tr></table></figure></p>
<h3 id="Collection_Classes"><a href="#Collection_Classes" class="headerlink" title="Collection Classes"></a>Collection Classes</h3><p>Swift把<code>NSArray</code>、<code>NSSet</code>、<code>NSDictionary</code>分别桥接到<code>Array</code>、<code>Set</code>、<code>Dictionary</code>。</p>
<h4 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h4><p>如果<code>NSArray</code>指定了参数化类型，则对应到Swift中的<code>[ObjectType]</code>，否则对应到<code>[AnyObject]</code>。可以用<code>as?</code>或者<code>as!</code>把<code>[AnyObject]</code>转换到<code>[SomeType]</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swiftArray = foundationArray <span class="keyword">as</span> [<span class="type">AnyObject</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> downcastedSwiftArray = swiftArray <span class="keyword">as</span>? [<span class="type">NSView</span>] &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要把Swift数组转换成<code>NSArray</code>，数组里的元素必须是符合<code>AnyObject</code>协议的。将Swift API导入Objective-C的时候，会把所有<code>Array</code>替换成<code>NSArray</code>。</p>
<h4 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h4><p><code>Set&lt;ObjectType&gt;</code>对应<code>NSSet&lt;ObjectType&gt;</code>，如果没有指定<code>ObjectType</code>，则对应到<code>Set&lt;AnyObject&gt;</code></p>
<h4 id="Dictionaries"><a href="#Dictionaries" class="headerlink" title="Dictionaries"></a>Dictionaries</h4><p><code>NSDictionary</code>如果没有指定参数化类型，则对应到<code>[NSObject: AnyObject]</code></p>
<h3 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h3><p>Swift把<code>ErrorType</code>（协议）和<code>NSError</code>进行桥接。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@objc</span> <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CustomError</span>: <span class="title">Int</span>, <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应到相应的Objective-C的声明：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> SWIFT_ENUM(<span class="built_in">NSInteger</span>, CustomError) &#123;</span><br><span class="line">    CustomErrorA = <span class="number">0</span>,</span><br><span class="line">    CustomErrorB = <span class="number">1</span>,</span><br><span class="line">    CustomErrorC = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> String * <span class="keyword">const</span> CustomErrorDomain = <span class="string">@"Project.CustomError"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Foundation_Data_Types"><a href="#Foundation_Data_Types" class="headerlink" title="Foundation Data Types"></a>Foundation Data Types</h3><p>Swift对Foundation Framework中的数据类型做了封装。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> size = <span class="type">CGSize</span>(width: <span class="number">20</span>, height: <span class="number">40</span>)</span><br><span class="line"><span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">50</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> width = rect.width <span class="comment">// 等价于CGRectGetWidth(rect)</span></span><br><span class="line"><span class="keyword">let</span> maxX = rect.maxY <span class="comment">// 等价于CGRectGetMaxY(rect)</span></span><br></pre></td></tr></table></figure></p>
<p>还把<code>NSUInteger</code>和<code>NSInteger</code>桥接到<code>Int</code>。</p>
<h3 id="Core_Foundation"><a href="#Core_Foundation" class="headerlink" title="Core Foundation"></a>Core Foundation</h3><h4 id="u91CD_u6620_u5C04_u7C7B_u578B_uFF1A"><a href="#u91CD_u6620_u5C04_u7C7B_u578B_uFF1A" class="headerlink" title="重映射类型："></a>重映射类型：</h4><p>Swift导入Core Foundation类型的时候，编译器吧类型名中的<code>Ref</code>移除。</p>
<h4 id="u5185_u5B58_u7BA1_u7406"><a href="#u5185_u5B58_u7BA1_u7406" class="headerlink" title="内存管理"></a>内存管理</h4><p>Swift中使用Core Foundation中<code>annotated</code>的API返回的对象会自动处理内存管理，不需要调用<code>CFRetain</code>、<code>CFRelase</code>或者<code>CFAutorelase</code>。<br>其他情况需要处理<code>Unmanaged&lt;Instance&gt;</code>。</p>
<h3 id="u9519_u8BEF_u5904_u7406"><a href="#u9519_u8BEF_u5904_u7406" class="headerlink" title="错误处理"></a>错误处理</h3><p>Cocoa中，会产生错误的方法把<code>NSError</code>指针作为最后一个参数，如果Objective-C方法的最后一个非block的参数是<code>NSError **</code>，Swift就把它替换成<code>throws</code>关键字，如果同时还是第一个关键字，会尝试简化方法名字，比如删除<code>WithError</code>或者<code>AndReturnError</code>后缀。如果这样的方法返回<code>BOOL</code>值表示方法成功或者失败，Swift会把返回值改成<code>Void</code>，如果返回<code>nil</code>表示失败，Swift会把返回值类型替换成<code>non-optional</code>类型。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)removeItemAtURL:(<span class="built_in">NSURL</span> *)URL error:(<span class="built_in">NSError</span> **)error;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">removeItemAtURL</span><span class="params">(URL: NSURL)</span></span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure>
<h2 id="Key-Value_Observing"><a href="#Key-Value_Observing" class="headerlink" title="Key-Value Observing"></a>Key-Value Observing</h2><p>Swift中可以对继承自<code>NSObject</code>的类使用KVO，用<code>dynamic</code>关键字表明属性是需要<code>observe</code>的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObjectToObserve</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> myDate = <span class="type">NSDate</span>()</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">updateDate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        myDate = <span class="type">NSDate</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> myContext = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> objectToObserve = <span class="type">MyObjectToObserve</span>()</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        objectToObserve.addObserver(<span class="keyword">self</span>, forKeyPath:<span class="string">"myDate"</span>, options: .<span class="type">New</span>, context: &amp;myContext)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">observeValueForKeyPath</span><span class="params">(keyPath:String?, ofObject object: AnyObject?, change: [String: AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        objectToObserve.removeObserver(<span class="keyword">self</span>, forKeyPath:<span class="string">"MyDate"</span>, context: &amp;myContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance: <span class="type">Singleton</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> instance = <span class="type">Singleton</span>()</span><br><span class="line">        <span class="comment">// setup code</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>学习《<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/" target="_blank" rel="external">Usi]]>
    </summary>
    
      <category term="Swift" scheme="http://nightfade.github.io/tags/Swift/"/>
    
      <category term="iOS" scheme="http://nightfade.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发中的Promise模式]]></title>
    <link href="http://nightfade.github.io/2015/08/12/ios-promise/"/>
    <id>http://nightfade.github.io/2015/08/12/ios-promise/</id>
    <published>2015-08-12T12:29:00.000Z</published>
    <updated>2016-01-18T08:04:10.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u4EC0_u4E48_u662FPromise"><a href="#u4EC0_u4E48_u662FPromise" class="headerlink" title="什么是Promise"></a>什么是Promise</h1><p>借用<a href="http://promisekit.org" target="_blank" rel="external"><code>PromiseKit</code></a>文档中的定义：</p>
<blockquote>
<p>A promise represents the future value of an asynchronous task.</p>
</blockquote>
<p>如果去Google一下<code>Promise模式</code>关键字，会发现基本都是和<code>JavaScript</code>相关的，在<code>JavaScript</code>中，<code>Promise</code>模式应用的非常多，因为<code>JavaScript</code>语言自身的特点（函数是一等对象），以及运行环境（浏览器，Node.js）决定了在<code>JavaScript</code>里异步操作运用的非常多，所以很多<code>JavaScript</code>开发者也想了很多办法更好的管理这些异步操作，<code>Promise</code>模式是其中最简洁有效的一种。</p>
<p>在iOS开发中，同样会面临和<code>JavaScript</code>运行环境类似的问题。作为客户端开发，我们必须要保证用户界面流畅不卡顿，所以要尽量避免有长时间运行的操作阻塞主线程。那使用的方式就是把耗时比较长的比如I/O操作、网络请求、数据库查询之类的操作放到后台线程里去做，等操作完成之后再通知主线程更新UI。这些放到后台里任务就构成了一系列异步操作。最传统的处理异步任务的方式是使用回调(<code>Callback</code>)。回调本身没什么问题，但是使用回调的异步操作代码相对来说更难看了。</p>
<p>编造一个真实场景的例子，假设我们要处理一个用户登录的流程：</p>
<ol>
<li>首先向服务器发起网络请求验证用户的账号密码。</li>
<li>验证成功之后查询本地数据库里有没有用户的相关信息：<br> a. 如果没有，向服务器发起网络请求拉取用户信息.<br> b. 如果有，把本地用户数据的时间戳发送给服务器检查需不需要更新数据，如果需要的话同样也做一次数据拉取。</li>
<li>拉取用户信息成功之后，把拉取到用户信息写回到数据库。</li>
</ol>
<p>整个流程中还需要考虑每一步的错误处理。</p>
<p>如果不考虑主线程阻塞的问题，就可以这么写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSync &#123; </span><br><span class="line">    <span class="built_in">BOOL</span> loginSuccess = [_client loginWithUsername:<span class="string">@"aUser"</span> andPassword:<span class="string">@"123456"</span>];</span><br><span class="line">    <span class="keyword">if</span> (!loginSuccess) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"登录验证失败！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">id</span> userData = [_db queryWithUsername:<span class="string">@"aUser"</span>];</span><br><span class="line">    <span class="built_in">BOOL</span> needFetch = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (userData) &#123;</span><br><span class="line">        <span class="built_in">NSNumber</span> * timestamp = [userData timestamp];</span><br><span class="line">        needFetch = [_client checkTimestamp:timestamp];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needFetch) &#123;</span><br><span class="line">        <span class="keyword">id</span> userData = [_client fetchUserData];</span><br><span class="line">        [_db writeUserData:userData];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"操作成功"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整个流程写下来非常清晰。但是真实情况下，为了避免阻塞线程，我们都会把网络操作、I/O操作包括数据库操作等等写成异步接口，这种情况下我们再看下代码要怎么写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doAsync &#123;</span><br><span class="line">    [_client loginWithUsername:<span class="string">@"aUser"</span> andPassword:<span class="string">@"123456"</span> result:^(<span class="built_in">BOOL</span> success)&#123;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            [_db queryWithUsername:<span class="string">@"aUser"</span> result:^(<span class="keyword">id</span> userData)&#123;</span><br><span class="line">                <span class="keyword">if</span> (userData) &#123;</span><br><span class="line">                    <span class="built_in">NSNumber</span> * timestamp = [userData timestamp];</span><br><span class="line">                    [_client checkTimestamp:timestamp result:^(<span class="built_in">BOOL</span> needFetch)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (needFetch) &#123;</span><br><span class="line">                            [_client fetchUserDataWithResult:^(<span class="keyword">id</span> userData)&#123;</span><br><span class="line">                                [_db writeUserData:userData result:^&#123;</span><br><span class="line">                                    <span class="built_in">NSLog</span>(<span class="string">@"操作成功!"</span>);                                </span><br><span class="line">                                &#125;]                            </span><br><span class="line">                            &#125;];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="built_in">NSLog</span>(<span class="string">@"操作成功!"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;];                </span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"登录失败！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后再看一下用了<code>Promise</code>模式的异步接口，代码是什么样子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doPromiseAsync &#123;</span><br><span class="line">    P<span class="built_in">MKPromise</span> *loginPromise = [_client loginWithUsername:<span class="string">@"aUser"</span> andPassword:<span class="string">@"123456"</span>];</span><br><span class="line">    P<span class="built_in">MKPromise</span> * queryPromise = loginPromise<span class="variable">.then</span>(^&#123;</span><br><span class="line">        <span class="keyword">return</span> [_db queryWithUsername:<span class="string">@"aUser"</span>];    </span><br><span class="line">    &#125;);</span><br><span class="line">    P<span class="built_in">MKPromise</span> * checkPromise = queryPromise<span class="variable">.then</span>(^(<span class="keyword">id</span> userData)&#123;</span><br><span class="line">        <span class="keyword">if</span> (userData) &#123;</span><br><span class="line">            <span class="built_in">NSNumber</span> * timestamp = [userData timestamp];</span><br><span class="line">            <span class="keyword">return</span> [_client checkTimestamp:timestamp];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    P<span class="built_in">MKPromise</span> * needFetchPromise = checkPromise<span class="variable">.then</span>(^(<span class="built_in">BOOL</span> needFetch)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!needFetch) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        P<span class="built_in">MKPromise</span> * fetchPromise = [_client fetchUserData];</span><br><span class="line">        P<span class="built_in">MKPromise</span> * writePromise = fetchPromise<span class="variable">.then</span>(^(<span class="keyword">id</span> userData)&#123;</span><br><span class="line">            <span class="keyword">return</span> [_db writeUserData:userData];    </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    needFetchPromise<span class="variable">.then</span>(^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"操作成功！"</span>);</span><br><span class="line">    &#125;)<span class="variable">.catch</span>(^(<span class="built_in">NSError</span> *err)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"操作失败：%@"</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>Promise</code>构建的异步操作的代码结构变得和同步接口很相似了，调用异步接口直接通过返回值返回一个<code>Promise</code>对象，这个对象‘保证‘会把相应异步操作会在将来到来的结果的值，通过<code>then</code>方法交给后续的调用。<code>Promise</code>支持链式调用，所以上面的例子中，我们可以省略中间变量，写成下面这种更简洁的方式：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doPromiseAsync &#123;</span><br><span class="line">    [_client loginWithUsername:<span class="string">@"aUser"</span> andPassword:<span class="string">@"123456"</span>]<span class="variable">.then</span>(^&#123;</span><br><span class="line">        <span class="keyword">return</span> [_db queryWithUsername:<span class="string">@"aUser"</span>];    </span><br><span class="line">    &#125;)<span class="variable">.then</span>(^(<span class="keyword">id</span> userData)&#123;</span><br><span class="line">        <span class="keyword">if</span> (userData) &#123;</span><br><span class="line">            <span class="built_in">NSNumber</span> * timestamp = [userData timestamp];</span><br><span class="line">            <span class="keyword">return</span> [_client checkTimestamp:timestamp];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)<span class="variable">.then</span>(^(<span class="built_in">BOOL</span> needFetch)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!needFetch) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> [_client fetchUserData]<span class="variable">.then</span>(^(<span class="keyword">id</span> userData)&#123;</span><br><span class="line">            <span class="keyword">return</span> [_db writeUserData:userData];    </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)<span class="variable">.then</span>(^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"操作成功！"</span>);</span><br><span class="line">    &#125;)<span class="variable">.catch</span>(^(<span class="built_in">NSError</span> *err)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"操作失败：%@"</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简而言之，使用<code>Promise</code>模式写异步操作，避免了层层嵌套的回调，使得代码结构和逻辑更直接更清晰。像使用同步接口一样，代码的书写顺序就是代码的执行顺序。</p>
<h1 id="PromiseKit_u7684_u57FA_u672C_u4F7F_u7528"><a href="#PromiseKit_u7684_u57FA_u672C_u4F7F_u7528" class="headerlink" title="PromiseKit的基本使用"></a>PromiseKit的基本使用</h1><p>直接引用<a href="http://promisekit.org" target="_blank" rel="external"><code>PromiseKit</code></a>首页的说明：</p>
<blockquote>
<p>PromiseKit is not just a promises implementation, it is also a collection of helper functions that make the typical asynchronous patterns we use as iOS developers delightful too.</p>
</blockquote>
<p>首先看一下<code>Promise</code>对象<code>PMKPromise</code>的主要接口：</p>
<h2 id="then"><a href="#then" class="headerlink" title="then"></a><code>then</code></h2><p><code>then</code>用来传入异步操作完成之后对结果的操作的Block。例如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIAlertView</span> *alertView = [<span class="built_in">UIAlertView</span> …];</span><br><span class="line">[alertView promise]<span class="variable">.then</span>(^(<span class="built_in">NSNumber</span> *dismissedIndex)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index %@ pressed."</span>, dismissedIndex);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Block的返回值可以是任意对象类型，值类型，<code>PMKPromise</code>对象类型，或者<code>NSError</code>类型。<code>then</code>的返回值也是<code>PMKPromise</code>类型。为了方便描述，假设原<code>PMKPromise</code>对象是<code>A</code>，<code>A</code>的<code>then</code>方法返回的<code>PMKPromise</code>对象是<code>B</code>。</p>
<ul>
<li>如果Block的返回值是对象类型或者值类型，那么<code>B</code>也会进一步向后传递这个值或者对象给<code>then</code>的Block。</li>
<li>如果Block的返回值也是<code>PMKPromise</code>对象，称作<code>C</code>，那么会首先执行<code>C</code>对应的异步操作，再把将<code>C</code>的Block的返回值传递给<code>B</code>。</li>
<li>如果Block的返回值类型是<code>NSError</code>，那么将触发错误处理流程。这部分在错误处理的章节会做详细说明。</li>
</ul>
<p>举例说明：</p>
<ol>
<li><p>Block返回值是值/对象类型：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[alertView promise]<span class="variable">.then</span>(^(<span class="built_in">NSNumber</span> *dismissedIndex)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index %@ pressed."</span>, dismissedIndex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.contacts</span>[dismissedIndex<span class="variable">.integerValue</span>];</span><br><span class="line">&#125;)<span class="variable">.then</span>(^(<span class="keyword">id</span> contact)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"contact name: %@ pressed."</span>, [contact name]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Block返回值类型也是<code>PMKPromise</code>类型：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[alertView promise]<span class="variable">.then</span>(^(<span class="built_in">NSNumber</span> *dismissedIndex)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index %@ pressed."</span>, dismissedIndex);</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span><span class="variable">.client</span> promiseQueryCotactAtIndex:dismissedIndex];</span><br><span class="line">&#125;)<span class="variable">.then</span>(^(<span class="keyword">id</span> contact)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"contact name: %@ pressed."</span>, [contact name]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a><code>catch</code></h2><p>如果调用链上某个Block返回值类型是<code>NSError</code>类型，<code>NSError</code>对象会直接跳过调用链上的<code>then</code>方法向下传递，直到遇到<code>catch</code>方法进行处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[alertView promise]<span class="variable">.then</span>(^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *dismissedIndex)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index %@ pressed."</span>, dismissedIndex);</span><br><span class="line">    <span class="keyword">if</span> (dismissedIndex &lt; <span class="keyword">self</span><span class="variable">.contacts</span><span class="variable">.count</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.contacts</span>[dismissedIndex<span class="variable">.integerValue</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSDemoErrorDomain</span> code:<span class="number">123</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="variable">.then</span>(^(<span class="keyword">id</span> contact)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"contact name: %@ pressed."</span>, [contact name]);</span><br><span class="line">&#125;)<span class="variable">.catch</span>(^(<span class="built_in">NSError</span> *err)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"error occurred with code: %@"</span>, @(err<span class="variable">.code</span>));    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>catch</code>方法除了可以进行错误处理，甚至还可以进行错误恢复。如果<code>catch</code>方法有非<code>NSError</code>的返回值，那就暗示着错误已经被处理了，所以后续的调用链会继续执行：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[alertView promise]<span class="variable">.then</span>(^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *dismissedIndex)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index %@ pressed."</span>, dismissedIndex);</span><br><span class="line">    <span class="keyword">if</span> (dismissedIndex &lt; <span class="keyword">self</span><span class="variable">.contacts</span><span class="variable">.count</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.contacts</span>[dismissedIndex<span class="variable">.integerValue</span>]<span class="variable">.name</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSDemoErrorDomain</span> code:<span class="number">123</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="variable">.catch</span>(^(<span class="built_in">NSError</span> *err)&#123;</span><br><span class="line">    <span class="keyword">if</span> (err<span class="variable">.code</span> == <span class="number">123</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@"Unknown Name"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// return err;</span></span><br><span class="line">        <span class="keyword">@throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="variable">.then</span>(^(<span class="built_in">NSString</span> * contactName)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"contact name: %@ pressed."</span>, contactName);</span><br><span class="line">&#125;)<span class="variable">.catch</span>(^(<span class="built_in">NSError</span> *err)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"fatal error: %@"</span>, @(err<span class="variable">.code</span>));    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p><code>finally</code>是<code>then</code>和<code>catch</code>的补充，无论调用链最终执行<code>then</code>还是<code>catch</code>，<code>finally</code>的代码块始终都会得到执行：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[alertView promise]<span class="variable">.then</span>(^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *dismissedIndex)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index %@ pressed."</span>, dismissedIndex);</span><br><span class="line">    <span class="keyword">if</span> (dismissedIndex &lt; <span class="keyword">self</span><span class="variable">.contacts</span><span class="variable">.count</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.contacts</span>[dismissedIndex<span class="variable">.integerValue</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSDemoErrorDomain</span> code:<span class="number">123</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="variable">.then</span>(^(<span class="keyword">id</span> contact)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"contact name: %@ pressed."</span>, [contact name]);</span><br><span class="line">&#125;)<span class="variable">.catch</span>(^(<span class="built_in">NSError</span> *err)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"error occurred with code: %@"</span>, @(err<span class="variable">.code</span>));    </span><br><span class="line">&#125;)<span class="variable">.finally</span>(^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"operation completed."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>了解了<code>PMKPromise</code>的主要对象，我们看一下怎么封装我们自己的<code>Promise</code>模式的异步API：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (P<span class="built_in">MKPromise</span> *)users &#123;</span><br><span class="line">    <span class="keyword">return</span> [P<span class="built_in">MKPromise</span> promiseWithResolverBlock:^(P<span class="built_in">MKResolver</span> resolve) &#123;</span><br><span class="line">        <span class="built_in">AVQuery</span> *query = [<span class="built_in">AVUser</span> query];</span><br><span class="line">        [query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *objects, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">            resolve(error ?: objects);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>PMKPromise</code>对象的<code>promiseWithResolverBlock</code>方法会传入的<code>resolve</code>参数，我们可以在异步操作完成的时候，讲异步操作的结果传给<code>resolve</code>。如果传入的是非<code>NSError</code>对象，那么就触发后续的<code>then</code>，否则触发后续的<code>catch</code>。</p>
<h1 id="PromiseKit_u8FDB_u9636"><a href="#PromiseKit_u8FDB_u9636" class="headerlink" title="PromiseKit进阶"></a>PromiseKit进阶</h1><h2 id="Dispatch_Queues"><a href="#Dispatch_Queues" class="headerlink" title="Dispatch Queues"></a>Dispatch Queues</h2><p>现在我们来讨论一下<code>PromiseKit</code>与<code>GCD</code>。之前我们看到的<code>PMKPromise</code>的<code>then</code>方法默认都是执行在主线程上的，但是我们可以很容易的通过<code>thenOn</code>方法把这些代码的执行<code>dispatch</code>到其他线程，例如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> url = <span class="string">@"http://www.baidu.com/test.png"</span>;</span><br><span class="line"><span class="keyword">id</span> q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">[<span class="built_in">NSURLConnection</span> GET:url]<span class="variable">.thenOn</span>(q, ^(<span class="built_in">UIImage</span> *image)&#123;</span><br><span class="line">    assert(![<span class="built_in">NSThread</span> isMainThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>PromiseKit</code>方法还提供了<code>thenInBackground</code>的便利函数，把后续的执行<code>dispatch</code>到<code>GCD</code>的<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>队列。</p>
<h2 id="when"><a href="#when" class="headerlink" title="when"></a><code>when</code></h2><p>之前我们例子里通过<code>then</code>去串行执行异步操作。很多时候我们还需要并行执行异步操作，等所有异步操作都执行完毕以后再继续后续操作。这时候就用到<code>when</code>方法，举例说明：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> search1 = [[[<span class="built_in">MKLocalSearch</span> alloc] initWithRequest:rq1] promise];</span><br><span class="line"><span class="keyword">id</span> search2 = [[[<span class="built_in">MKLocalSearch</span> alloc] initWithRequest:rq2] promise];</span><br><span class="line"><span class="comment">// PMKWhen(@[a, b]) 等价于 [PMKPromise when:@[a, b]]</span></span><br><span class="line">P<span class="built_in">MKWhen</span>(@[search1, search2])<span class="variable">.then</span>(^(<span class="built_in">NSArray</span> *results)&#123;</span><br><span class="line">    <span class="keyword">id</span> resultOfSearch1 = results[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">id</span> resultOfSearch2 = results[<span class="number">1</span>];</span><br><span class="line">&#125;)<span class="variable">.catch</span>(^(<span class="built_in">NSError</span> *error)&#123;</span><br><span class="line">    <span class="comment">// called if either search fails</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>至此，<code>PromiseKit</code>的常用的方法基本就是这些，其他更多的用法，可以参考<a href="http://promisekit.org" target="_blank" rel="external"><code>PromiseKit</code>文档</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u4EC0_u4E48_u662FPromise"><a href="#u4EC0_u4E48_u662FPromise" class="headerlink" title="什么是Promise"></a>什么是Promise</h1><p>借用<a href=]]>
    </summary>
    
      <category term="iOS" scheme="http://nightfade.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS应用内购买IAP接入]]></title>
    <link href="http://nightfade.github.io/2015/08/09/ios-in-app-purchase/"/>
    <id>http://nightfade.github.io/2015/08/09/ios-in-app-purchase/</id>
    <published>2015-08-08T20:55:12.000Z</published>
    <updated>2016-01-18T08:04:06.000Z</updated>
    <content type="html"><![CDATA[<p>本文主要讲解iOS应用接入应用内购买的基本实现。<br>首先需要在应用后台做一些配置工作，这部分就不做详细步骤的说明，只列出需要完成的工作：</p>
<ol>
<li>在<a href="https://developer.apple.com/" target="_blank" rel="external">developer.apple.com</a>为应用创建APP ID。</li>
<li>在<a href="https://itunesconnect.apple.com/" target="_blank" rel="external">iTunes Connect</a>中，创建一个新的应用。</li>
<li>在该应用中，创建应用内付费项目，然后设置好价格和<code>ProductID</code>，以及其他相关信息，这里的<code>ProductID</code>在之后的开发中会用到。</li>
<li>添加一个<code>Test User</code>用作之后<code>SandBox</code>付费的测试用户。</li>
</ol>
<p>配置工作完成后，就进入开发阶段。<br>IAP的接入依赖于<code>StoreKit.framework</code>，因此需要在工程中引入<code>StoreKit.framework</code>。<br>相关的几个主要对象有：</p>
<ul>
<li><code>SKProduct</code>：商品信息，包括价格、商品名称、描述等。</li>
<li><code>SKProductRequest</code>：发起网络请求，从<code>App Store</code>获取商品信息。</li>
<li><code>SKPaymentQueue</code>：支付执行队列，用来发起支付操作。</li>
<li><code>SKPaymentTransaction</code>：交易对象，每次支付交易对应一个交易对象。</li>
</ul>
<p>IAP的基本流程如下。<br>首先，根据之前配置好的<code>ProductID</code>，这里假定为<code>com.demo.product</code>，从<code>App Store</code>获取商品信息，即<code>SkProduct</code>对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SKProductRequest * _productsRequest;</span></span><br><span class="line">- (<span class="keyword">void</span>)requestProducts &#123;</span><br><span class="line">    <span class="built_in">NSSet</span> * productIdentifiers = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"objc"</span>, <span class="literal">nil</span>];</span><br><span class="line">    _productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers];</span><br><span class="line">    _productsRequest<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    [_productsRequest start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>SKProductRequest</code>获取商品信息成功/失败后，会调用该对象的<code>delegate</code>(实现了<code>&lt;SKProductsRequestDelegate&gt;</code>)的回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - SKProductsRequestDelegate</span></span><br><span class="line">- (<span class="keyword">void</span>)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Loaded list of products..."</span>);</span><br><span class="line">    _productsRequest = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> * skProducts = response<span class="variable">.products</span>;</span><br><span class="line">    <span class="keyword">for</span> (SKProduct * skProduct <span class="keyword">in</span> skProducts) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Found product: %@ %@ %@ %0.2f"</span>,</span><br><span class="line">              skProduct<span class="variable">.productIdentifier</span>,</span><br><span class="line">              skProduct<span class="variable">.localizedTitle</span>,</span><br><span class="line">              skProduct<span class="variable">.priceLocale</span>,</span><br><span class="line">              skProduct<span class="variable">.price</span><span class="variable">.floatValue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)request:(SKRequest *)request didFailWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Failed to load list of products."</span>);</span><br><span class="line">    _productsRequest = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果请求成功，我们就已经得到了<code>SKProduct</code>对象，接下来可以发起购买请求：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)buyProduct:(SKProduct *)product &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Buying %@..."</span>, product<span class="variable">.productIdentifier</span>);</span><br><span class="line">    SKPayment * payment = [SKPayment paymentWithProduct:product];</span><br><span class="line">    [[SKPaymentQueue defaultQueue] addPayment:payment];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>SKPaymentQueue</code>处理购买请求的结果是通过回调<code>Observer</code>（实现了<code>&lt;SKPaymentTransactionObserver&gt;</code>）来通知的。这里需要处理的两种可能情况：</p>
<ol>
<li>当下发起的购买请求，保持程序运行状态，最终等到返回的购买结果。</li>
<li>发起购买请求后，尚未等到返回的购买结果之前，就退出了程序（主动退出，或者程序崩溃）。</li>
</ol>
<p>对于第二种情况，<code>StoreKit</code>的处理逻辑是，在程序启动后，为标记完成的<code>Transaction</code>会重新回调<code>Observer</code>进行处理。因此需要保证在程序启动时注册<code>SKPaymentQueue</code>的<code>Observer</code>。因此我们在<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions;</code>中完成这一操作：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[SKPaymentQueue defaultQueue] addTransactionObserver:observer];</span><br></pre></td></tr></table></figure></p>
<p>并在<code>Observer</code>中实现相关回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - SKPaymentTransactionObserver</span></span><br><span class="line">- (<span class="keyword">void</span>)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(<span class="built_in">NSArray</span> *)transactions &#123;</span><br><span class="line">    <span class="keyword">for</span> (SKPaymentTransaction * transaction <span class="keyword">in</span> transactions) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (transaction<span class="variable">.transactionState</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> SKPaymentTransactionStatePurchased:</span><br><span class="line">                [<span class="keyword">self</span> completeTransaction:transaction];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SKPaymentTransactionStateRestored:</span><br><span class="line">                [<span class="keyword">self</span> restoreTransaction:transaction];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SKPaymentTransactionStateFailed:</span><br><span class="line">                [<span class="keyword">self</span> failedTransaction:transaction];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - Callbacks</span></span><br><span class="line">- (<span class="keyword">void</span>)completeTransaction:(SKPaymentTransaction *)transaction &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"complete transaction..."</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> verify transaction receipts, provide contents</span></span><br><span class="line">    [[SKPaymentQueue defaultQueue] finishTransaction:transaction];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)restoreTransaction:(SKPaymentTransaction *)transaction &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"restore transaction..."</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> verify transaction receipts, provide contents</span></span><br><span class="line">    [[SKPaymentQueue defaultQueue] finishTransaction:transaction];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)failedTransaction:(SKPaymentTransaction *)transaction &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"failed transaction..."</span>);</span><br><span class="line">    [[SKPaymentQueue defaultQueue] finishTransaction:transaction];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之前提到，如果没有将<code>Transaction</code>标记完成，每次程序启动后，都会调用<code>Observer</code>的回调继续处理该<code>Transaction</code>。因此在交易完成，已经提供给用户商品或者确认交易已经失败之后调用:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[SKPaymentQueue defaultQueue] finishTransaction:transaction];</span><br></pre></td></tr></table></figure></p>
<p>讲交易标记成完成。</p>
<p>另外这里还需要注意的一点是，考虑到伪造交易<code>Receipt</code>的问题，如果应用有服务端，可以考虑将<code>Receipt</code>传给服务端，并由服务端向<code>App Store</code>通过<code>HTTP API</code>发起<code>Receipt</code>验证请求，以<code>Node.js</code>为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> makeRequest = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"></span><br><span class="line">makeRequest(&#123;</span><br><span class="line">        url: <span class="string">'https://buy.itunes.apple.com/verifyReceipt'</span>,</span><br><span class="line">        method: <span class="string">'POST'</span>,</span><br><span class="line">        json: &#123;<span class="string">'receipt-data'</span>:receipt&#125;,</span><br><span class="line">        headers: &#123;<span class="string">"content-type"</span>: <span class="string">"application/json"</span>&#125;</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, httpResponse, body</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'request error: '</span> + err.message);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (body.status === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'valid receipt'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'invalid receipt'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>App Store</code>正式环境验证URL是<code>https://buy.itunes.apple.com/verifyReceipt</code> ，测试环境验证URL是：<code>https://sandbox.itunes.apple.com/verifyReceipt</code>。</p>
<p>对于非消耗商品（Non-Consumable），Apple要求必须实现<code>Restore</code>功能，即用户在其他设备上购买的商品，更换设备后，可以在新的设备上直接取回已购的商品。实现<code>Restore</code>很简单：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[SKPaymentQueue defaultQueue] restoreCompletedTransactions];</span><br></pre></td></tr></table></figure></p>
<p>该操作完成后也同样会调用<code>&lt;SKPaymentTransactionObserver&gt;</code>的<br><code>- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray *)transactions;</code>回调，且<code>transaction.transactionState == SKPaymentTransactionStateRestored</code>，可由此触发我们自己的<code>Restore</code>逻辑。</p>
<p>最后，由于IAP测试的特殊性，还有一些问题需要注意。</p>
<ol>
<li><code>Simulator</code>上无法完成IAP交易，无论是沙盒环境还是正式环境都不行。</li>
<li><code>Developer</code>证书 + 测试账号触发沙盒环境，<code>Distribution</code>证书触发正式环境。要触发沙盒环境，首先在iOS的<code>Setting</code>中登出当前账号，之后在应用内付费弹出输入App Id的时候输入测试账号。</li>
<li>测试账号一定不要用来登录正式环境，否则该测试账号再也不能用来登录沙盒环境做测试。</li>
<li>在提交Apple审核时，启用的是App自己服务端的正式环境和Apple的<strong>沙盒环境</strong>，因此对于我们自己服务端正式环境来说，如果有验证<code>Receipt</code>的逻辑，建议的实现方式是：先走<code>App Store</code>正式环境的URL验证<code>Receipt</code>，如果<code>status</code>返回值是<code>21007</code>(沙盒环境的<code>Receipt</code>拿到了正式环境做验证)，再向沙盒环境URL重新做一次验证，从而保证应用审核顺利进行。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要讲解iOS应用接入应用内购买的基本实现。<br>首先需要在应用后台做一些配置工作，这部分就不做详细步骤的说明，只列出需要完成的工作：</p>
<ol>
<li>在<a href="https://developer.apple.com/" target="_blan]]>
    </summary>
    
      <category term="iOS" scheme="http://nightfade.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SQLite中的常用SQL语法、锁机制和WAL]]></title>
    <link href="http://nightfade.github.io/2015/08/02/sql-summary/"/>
    <id>http://nightfade.github.io/2015/08/02/sql-summary/</id>
    <published>2015-08-02T10:55:00.000Z</published>
    <updated>2016-01-18T08:04:02.000Z</updated>
    <content type="html"><![CDATA[<p>本文主要参考《SQLite权威指南》。</p>
<h1 id="u521B_u5EFA_u8868"><a href="#u521B_u5EFA_u8868" class="headerlink" title="创建表"></a>创建表</h1><p>创建表的通用形式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> [TEMP|<span class="keyword">TEMPORARY</span>] <span class="keyword">TABLE</span> table_name (column_definitions [, <span class="keyword">constraints</span>]);</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>TEMP/TEMPORARY</code>关键字表示声明的表是临时表，一旦当前数据库断开链接，就自动销毁。</li>
<li><code>table_name</code>是表名。</li>
<li><code>column_definitions</code>是由逗号分隔的字段列表组成。</li>
</ul>
<p>SQLite有5中本地类型：<code>INTEGER</code>，<code>REAL</code>，<code>TEXT</code>，<code>BLOB</code>，<code>NULL</code>。</p>
<p>下面是一个例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> contacts (<span class="keyword">id</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">                       <span class="keyword">name</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COLLATE</span> NOCASE,</span><br><span class="line">                       phone <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'UNKNOWN'</span>,</span><br><span class="line">                       <span class="keyword">UNIQUE</span> (<span class="keyword">name</span>, phone));</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u4FEE_u6539_u8868"><a href="#u4FEE_u6539_u8868" class="headerlink" title="修改表"></a>修改表</h1><p>修改表的一般格式为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name &#123; <span class="keyword">RENAME</span> <span class="keyword">TO</span> <span class="keyword">name</span> | <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="keyword">column</span> <span class="keyword">def</span> &#125;;</span></span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> contacts</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> email <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COLLATE</span> NOCASE;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u6570_u636E_u5E93_u67E5_u8BE2"><a href="#u6570_u636E_u5E93_u67E5_u8BE2" class="headerlink" title="数据库查询"></a>数据库查询</h1><p><code>select</code>命令的通用形式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="keyword">heading</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">tables</span></span><br><span class="line"><span class="keyword">WHERE</span> predicate</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">columns</span></span><br><span class="line"><span class="keyword">HAVING</span> predicate</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">columns</span> [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>]</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="keyword">count</span></span><br><span class="line"><span class="keyword">OFFSET</span> <span class="keyword">offset</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>理解<code>select</code>命令的最好方法是将其当成处理关系的<code>管道</code>。</p>
<h2 id="u8FC7_u6EE4"><a href="#u8FC7_u6EE4" class="headerlink" title="过滤"></a>过滤</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dogs <span class="keyword">WHERE</span> color=<span class="string">'purple'</span> <span class="keyword">AND</span> grin=<span class="string">'toothy'</span>;</span></span><br></pre></td></tr></table></figure>
<p>数据库会获取表<code>dogs</code>中的所有行，然后用<code>where</code>子句形成预测逻辑，如果为真，该行将会包含在结果集里。</p>
<h2 id="u9650_u5B9A_u548C_u6392_u5E8F"><a href="#u9650_u5B9A_u548C_u6392_u5E8F" class="headerlink" title="限定和排序"></a>限定和排序</h2><p>可以用<code>limit</code>和<code>offset</code>关键字限定结果集的大小和范围。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> foods <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'B%'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> type_id <span class="keyword">DESC</span>, <span class="keyword">name</span> <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">2</span>;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u51FD_u6570_uFF08Function_uFF09_u548C_u805A_u5408_uFF08Aggregate_uFF09"><a href="#u51FD_u6570_uFF08Function_uFF09_u548C_u805A_u5408_uFF08Aggregate_uFF09" class="headerlink" title="函数（Function）和聚合（Aggregate）"></a>函数（Function）和聚合（Aggregate）</h1><p>SQLite提供多种内置的函数和聚合。<br>函数的种类包括：</p>
<ul>
<li>数学函数，例如计算绝对值的<code>ABS()</code>。</li>
<li>字符串格式函数，例如将字符串转化为大写或小写的<code>UPPER()</code>和<code>LOWER()</code>。</li>
</ul>
<p>函数可以是任意表达式的一部分，可以用在<code>WHERE</code>子句中。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">UPPER</span>(<span class="keyword">name</span>), <span class="keyword">LENGTH</span>(<span class="keyword">name</span>) <span class="keyword">FROM</span> foods <span class="keyword">WHERE</span> <span class="keyword">LENGTH</span>(<span class="keyword">name</span>) &lt; <span class="number">5</span> <span class="keyword">LIMIT</span> <span class="number">5</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>聚合是一类特殊的函数，它从一组记录中计算聚合值。标准的聚合函数包括：<code>SUM()</code>，<code>AVG()</code>，<code>COUNT()</code>，<code>MIN()</code>，<code>MAX()</code>。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> foods <span class="keyword">WHERE</span> type_id=<span class="number">1</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>聚合不仅可以聚合字段，也可以聚合任意表达式，标扩函数。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">LENGTH</span>(<span class="keyword">name</span>)) <span class="keyword">FROM</span> foods;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u5206_u7EC4_uFF08Grouping_uFF09"><a href="#u5206_u7EC4_uFF08Grouping_uFF09" class="headerlink" title="分组（Grouping）"></a>分组（Grouping）</h1><p>聚合不只是能够计算整个结果集的聚合至，还可以把结果集分成多个组，然后计算每个组的聚合值，方法是使用<code>GROUP BY</code>子句，例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> type_id, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> foods <span class="keyword">GROUP</span> <span class="keyword">BY</span> type_id;</span></span><br></pre></td></tr></table></figure></p>
<p>从操作上讲，<code>GROUP BY</code>介于<code>WHERE</code>和<code>SELECT</code>子句中间。<code>GROUP BY</code>接收<code>WHERE</code>的输出，并将其分割成共享某个字段（或多个字段）上同等值的小组，这些组再传递给<code>SELECT</code>子句。<br>使用<code>GROUP BY</code>时，<code>SELECT</code>子句<em>对每组单独应用聚合，而不是对整个结果进行聚合</em>。因此，聚合对魅族生成一个值，并将这些组的行作为单行。</p>
<p><code>HAVING</code>是一个可以应用到<code>GROUP BY</code>的断言。它从<code>GROUP BY</code>中过滤组的方式与<code>WHERE</code>子句从<code>FROM</code>中过滤行的方式相同。唯一不同的是，<code>WHERE</code>子句的预测是针对单个行的，而<code>HAVING</code>的断言是针对聚合值的。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> type_id, <span class="keyword">COUNT</span>(*) <span class="keyword">from</span> foods</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> type_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &lt; <span class="number">20</span>;</span></span><br></pre></td></tr></table></figure></p>
<p><code>GROUP BY</code>接收<code>WHERE</code>子句的约束，将结果行分成共享某值的组。<code>HAVING</code>对每组应用过滤，通过过滤的组传递给<code>SELECT</code>子句来做聚合和映射。</p>
<h1 id="u53BB_u6389_u91CD_u590D"><a href="#u53BB_u6389_u91CD_u590D" class="headerlink" title="去掉重复"></a>去掉重复</h1><p><code>DISTINCT</code>处理<code>SELECT</code>的结果并过滤掉其中重复的行。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> type_id <span class="keyword">FROM</span> foods;</span></span><br></pre></td></tr></table></figure></p>
<p>该语句的工作流程：<code>WHERE</code>子句返回表<code>foods</code>的所有行，<code>SELECT</code>子句取出其中的<code>type_id</code>字段，最终<code>DISTINCT</code>删除重复行。</p>
<h1 id="u591A_u8868_u94FE_u63A5"><a href="#u591A_u8868_u94FE_u63A5" class="headerlink" title="多表链接"></a>多表链接</h1><p>连接(JOIN)是多表关系数据工作的关键，它是<code>SELECT</code>命令的第一个操作，连接操作的结果作为输入，供<code>SELECT</code>语句的其他部分过滤处理。</p>
<p>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> foods.<span class="keyword">name</span>, food_types.<span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> foods, food_types</span><br><span class="line"><span class="keyword">WHERE</span> foods.type_id=food_types.<span class="keyword">id</span></span><br><span class="line"><span class="keyword">LIMIt</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>要实现连接，数据库需要找出匹配的行。对于第一个表中的每一行，数据库都要查询的第二个表的所有行，寻找那些链接字段具有相同值的行，然后将他们包含到输入关系中。</p>
<p>SQLite支持六种不同类型的连接，其中一种称为<em>内连接</em>的连接是最普遍的。</p>
<h2 id="u5185_u8FDE_u63A5"><a href="#u5185_u8FDE_u63A5" class="headerlink" title="内连接"></a>内连接</h2><p>内连接就是通过表中的两个字段进行连接。内连接找出两边集合那些包含相似值的行，然后结合两者形成结果集。<br>内连接只返回满足给定字段关系的行，也称为连接条件。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> foods <span class="keyword">INNER</span> <span class="keyword">JOIN</span> food_types <span class="keyword">ON</span> foods.<span class="keyword">id</span> = food_types.<span class="keyword">id</span>;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u4EA4_u53C9_u8FDE_u63A5"><a href="#u4EA4_u53C9_u8FDE_u63A5" class="headerlink" title="交叉连接"></a>交叉连接</h2><p>如果没有连接条件，<code>SELECT</code>会产生一种更基础的连接，称为交叉连接、笛卡尔积或者交叉乘积。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> foods, food_types;</span></span><br></pre></td></tr></table></figure></p>
<p><code>FROM</code>在缺乏其他条件时产生交叉连接，<code>foods</code>中的每一行都与<code>food_types</code>的所有行组合在一起。</p>
<h2 id="u5916_u8FDE_u63A5"><a href="#u5916_u8FDE_u63A5" class="headerlink" title="外连接"></a>外连接</h2><p>内连接是根据给定关系选择表中的行。外连接选择内连接的所有行外加一些关系之外的行。<br>三种外连接类型分别是：左外连接、右外连接和全外连接。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> foods <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> foods_episodes <span class="keyword">ON</span> foods.<span class="keyword">id</span> = foods_episodes.food_id;</span></span><br></pre></td></tr></table></figure></p>
<p>左外连接试图将<code>foods</code>中的所有行与<code>foods_episodes</code>的所有行进行行连接关系的匹配，所有匹配的行都包含在结果集中。但是，如果我们在<code>foods</code>表中注册一些食品，这些食品没有在<code>foods_episodes</code>中出现，<code>foods</code>表中没有匹配<code>food_episodes</code>的剩余行仍然会出现在结果集中，foods_episodes没有提供相应的行，它会以null补充。</p>
<p>右外连接的工作方式类似，不管是否匹配，右表的行都包含在结果集中。</p>
<p>全外连接是左外连接和右外连接的结合。它包含所有的匹配航，然后是右边和左边表的不匹配行。</p>
<p>目前SQLite不支持右外连接和全外连接，但是右外连接可以用左外连接代替，全外连接可以通过使用复合查询执行。</p>
<h2 id="u81EA_u7136_u8FDE_u63A5"><a href="#u81EA_u7136_u8FDE_u63A5" class="headerlink" title="自然连接"></a>自然连接</h2><p>自然连接是内连接的另一种形式，自然连接通过表中共有的字段名称将两个表连接起来，因此，使用自然连接时，不用添加连接条件就可以获得内连接的结果。<br>如果表的设计一直在改变，最好清晰的定义查询中的连接条件，不要使用自然连接。</p>
<h2 id="u8BED_u6CD5_u504F_u597D"><a href="#u8BED_u6CD5_u504F_u597D" class="headerlink" title="语法偏好"></a>语法偏好</h2><p>语法上讲，可以通过各种方式制定连接，<code>foods</code>和<code>food_types</code>的内连接可以通过<code>WHERE</code>子句隐含实现：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> foods, food_types <span class="keyword">WHERE</span> foods.<span class="keyword">id</span> = food_types.food_id;</span></span><br></pre></td></tr></table></figure></p>
<p>这种隐式形式虽然简洁，但是是一种应该避免的果实的语法形式。SQL中正确的表达连接的方法是使用连接关键字：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">heading</span> <span class="keyword">FROM</span> left_table JOIN_TYPE right_table <span class="keyword">ON</span> join_condition;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u540D_u79F0_u548C_u522B_u540D"><a href="#u540D_u79F0_u548C_u522B_u540D" class="headerlink" title="名称和别名"></a>名称和别名</h1><p>举例说明：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">f</span>.<span class="keyword">name</span>, <span class="keyword">t</span>.<span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> foods <span class="keyword">f</span>, food_types <span class="keyword">t</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">f</span>.type_id = <span class="keyword">t</span>.<span class="keyword">id</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">f</span>.<span class="keyword">name</span> <span class="keyword">AS</span> food, e1.<span class="keyword">name</span>, e2.season, e2.<span class="keyword">name</span>, e2.season</span><br><span class="line"><span class="keyword">FROM</span> episodes e1, foods_episodes fe1, foods <span class="keyword">f</span>,</span><br><span class="line">     episodes e2, foods_episodes fe2</span><br><span class="line"><span class="keyword">WHERE</span> e1.<span class="keyword">id</span> = fe1.episode_id <span class="keyword">AND</span> e1.season = <span class="number">4</span> <span class="keyword">AND</span> fe1.food_id = <span class="keyword">f</span>.<span class="keyword">id</span> </span><br><span class="line">      <span class="keyword">AND</span> fe1.food_id = fe2.food_id</span><br><span class="line">      <span class="keyword">AND</span> fe2.episode_id = e2.<span class="keyword">id</span> <span class="keyword">AND</span> e2.season != e1.season</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">f</span>.<span class="keyword">name</span>;</span></span><br></pre></td></tr></table></figure>
<h1 id="u5B50_u67E5_u8BE2"><a href="#u5B50_u67E5_u8BE2" class="headerlink" title="子查询"></a>子查询</h1><p>子查询最常用的地方是<code>WHERE</code>子句，特别是<code>IN</code>操作符中：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) </span><br><span class="line"><span class="keyword">FROM</span> foods</span><br><span class="line"><span class="keyword">WHERE</span> type_id <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="keyword">id</span> </span><br><span class="line">     <span class="keyword">FROM</span> food_types</span><br><span class="line">     <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'Bakery'</span> <span class="keyword">OR</span> <span class="keyword">name</span>=<span class="string">'Cereal'</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>可以用来从其他表向结果集添加额外数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">name</span>,</span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> foods_episodes <span class="keyword">WHERE</span> food_id=<span class="keyword">f</span>.<span class="keyword">id</span>) <span class="keyword">AS</span> <span class="keyword">count</span></span><br><span class="line"><span class="keyword">FROM</span> foods <span class="keyword">f</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">count</span> <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>子查询中可以使用<code>ORDER BY</code>子句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(type_id) <span class="keyword">FROM</span> foods <span class="keyword">WHERE</span> type_id=<span class="keyword">f</span>.type_id) <span class="keyword">DESC</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>有时可能想与其他结果进行连接：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">f</span>.<span class="keyword">name</span>, types.<span class="keyword">name</span> <span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> food_types <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">6</span>) types <span class="keyword">ON</span> <span class="keyword">f</span>.type_id=types.<span class="keyword">id</span>;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u590D_u5408_u67E5_u8BE2"><a href="#u590D_u5408_u67E5_u8BE2" class="headerlink" title="复合查询"></a>复合查询</h1><p>复合查询与子查询相反，它是使用三种特殊的关系操作符处理多个查询的结果：<code>UNION</code>、<code>INTERSECT</code>、<code>EXCEPT</code>。<br>复合查询操作需要如下一些条件：</p>
<ul>
<li>涉及的关系的字段数目必须相同。</li>
<li>只能有一个<code>ORDER BY</code>子句，并且处在复合查询的最末尾，对联合结果进行排序。</li>
</ul>
<p><code>UNION</code>联合两个<code>SELECT</code>语句的结果，默认情况下，<code>UNION</code>会消除重复数据，如果想在结果中保留重复数据，可以使用<code>UNION ALL</code>。<br>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">f</span>.*, top_foods.<span class="keyword">count</span> <span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> food_id, <span class="keyword">COUNT</span>(food_id) <span class="keyword">AS</span> <span class="keyword">count</span> <span class="keyword">from</span> foods_episodes</span><br><span class="line">            <span class="keyword">GROUP</span> <span class="keyword">BY</span> food_id</span><br><span class="line">            <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">COUNT</span>(food_id) <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>) top_foods</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">f</span>.<span class="keyword">id</span>=top_foods.food_id</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">f</span>.*, bottom_foods.<span class="keyword">count</span> <span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> food_id, <span class="keyword">count</span>(food_id) <span class="keyword">AS</span> <span class="keyword">count</span> <span class="keyword">FROM</span> foods_episodes</span><br><span class="line">            <span class="keyword">GROUP</span> <span class="keyword">BY</span> food_id</span><br><span class="line">            <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">COUNT</span>(food_id) <span class="keyword">LIMIT</span> <span class="number">1</span>) bottom_foods</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">f</span>.<span class="keyword">id</span>=bottom_foods.food_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> top_foods.<span class="keyword">count</span> <span class="keyword">DESC</span>;</span></span><br></pre></td></tr></table></figure></p>
<p><code>INTERSECT</code>操作输入两个关系A和B，选择那些既在A也在B的行。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">f</span>.* <span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">        (<span class="keyword">SELECT</span> food_id, <span class="keyword">COUNT</span>(food_id) <span class="keyword">AS</span> <span class="keyword">count</span></span><br><span class="line">         <span class="keyword">FROM</span> foods_episodes</span><br><span class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> food_id</span><br><span class="line">         <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">COUNT</span>(food_id) <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">10</span>) top_foods</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">f</span>.<span class="keyword">id</span>=top_foods.food_id</span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">f</span>.* <span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> foods_spisodes fe <span class="keyword">ON</span> <span class="keyword">f</span>.<span class="keyword">id</span>=fe.food_id</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> episodes <span class="keyword">e</span> <span class="keyword">ON</span> fe.episode_id=<span class="keyword">e</span>.<span class="keyword">id</span></span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">e</span>.season <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">5</span></span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">f</span>.<span class="keyword">name</span>;</span></span><br></pre></td></tr></table></figure></p>
<p><code>EXCEPT</code>操作输入两个关系A和B，找出所有在A但不在B的行。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">f</span>.* <span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">        (<span class="keyword">SELECT</span> food_id, <span class="keyword">COUNT</span>(food_id) <span class="keyword">AS</span> <span class="keyword">count</span> <span class="keyword">FROM</span> foods_episodes</span><br><span class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> food_id</span><br><span class="line">         <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">COUNT</span>(food_id) <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">10</span>) top_foods</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">f</span>.<span class="keyword">id</span>=top_foods.food_id</span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">f</span>.* <span class="keyword">from</span> foods <span class="keyword">f</span></span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> foods_episodes fe <span class="keyword">ON</span> <span class="keyword">f</span>.<span class="keyword">id</span>=fe.food_id</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> foods_episodes <span class="keyword">e</span> <span class="keyword">ON</span> fe.episode_id=<span class="keyword">e</span>.<span class="keyword">id</span></span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">e</span>.season <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">f</span>.<span class="keyword">name</span>;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u6761_u4EF6_u7ED3_u679C"><a href="#u6761_u4EF6_u7ED3_u679C" class="headerlink" title="条件结果"></a>条件结果</h1><p><code>CASE</code>表达式允许在<code>SELECT</code>语句中处理各种情况。</p>
<ol>
<li><p>接受静态值并列出各种情况下<code>CASE</code>返回值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">name</span> || <span class="keyword">CASE</span> type_id</span><br><span class="line">                   <span class="keyword">WHEN</span> <span class="number">7</span> <span class="keyword">THEN</span> <span class="string">' is a drink'</span></span><br><span class="line">                   <span class="keyword">WHEN</span> <span class="number">8</span> <span class="keyword">THEN</span> <span class="string">' is a fruit'</span></span><br><span class="line">                   <span class="keyword">WHEN</span> <span class="number">9</span> <span class="keyword">THEN</span> <span class="string">' is junkfood'</span></span><br><span class="line">                   <span class="keyword">WHEN</span> <span class="number">13</span> <span class="keyword">THEN</span> <span class="string">' is seafood'</span></span><br><span class="line">                   <span class="keyword">ELSE</span> <span class="literal">NULL</span></span><br><span class="line">               <span class="keyword">END</span> <span class="keyword">AS</span> description</span><br><span class="line"><span class="keyword">FROM</span> foods</span><br><span class="line"><span class="keyword">WHERE</span> description <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>WHEN</code>条件中有表达式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">name</span>, (<span class="keyword">SELECT</span> <span class="keyword">CASE</span></span><br><span class="line">                  <span class="keyword">WHEN</span> <span class="keyword">COUNT</span>(*) &gt; <span class="number">4</span> <span class="keyword">THEN</span> <span class="string">'VERY HIGH'</span></span><br><span class="line">                  <span class="keyword">WHEN</span> <span class="keyword">COUNT</span>(*) = <span class="number">4</span> <span class="keyword">THEN</span> <span class="string">'HIGH'</span></span><br><span class="line">                  <span class="keyword">WHEN</span> <span class="keyword">COUNT</span>(*) <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>) <span class="keyword">THEN</span> <span class="string">'Moderate'</span></span><br><span class="line">                  <span class="keyword">ELSE</span> <span class="string">'Low'</span></span><br><span class="line">              <span class="keyword">END</span></span><br><span class="line">              <span class="keyword">FROM</span> foods_episodes</span><br><span class="line">              <span class="keyword">WHERE</span> food_id=<span class="keyword">f</span>.<span class="keyword">id</span>) <span class="keyword">AS</span> frequency</span><br><span class="line"><span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line"><span class="keyword">WHERE</span> frequency <span class="keyword">like</span> <span class="string">'%HIGH'</span>;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="u4FEE_u6539_u6570_u636E"><a href="#u4FEE_u6539_u6570_u636E" class="headerlink" title="修改数据"></a>修改数据</h1><h2 id="u63D2_u5165_u8BB0_u5F55"><a href="#u63D2_u5165_u8BB0_u5F55" class="headerlink" title="插入记录"></a>插入记录</h2><p>使用<code>INSERT</code>命令向表中插入记录，<code>INSERT</code>语句的一般格式为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column_list) <span class="keyword">VALUES</span> (value_list);</span></span><br></pre></td></tr></table></figure></p>
<p>插入一行：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> foods (<span class="keyword">name</span>, type_id) <span class="keyword">VALUES</span> (<span class="string">'Cinnamon Bobka'</span>, <span class="number">1</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>插入一组行：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> foods</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="literal">NULL</span>,</span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> food_types <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'Bakery'</span>),</span><br><span class="line">        <span class="string">'Blackberry Bobka'</span>);</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> foods</span><br><span class="line"><span class="keyword">SELECT</span> last_insert_rowid()+<span class="number">1</span>, type_id, <span class="keyword">name</span> <span class="keyword">FROM</span> foods</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'Chocolate Bobka'</span>;</span></span><br></pre></td></tr></table></figure>
<p>只要<code>SELECT</code>子句的字段数目与要插入的表的字段数目匹配，或者与提供的字段列表匹配，<code>INSERT</code>语句就可以正常工作。</p>
<h2 id="u66F4_u65B0_u8BB0_u5F55"><a href="#u66F4_u65B0_u8BB0_u5F55" class="headerlink" title="更新记录"></a>更新记录</h2><p><code>UPDATE</code>命令用于更新表中的记录，该命令可以修改一个表中的一行或多行中的一个或多个字段。<code>UPDATE</code>语句的一般格式为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> update_list <span class="keyword">WHERE</span> predicate;</span></span><br></pre></td></tr></table></figure></p>
<p><code>update_list</code>是一个或多个“字段赋值”的列表，字段赋值的格式为<code>column_name=value</code>。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">UPDATE</span> foods <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">'CHOCOLATE BOBKA'</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'Chocolate Bobka'</span>;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u5220_u9664_u8BB0_u5F55"><a href="#u5220_u9664_u8BB0_u5F55" class="headerlink" title="删除记录"></a>删除记录</h2><p>使用<code>DELETE</code>命令可以删除表中的记录，<code>DELETE</code>语句的一般格式为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> predicate;</span></span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> foods <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'CHOCOLATE BOBKA'</span>;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u6570_u636E_u5B8C_u6574_u6027"><a href="#u6570_u636E_u5B8C_u6574_u6027" class="headerlink" title="数据完整性"></a>数据完整性</h1><p>数据完整性用于定义和保护表内部或表之间的数据关系。一般有四种完整性：域完整性、实体完整性、引用完整性和用户自定义完整性。</p>
<ul>
<li>域完整性：控制字段内的值。</li>
<li>实体完整性：表中的行。</li>
<li>引用完整性：表之间的行，也就是外键关系。</li>
<li>用户自定义完整性：其他。</li>
</ul>
<h2 id="u5B9E_u4F53_u5B8C_u6574_u6027"><a href="#u5B9E_u4F53_u5B8C_u6574_u6027" class="headerlink" title="实体完整性"></a>实体完整性</h2><p>行必须在某种方式上是唯一的，这就是<strong>主键</strong>的功能。<br>主键由至少带有<code>UNIQUE</code>约束的一个或一组字段组成。<br>唯一性约束：一个<code>UNIQUE</code>约束要求一个或一组字段的所有值互不相同，如果视图插入一个重复值，或者将一个值更新成一个已存在的值，数据库将引发一个约束非法，并终止操作。<br>主键约束：定义一个表时总要确定一个主键，不管自己有没有定义。这个字段是一个64bit的整形字段，称为<code>rowid</code>，还有两个别名<code>_rowid_</code>和<code>oid</code>。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> contacts (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> AUTOINCREMENT</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COLLATE</span> nocase,</span><br><span class="line">    phone <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'UNKNOWN'</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span>(<span class="keyword">name</span>, phone));</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u57DF_u5B8C_u6574_u6027"><a href="#u57DF_u5B8C_u6574_u6027" class="headerlink" title="域完整性"></a>域完整性</h2><ol>
<li><p>默认值：如果用<code>INSERT</code>语句插入记录时没有为该字段指定值，关键字<code>DEFAULT</code>将为字段提供一个默认值。<br><code>DEFAULT</code>还可以接受3中预定义格式的保留字，用于生成日期和时间。<code>current_time</code>将生成（HH:MM:SS）的当前时间，<code>current_date</code>将生成(YYYY-MM-DD)格式的当前日期，<code>current_timestamp</code>将生成一个日期时间的组合(YYYY-MM-DD HH:MM:SS)。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> times (<span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">                    <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">current_date</span>,</span><br><span class="line">                    <span class="keyword">time</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">current_time</span>,</span><br><span class="line">                    <span class="keyword">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">current_timestamp</span>);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>NOT NULL</code>约束：确保该字段值不为<code>NULL</code>。</p>
</li>
<li><p><code>CHECK</code>约束：允许自定义表达式来测试要插入或更新的字段值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> contacts (<span class="keyword">id</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">                       <span class="keyword">name</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COLLATE</span> NOCASE,</span><br><span class="line">                       phone <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'UNKNOWN'</span>,</span><br><span class="line">                       <span class="keyword">UNIQUE</span>(<span class="keyword">name</span>, phone),</span><br><span class="line">                       <span class="keyword">CHECK</span>(<span class="keyword">LENGTH</span>(<span class="keyword">name</span>) &gt;= <span class="number">7</span>));</span></span><br><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> foo (x <span class="built_in">INTEGER</span>,</span><br><span class="line">                  y <span class="built_in">INTEGER</span> <span class="keyword">CHECK</span> (y &gt; x),</span><br><span class="line">                  z <span class="built_in">INTEGER</span> <span class="keyword">CHECK</span> (z &gt; <span class="keyword">ABS</span>(y)));</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>外键约束：确保一个表中的关系值必须从另一个表中引用，且该数据必须在另一个表中实际存在，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (column_definitions <span class="keyword">REFERENCES</span> foreign_table (column_name) <span class="keyword">on</span> &#123;<span class="keyword">DELETE</span>|<span class="keyword">UPDATE</span>&#125; integrity_action [<span class="keyword">not</span>] deferrable [<span class="keyword">INITIALLY</span> &#123;DEFERED|<span class="keyword">IMMEDIATE</span>&#125;,]</span><br><span class="line">);</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>举例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> foods (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    type_id <span class="built_in">INTEGER</span> <span class="keyword">REFERENCES</span> food_types(<span class="keyword">id</span>) </span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT</span><br><span class="line">    DEFERRABLE <span class="keyword">INITIALLY</span> <span class="keyword">DEFERRED</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">TEXT</span></span><br><span class="line">)</span></span><br></pre></td></tr></table></figure></p>
<p><code>DELETE RESTRICT</code>阻止任何破坏完整性的行为。其他的选项有：</p>
<ul>
<li><code>SET NULL</code>：如果父值被删除或者不存在了，子值设置为<code>NULL</code>。</li>
<li><code>SET DEFAULT</code>：如果赋值不存在了就设置为默认值。</li>
<li><code>CASCADE</code>：更新父值时，更新所有匹配的子值。删除父值时，删除所有子值。</li>
<li><code>RESTRICT</code>：如果更新或删除父值可能出现孤立的子值，就阻止事务。</li>
<li><code>NO ACTION</code>：不干涉操作，只是在整个语句的结尾报错。</li>
</ul>
<p><code>DEFERRABLE</code>子句控制定义的约束是立即强制实施还是延迟到整个事务结束时。</p>
<ol>
<li>排序规则：SQLite内置三种排序规则，默认的是二进制排序规则，使用C函数<code>memcmp()</code>逐字节比较文本值。第二种，<code>NOCASE</code>是拉丁字母中26个ASCII字符的非大小写敏感排序算法。第三种，<code>REVERSE</code>排序规则，和二进制排序规则相反。</li>
</ol>
<h1 id="u89C6_u56FE"><a href="#u89C6_u56FE" class="headerlink" title="视图"></a>视图</h1><p>视图即虚拟表，也称为派生表，因为它们的内容都派生自其他表的查询结果。视图的内容是在使用时动态产生的。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="keyword">name</span> <span class="keyword">AS</span> <span class="keyword">select</span>-stmt;</span></span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> details <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">f</span>.<span class="keyword">name</span> <span class="keyword">AS</span> fd, ft.<span class="keyword">name</span> <span class="keyword">AS</span> tp, <span class="keyword">e</span>.<span class="keyword">name</span> <span class="keyword">AS</span> ep, <span class="keyword">e</span>.season <span class="keyword">AS</span> ssn</span><br><span class="line"><span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> food_types ft <span class="keyword">ON</span> <span class="keyword">f</span>.type_id=ft.<span class="keyword">id</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> foods_spisodes fe <span class="keyword">ON</span> <span class="keyword">f</span>.<span class="keyword">id</span>=fe.food_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> episodes <span class="keyword">e</span> <span class="keyword">ON</span> fe.episode_id=<span class="keyword">e</span>.<span class="keyword">id</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> fd <span class="keyword">AS</span> FOOD, ep <span class="keyword">AS</span> Episode <span class="keyword">FROM</span> details <span class="keyword">WHERE</span> ssn=<span class="number">7</span> <span class="keyword">AND</span> tp <span class="keyword">LIKE</span> <span class="string">'Drinks'</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>视图的内容是动态生成的，每次使用<code>details</code>时，基于数据库对当前数据执行相关的SQL语句，产生结果。<br>使用命令<code>DROP VIEW</code>删除视图：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="keyword">name</span>;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u7D22_u5F15"><a href="#u7D22_u5F15" class="headerlink" title="索引"></a>索引</h1><p>索引是一种用来在某种条件下加速查询的结构，例如如下查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> foods <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'JujyFruit'</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>当数据库搜索匹配行时，执行这种查询的默认方法是调用顺序扫描。如果表<code>foods</code>非常大，使用索引的方法查找数据就更有意义了。<br>创建索引的命令如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> [<span class="keyword">UNIQUE</span>] index_name <span class="keyword">ON</span> table_name (<span class="keyword">columns</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>关键字<code>UNIQUE</code>会在索引上添加约束，索引中的所有值必须是唯一的。<br>例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> <span class="keyword">UNIQUE</span> foo_index <span class="keyword">ON</span> foo (a, b);</span></span><br></pre></td></tr></table></figure></p>
<p>删除索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name;</span></span><br></pre></td></tr></table></figure></p>
<p>排序规则：索引中的每个字段都有相关的排序规则，例如，要在<code>foods.name</code>上创建大小写不敏感的索引，可以使用如下命令：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> foods_name_idx <span class="keyword">ON</span> foods (<span class="keyword">name</span> <span class="keyword">COLLATE</span> NOCASE);</span></span><br></pre></td></tr></table></figure></p>
<p>使用索引<br>对于下面会在<code>WHERE</code>子句中出现的表达式，SQLite将使用单个字段索引：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">column &#123;=|&gt;|&gt;=|&lt;=|&lt;&#125; expression</span><br><span class="line">expression &#123;=|&gt;|&gt;=|&lt;=|&lt;&#125; column</span><br><span class="line">column IN (expression-list)</span><br><span class="line">column IN (subquery)</span><br></pre></td></tr></table></figure></p>
<p>多字段索引有更复杂的条件，它从左到右智能的使用字段。</p>
<h1 id="u89E6_u53D1_u5668"><a href="#u89E6_u53D1_u5668" class="headerlink" title="触发器"></a>触发器</h1><p>当具体的表发生特定的数据库事件时，触发器执行对应的SQL命令。创建触发器的一般命令如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> [TEMP|<span class="keyword">TEMPORARY</span>] <span class="keyword">TRIGGER</span> <span class="keyword">name</span></span><br><span class="line">[<span class="keyword">BEFORE</span>|<span class="keyword">AFTER</span>] [<span class="keyword">INSERT</span>|<span class="keyword">DELETE</span>|<span class="keyword">UPDATE</span>|<span class="keyword">UPDATE</span> <span class="keyword">OF</span> <span class="keyword">columns</span>] <span class="keyword">ON</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">action</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> TEMP <span class="keyword">TRIGGER</span> foods_update_log <span class="keyword">UPDATE</span> <span class="keyword">OF</span> <span class="keyword">name</span> <span class="keyword">ON</span> foods</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">log</span> <span class="keyword">VALUES</span> (<span class="string">'updated foods: new name = '</span> || <span class="keyword">new</span>.<span class="keyword">name</span>);</span></span><br><span class="line"><span class="operator"><span class="keyword">END</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>UPDATE</code>触发器中，未更新行可以引用为<code>old</code>，已更新行可以引用为<code>new</code>。</p>
<p>错误处理：SQLite提供一个特殊的SQL函数<code>raise()</code>供触发器调用，该函数允许在触发器内产生错误，<code>raise()</code>定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span>(resolution, error_message);</span><br></pre></td></tr></table></figure></p>
<p>第一个参数是冲突解决策略（<code>abort</code>, <code>fail</code>, <code>ignore</code>, <code>rollback</code>等），第二个参数是错误消息。</p>
<p>可更新视图：可利用触发器实现可更新视图。<br>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> on_update_foods_view</span><br><span class="line">INSTEAD <span class="keyword">OF</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> foods_view</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> foods <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="keyword">new</span>.fname <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="keyword">new</span>.fid;</span></span><br><span class="line">    <span class="operator"><span class="keyword">UPDATE</span> food_types <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="keyword">new</span>.tname <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="keyword">new</span>.tid;</span></span><br><span class="line"><span class="operator"><span class="keyword">END</span>;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u4E8B_u52A1"><a href="#u4E8B_u52A1" class="headerlink" title="事务"></a>事务</h1><p>事务定义了一组SQL命令的边界，这组命令或者作为一个整体被全部执行，或者都不执行。<br>事务由3个命令控制：<code>BEGIN</code>、<code>COMMIT</code>和<code>ROLLBACK</code>。</p>
<ul>
<li><code>BEGIN</code>开始一个事务，<code>BEGIN</code>之后的所有操作都可以取消，如果连接终止前没有发出<code>COMMIT</code>，也会被取消。</li>
<li><code>COMMIT</code>提交事务开始后所执行的所有操作。</li>
<li><code>ROLLBACK</code>还原<code>BEGIN</code>之后的所有操作。</li>
</ul>
<p>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">BEGIN</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> foods;</span></span><br><span class="line"><span class="operator"><span class="keyword">ROLLBACK</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> foods;</span> <span class="comment">-- output: 412</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u51B2_u7A81_u89E3_u51B3"><a href="#u51B2_u7A81_u89E3_u51B3" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>违反约束会导致事务终止，在对数据进行很多修改的过程中，命令终止会简单的将前面所做的修改全部取消。<br>通过冲突解决可以指定不同的方式处理约束违反的情况。<br>SQLite提供5种可能的冲突解决方案或策略：</p>
<ul>
<li><code>REPLACE</code>：违反唯一性约束时，将造成这种违反的记录删除，以插入或修改的新纪录替代。违反<code>NOT NULL</code>约束时，则使用该字段的默认值代替<code>NULL</code>，如果没有默认值，则应用<code>ABORT</code>策略。</li>
<li><code>IGNORE</code>：当违反约束发生时，允许命令继续执行，违反约束的行保持不变，命令继续处理其他且不报错。</li>
<li><code>FAIL</code>：当违反约束发生时，终止命令，但是不回复约束违反之前已经修改的记录，违反约束之后的都不回继续处理了。</li>
<li><code>ABORT</code>：违反约束发生时，恢复当前命令所有的所有改变并终止命令。这是SQLite中所有操作的默认解决办法。</li>
<li><code>ROLLBACK</code>：违反约束发生时，执行回滚。当前命令所做的改变和事务中之前命令的改变都回滚。</li>
</ul>
<p>冲突解决方法既可以在SQL命令中指定，也可以在表盒索引的定义中执行。具体来说，可以在<code>INSERT</code>、<code>UPDATE</code>、<code>CREATE TABLE</code>和<code>CREATE INDEX</code>中指定。<br>在<code>INSERT</code>和<code>UPDATE</code>中的语法形式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">OR</span> *RESOLUTION_TYPE* <span class="keyword">INTO</span> table_name (column_list) <span class="keyword">VALUES</span> (value_list);</span></span><br><span class="line"><span class="operator"><span class="keyword">UPDATE</span> <span class="keyword">OR</span> *RESOLUTION_TYPE* table_name <span class="keyword">SET</span> (value_list) <span class="keyword">WHERE</span> predicate;</span></span><br></pre></td></tr></table></figure></p>
<p>表内定义时，可以为单个字段指定冲突解决方法，例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">cast</span> (<span class="keyword">name</span> <span class="built_in">TEXT</span> <span class="keyword">UNIQUE</span> <span class="keyword">ON</span> CONFLICT <span class="keyword">ROLLBACK</span>);</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u6570_u636E_u5E93_u9501"><a href="#u6570_u636E_u5E93_u9501" class="headerlink" title="数据库锁"></a>数据库锁</h2><p>SQLite使用锁逐步提升机制，为了写数据库，连接需要逐级获得排它锁。SQLite有5种不同的锁状态：未加锁(<code>UNLOCKED</code>)、共享(<code>SHARED</code>)、预留(<code>RESERVED</code>)、未决(<code>PENDING</code>)和排他(<code>EXCLUSIVE</code>)。</p>
<ul>
<li>最初的状态是<code>UNLOCK</code>状态，此状态下连接还没有访问数据库。</li>
<li>为了能从数据库<strong>读</strong>数据，连接必须首先进入<code>SHARED</code>状态。多个连接可以同时获得并保持共享锁，只要有一个共享锁没有释放，就不允许任何连接写数据库。</li>
<li>如果一个连接想要写数据库，必须首先获得一个预留锁(<code>RESERVED</code>)。一个数据库只能有一个预留锁，该预留锁可以与共享锁共存，它不阻止其他拥有共享锁的连接继续读数据库，也不阻止其他连接获得新的共享锁。</li>
<li>一旦连接获得预留锁，就可以开始处理数据库的修改操作，此时修改只能在缓冲区中进行，不实际写磁盘。</li>
<li>当连接想要<strong>提交修改</strong>时，需要将预留锁提升为排他锁(<code>EXCLUSIVE</code>)。为了得到排他锁，必须首先将预留锁提升为未决锁(<code>PENDING</code>)。<strong>获得未决锁之后，其他连接不能再获得新的共享锁。</strong>此时，拥有未决锁的连接等待其他拥有共享锁的连接完成工作并释放共享锁。</li>
<li>一旦所有其他的共享锁都被释放，拥有未决锁的连接就可以将其锁提升至排它锁(<code>EXCLUSIVE</code>)，此时就可以自由对数据库进行修改，所有以前所缓存的修改都会被写到数据库文件中。</li>
</ul>
<h2 id="u4E8B_u52A1_u7684_u7C7B_u578B"><a href="#u4E8B_u52A1_u7684_u7C7B_u578B" class="headerlink" title="事务的类型"></a>事务的类型</h2><p>SQLite有三种不同的事务类型，它们以不同的锁状态启动事务。事务可以开始于：<code>DEFERED</code>、<code>IMMEDIATE</code>或<code>EXCLUSIVE</code>。事务类型在<code>BEGIN</code>命令中制定：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">BEGIN</span> [ <span class="keyword">DEFERRED</span> | <span class="keyword">IMMEDIATE</span> | EXCLUSIVE ] <span class="keyword">TRANSACTION</span>;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>一个<code>DEFERED</code>知道必须使用时才获取锁。对于延迟事务，<code>BEGIN</code>本身不会做什么事情——它从未锁定状态开始。只是默认的情况。多个连接可以在同一时刻未创建任何锁的情况下开始延迟事务。第一个对数据库的读操作获取共享锁，第一个对数据库的写操作试图获取预留锁。</li>
<li>由<code>BEGIN</code>开始的<code>IMMEDIATE</code>事务在<code>BEGIN</code>执行时视图获取预留锁。如果成功，<code>BEGIN IMMEDIATE</code>保证没有其他连接可以写数据库。</li>
<li><code>EXCLUSIVE</code>事务会试着获取对数据库的排它锁。一旦成功，<code>EXCLUSIVE</code>事务保证数据库中没有其他活动连接，可以对数据库进行任意读写操作。</li>
</ul>
<p>如果两个连接都用<code>DEFERED</code>事务，可能会出现死锁：都想写数据库，但是都没有放弃自己的锁（例如一个获取了未决锁，一个保持了共享锁）。但是如果都以<code>BEGIN IMMEDIATE</code>或者<code>BEGIN EXCLUSIVE</code>开始事务，就不会死锁。<br>基本准则是：如果数据库没有其他连接，用<code>BEGIN</code>就足够。如果有其他连接会进行写操作，需要使用<code>BEGIN IMMEDIATE</code>或者<code>BEGIN EXCLUSIVE</code>开始事务。</p>
<h1 id="u6570_u636E_u5E93_u7BA1_u7406"><a href="#u6570_u636E_u5E93_u7BA1_u7406" class="headerlink" title="数据库管理"></a>数据库管理</h1><h2 id="u9644_u52A0_u6570_u636E_u5E93"><a href="#u9644_u52A0_u6570_u636E_u5E93" class="headerlink" title="附加数据库"></a>附加数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ATTACH [database] filename AS database_name;</span><br><span class="line">DETACH [database] database_name;</span><br></pre></td></tr></table></figure>
<p>可以用<code>main</code>全名引用主数据库中的对象。<br>例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ATTACH database '/tmp/db' AS db2;</span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> db2.foo;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">main</span>.foods <span class="keyword">LIMIT</span> <span class="number">2</span>;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u6570_u636E_u5E93_u6E05_u7406"><a href="#u6570_u636E_u5E93_u6E05_u7406" class="headerlink" title="数据库清理"></a>数据库清理</h2><p>SQLite有两个命令用于清理数据库——<code>REINDEX</code>和<code>VACUUM</code>。<br><code>REINDEX</code>用于重建索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REINDEX collation_name;</span><br><span class="line">REINDEX table_name|index_name;</span><br></pre></td></tr></table></figure></p>
<p>第一种形式重建所有使用指定排序名称的索引，当腰改变用户定义的排序行为时才需要这种形式。要重构表中所有索引（或指定名称的索引），可以使用第二种形式的命令。</p>
<p><code>VACUUM</code>通过重构数据库文件清理那些未使用的空间。</p>
<h2 id="u7CFB_u7EDF_u76EE_u5F55"><a href="#u7CFB_u7EDF_u76EE_u5F55" class="headerlink" title="系统目录"></a>系统目录</h2><p><code>sqlite_master</code>表是系统表，包含数据库中所有表、视图、索引和触发器信息。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">type</span>, <span class="keyword">name</span>, rootpage <span class="keyword">FROM</span> sqlite_master;</span></span><br></pre></td></tr></table></figure></p>
<p><code>type</code>字段说明对象的类型，<code>name</code>字段是对象的名称，<code>rootpage</code>指对象的第一个B-tree页面在数据库文件中的位置。</p>
<h2 id="u67E5_u770B_u67E5_u8BE2_u8BA1_u5212"><a href="#u67E5_u770B_u67E5_u8BE2_u8BA1_u5212" class="headerlink" title="查看查询计划"></a>查看查询计划</h2><p>使用<code>EXPLAN QUERY PLAN</code>命令查看SQLite执行查询的方法：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAN QUERY PLAN <span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> foods <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">145</span>;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Write-Ahead_Logging"><a href="#Write-Ahead_Logging" class="headerlink" title="Write-Ahead Logging"></a>Write-Ahead Logging</h1><p>SQLite处理<code>Atomic Commit</code>和<code>Rollback</code>传统方法叫做<code>Rollback Journal</code>。当进程想要修改数据库的时候，首先把未修改的这部分内容记录在<code>Rollback Journal</code>里，这个时候原始数据库还没有改变。当<code>COMMIT</code>数据的时候，SQLite首先确保没有其他数据库连接正在读数据库，将修改直接写入数据库文件，删除<code>Rollback Journal</code>。如果这期间发生了crash或者<code>ROLLBACK</code>，再利用<code>Rollback Journal</code>记录的原始内容<code>REVERT</code>之前的变更。</p>
<p><code>Write-Ahead Logging</code>方法反其道而行之，把原始内容保存在数据库文件里，把修改记录在单独的<code>WAL</code>文件里，多个<code>Transaction</code>会按顺序追加在文件末尾。要读取数据库的时候，首先会查找<code>WAL</code>文件里最后一个合法的<code>COMMIT</code>记录，并查看要读取的页面是不是出现在这次记录里，如果出现在记录里，就从<code>WAL</code>读取修改以后的数据，否则就从原数据库文件里读取。因此在<code>WAL</code>模式下，从原始数据库文件中读数据和提交数据修改可以同时进行，但是写事务之间依然不可并行（要保证<code>COMMIT</code>的数据按顺序一次追加到<code>WAL</code>文件末尾）。在之后的某个时间点(checkpoint)，所有的修改事务再写回数据库。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要参考《SQLite权威指南》。</p>
<h1 id="u521B_u5EFA_u8868"><a href="#u521B_u5EFA_u8868" class="headerlink" title="创建表"></a>创建表</h1><p>创建表的通用形式如下：]]>
    </summary>
    
      <category term="SQLite" scheme="http://nightfade.github.io/tags/SQLite/"/>
    
      <category term="database" scheme="http://nightfade.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发中的Markdown渲染]]></title>
    <link href="http://nightfade.github.io/2015/06/26/ios-markdown-rendering/"/>
    <id>http://nightfade.github.io/2015/06/26/ios-markdown-rendering/</id>
    <published>2015-06-26T05:20:12.000Z</published>
    <updated>2016-01-18T08:03:56.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://bearychat.com/" target="_blank" rel="external">BearyChat</a>的消息是全面支持Markdown语法的，所以在开发<a href="https://bearychat.com/" target="_blank" rel="external">BearyChat</a>的iOS客户端的时候需要处理Markdown的渲染。</p>
<p>主要是两套实现方案：</p>
<ol>
<li>直接将Markdown文本转换成<code>NSAttributedString</code>。</li>
<li>先将Markdown文本转换成HTML，再将HTML转换成<code>NSAttributedString</code>。</li>
</ol>
<p>方案1可用的第三方库有：<a href="https://github.com/dreamwieber/AttributedMarkdown" target="_blank" rel="external">AttributedMarkdown</a>，这个库是基于C语言的<a href="https://github.com/humblehacker/peg-markdown/" target="_blank" rel="external">peg-markdown</a>的封装，经过试验发现对<a href="http://github.github.com/github-flavored-markdown/" target="_blank" rel="external">GitHub Flavored Markdown</a>支持的不太好。</p>
<p>方案2可用的第三方库相对多一些：</p>
<p>将Markdown文本转换成HTML可用的第三方库有：<a href="https://github.com/mdiep/MMMarkdown" target="_blank" rel="external">MMMarkdown</a>，<a href="https://github.com/OliverLetterer/GHMarkdownParser" target="_blank" rel="external">GHMarkdownParser</a>。其中<a href="https://github.com/OliverLetterer/GHMarkdownParser" target="_blank" rel="external">GHMarkdownParser</a>对<a href="http://github.github.com/github-flavored-markdown/" target="_blank" rel="external">GitHub Flavored Markdown</a>支持比较好。</p>
<p>将HTML转换成<code>NSAttributedString</code>，在iOS 7之后<code>UIKit</code>为<code>NSAttributedString</code>增加了<code>initWithData:options:documentAttributes:error:</code>方法可以直接转换：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSAttributedString</span> * attributedString = </span><br><span class="line">[[<span class="built_in">NSAttributedString</span> alloc] initWithData:[htmlString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>] </span><br><span class="line">                                 options:@&#123;<span class="built_in">NSDocumentTypeDocumentAttribute</span>: <span class="built_in">NSHTMLTextDocumentType</span>,</span><br><span class="line">                                           <span class="built_in">NSCharacterEncodingDocumentAttribute</span>: @(<span class="built_in">NSUTF8StringEncoding</span>)&#125; </span><br><span class="line">                      documentAttributes:<span class="literal">nil</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></p>
<p>但是实测发现，这个方法的计算速度非常慢！google了一下，貌似因为这个方法渲染的过程是需要初始化<code>ScriptCore</code>的，每次渲染都要初始化一个<code>ScriptCore</code>肯定是不能忍的。<br>第三方库的替代方案：<a href="https://github.com/Cocoanetics/DTCoreText" target="_blank" rel="external">DTCoreText</a>，<a href="https://github.com/dbowen/NSAttributedString-DDHTML" target="_blank" rel="external">NSAttributedString-DDHTML</a>。二者之中，<code>DTCoreText</code>是一个比较成熟的第三方库，对样式的控制也比较灵活。</p>
<p>所以最终选择的方案是：首先用<code>GHMarkdownParser</code>讲Markdown转换成HTML，之后再用<code>DTCoreText</code>讲HTML转换成<code>NSAttributedString</code>最后交给<code>UILabel</code>等控件渲染。<br>最终的实现代码就比较简单了：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;GHMarkdownParser/GHMarkdownParser.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;DTCoreText/DTCoreText.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MarkdownParser</span></span></span><br><span class="line"><span class="keyword">@property</span> GHMarkdownParser *htmlParser;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *DTCoreText_options;</span><br><span class="line">- (<span class="built_in">NSAttributedString</span> *)DTCoreText_attributedStringFromMarkdown:(<span class="built_in">NSString</span> *)text;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MarkdownParser</span></span></span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _htmlParser = [[GHMarkdownParser alloc] init];</span><br><span class="line">        _htmlParser<span class="variable">.options</span> = kGHMarkdownAutoLink;</span><br><span class="line">        _htmlParser<span class="variable">.githubFlavored</span> = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)htmlFromMarkdown:(<span class="built_in">NSString</span> *)text &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span><span class="variable">.htmlParser</span> HTMLStringFromMarkdownString:text];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSAttributedString</span> *)attributedStringFromMarkdown:(<span class="built_in">NSString</span> *)text &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *html = [<span class="keyword">self</span> htmlFromMarkdown:text];</span><br><span class="line">    <span class="built_in">NSData</span> *data = [html dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> *attributed = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithHTMLData:data options:<span class="keyword">self</span><span class="variable">.DTCoreText_options</span> documentAttributes:<span class="literal">nil</span>];    </span><br><span class="line">    <span class="keyword">return</span> attributed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)DTCoreText_options &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_DTCoreText_options) &#123;</span><br><span class="line">        _DTCoreText_options = @&#123;</span><br><span class="line">            DTUseiOS6Attributes:@YES,</span><br><span class="line">            DTIgnoreInlineStylesOption:@YES,</span><br><span class="line">            DTDefaultLinkDecoration:@NO,</span><br><span class="line">            DTDefaultLinkColor:[<span class="built_in">UIColor</span> blueColor],</span><br><span class="line">            DTLinkHighlightColorAttribute:[<span class="built_in">UIColor</span> redColor],</span><br><span class="line">            DTDefaultFontSize:@<span class="number">15</span>,</span><br><span class="line">            DTDefaultFontFamily:<span class="string">@"Helvetica Neue"</span>,</span><br><span class="line">            DTDefaultFontName:<span class="string">@"HelveticaNeue-Light"</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _DTCoreText_options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>到这里，绝大部分的问题都解决了，还有一点点小问题：把解析得到的<code>NSAttributedString</code>丢给<code>UILabel</code>的<code>attributedString</code>渲染的时候，在options里设置的链接的颜色是无效的，貌似<code>UILabel</code>对链接的渲染颜色是不可改的。继续寻找替代方案：用第三方的<a href="https://github.com/TTTAttributedLabel/TTTAttributedLabel" target="_blank" rel="external">TTTAttributedLabel</a>代替UILabel。<code>TTTAttributedLabel</code>是<code>UILabel</code>的派生类，为<code>UILabel</code>提供了更多对<code>NSAttributedString</code>的控制。通过为<code>TTTAttributedLabel</code>设置超链接的样式最终解决了Markdown渲染的相关问题。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;TTTAttributedLabel/TTTAttributedLabel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MarkdownLabel</span> : <span class="title">TTTAttributedLabel</span> &lt;<span class="title">TTTAttributedLabelDelegate</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)setDisplayedAttributedString:(<span class="keyword">id</span>)text;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MarkdownLabel</span></span></span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:aDecoder];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> commonConfig];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> commonConfig];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)commonConfig &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *linkAttributes = @&#123;</span><br><span class="line">         (<span class="keyword">id</span>)kCTForegroundColorAttributeName:[<span class="built_in">UIColor</span> blueColor],</span><br><span class="line">         <span class="built_in">NSUnderlineStyleAttributeName</span>:@(kCTUnderlineStyleNone),</span><br><span class="line">         <span class="built_in">NSFontAttributeName</span>:[<span class="built_in">UIFont</span> fontWithName:<span class="string">@"HelveticaNeue-Light"</span> size:<span class="number">15</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.linkAttributes</span> = linkAttributes;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.enabledTextCheckingTypes</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setDisplayedAttributedString:(<span class="keyword">id</span>)text &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *linksAndRange = [@[] mutableCopy];</span><br><span class="line">    [<span class="keyword">self</span> setText:[text string] afterInheritingLabelAttributesAndConfiguringWithBlock:^<span class="built_in">NSMutableAttributedString</span> *(<span class="built_in">NSMutableAttributedString</span> *mutableAttributedString) &#123;</span><br><span class="line">        [text enumerateAttributesInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, [text length])</span><br><span class="line">                                 options:<span class="number">0</span></span><br><span class="line">                              usingBlock:^(<span class="built_in">NSDictionary</span> *attrs, <span class="built_in">NSRange</span> range, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">                                  <span class="keyword">if</span> (attrs[<span class="built_in">NSLinkAttributeName</span>]) &#123;</span><br><span class="line">                                      [linksAndRange addObject:@[attrs[<span class="built_in">NSLinkAttributeName</span>], [<span class="built_in">NSValue</span> valueWithRange:range]]];</span><br><span class="line">                                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                      [mutableAttributedString addAttributes:attrs range:range];</span><br><span class="line">                                  &#125;</span><br><span class="line">                              &#125;];</span><br><span class="line">        <span class="keyword">return</span> mutableAttributedString;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSArray</span> *pair <span class="keyword">in</span> linksAndRange) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addLinkToURL:pair[<span class="number">0</span>] withRange:[pair[<span class="number">1</span>] rangeValue]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://bearychat.com/" target="_blank" rel="external">BearyChat</a>的消息是全面支持Markdown语法的，所以在开发<a href="https://bearychat.com/" ta]]>
    </summary>
    
      <category term="iOS" scheme="http://nightfade.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[可变高度的UITableViewCell]]></title>
    <link href="http://nightfade.github.io/2015/06/24/dynamic-height-cell/"/>
    <id>http://nightfade.github.io/2015/06/24/dynamic-height-cell/</id>
    <published>2015-06-24T12:28:12.000Z</published>
    <updated>2016-01-18T08:03:53.000Z</updated>
    <content type="html"><![CDATA[<p>可变高度的<code>UITableViewCell</code>用到的很多，简单总结一下利用autolayout实现自动计算高度的<code>UITableViewCell</code>的要点。</p>
<p>首先，设置Cell内部subviews的autolayout约束，这里就不再阐述。对于布局比较复杂的Cell，通过代码设置约束还是灵活很多的。</p>
<p><code>UITableView</code>在<code>UITableViewDelegate Protocol</code>的如下方法中计算Cell的高度，所以我们也主要在这个方法中计算高度的值。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> )tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> )indexPath;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>为了利用autolayout计算高度，我们先得有一个Cell的实例。可以创建一个Cell的成员变量，或者静态变量。</li>
<li>之后调用<code>cell.contentView</code>的<code>setNeedsLayout</code>和<code>layoutIfNeeded</code>方法触发autolayout计算合适的布局。</li>
<li>最后调用<code>cell.contentView</code>的<code>systemLayoutSizeFittingSize:</code>方法得到<code>cell.contentView</code>合适的高度。</li>
<li><code>UITableViewCell</code>的高度是<code>contentView</code>的高度加上分割线的高度(通常是1)，所以返回<code>contentView高度 + 1</code>才是正确的高度。</li>
</ol>
<p>相应代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123; </span><br><span class="line">    <span class="keyword">static</span> CustomCell *offscreenCell; </span><br><span class="line">    <span class="keyword">if</span> (!offscreenCell) &#123; </span><br><span class="line">        offscreenCell = [[CustomCell alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:<span class="string">@"Cell"</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// configure offscreenCell ... </span></span><br><span class="line">    [offscreenCell<span class="variable">.contentView</span> setNeedsLayout]; </span><br><span class="line">    [offscreenCell<span class="variable">.contentView</span> layoutIfNeeded]; </span><br><span class="line">    <span class="built_in">CGFloat</span> height = [offscreenCell<span class="variable">.contentView</span> systemLayoutSizeFittingSize:<span class="built_in">UILayoutFittingCompressedSize</span>]<span class="variable">.height</span>; </span><br><span class="line">    <span class="keyword">return</span> height + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时，需要保证：<code>cell.contentView.translatesAutoresizingMaskIntoConstraints = NO;</code><br>如果Cell包含支持多行文本的UILabel，还要设置<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cell<span class="variable">.textLabel</span><span class="variable">.lineBreakMode</span> = <span class="built_in">NSLineBreakByWordWrapping</span>;</span><br><span class="line">cell<span class="variable">.textLabel</span><span class="variable">.numberOfLines</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>这里有一个效率问题，<code>UITableView</code>是一次性计算所有Cell的高度，所以对于Cell比较多的情况需要较长时间计算才能显示内容。这个问题可以通过实现<code>- (CGFloat)tableView:(UITableView )tableView estimatedHeightForRowAtIndexPath:(NSIndexPath )indexPath;</code>方法解决。首先通过该方法返回一个估计值，之后要显示Cell的时候才计算准确的高度。</p>
<p>如果Cell里包含<code>UITextView</code>，那么还需要调用<code>UITextView</code>的<code>sizeThatFit:</code>方法进行额外的处理，示例代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">static</span> CustomCell *offscreenCell; </span><br><span class="line">    <span class="keyword">if</span> (!offscreenCell) &#123; </span><br><span class="line">        offscreenCell = [[CustomCell alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:<span class="string">@"Cell"</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// configure offscreenCell ... </span></span><br><span class="line">    [offscreenCell<span class="variable">.contentView</span> setNeedsLayout]; </span><br><span class="line">    [offscreenCell<span class="variable">.contentView</span> layoutIfNeeded]; </span><br><span class="line">    <span class="built_in">CGSize</span> size = [offscreenCell<span class="variable">.contentView</span> systemLayoutSizeFittingSize:<span class="built_in">UILayoutFittingCompressedSize</span>];</span><br><span class="line">    <span class="built_in">CGSize</span> textViewSize = [offscreen<span class="variable">.textView</span> sizeThatFits:<span class="built_in">CGSizeMake</span>(cell<span class="variable">.textView</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>, FLT_MAX)];</span><br><span class="line">    <span class="built_in">CGFloat</span> h = size<span class="variable">.height</span> + textViewSize<span class="variable">.height</span>;</span><br><span class="line">    h = h &gt; MIN_CELL_HEIGHT ? h : MIN_CELL_HEIGHT;  <span class="comment">//MIN_CELL_HEIGHT是CELL显示的最低高度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>可变高度的<code>UITableViewCell</code>用到的很多，简单总结一下利用autolayout实现自动计算高度的<code>UITableViewCell</code>的要点。</p>
<p>首先，设置Cell内部subviews的autolayout约]]>
    </summary>
    
      <category term="iOS" scheme="http://nightfade.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用七牛云存储实现HLS在线视频授权播放]]></title>
    <link href="http://nightfade.github.io/2015/05/10/qiniu-hls/"/>
    <id>http://nightfade.github.io/2015/05/10/qiniu-hls/</id>
    <published>2015-05-09T23:12:12.000Z</published>
    <updated>2016-01-18T08:12:15.000Z</updated>
    <content type="html"><![CDATA[<p>本文主要利用七牛云存储和node.js实现基于HLS的在线视频授权播放。</p>
<h2 id="1-__u5173_u4E8EHLS_u683C_u5F0F"><a href="#1-__u5173_u4E8EHLS_u683C_u5F0F" class="headerlink" title="1. 关于HLS格式"></a>1. 关于HLS格式</h2><p>定义可参考<a href="http://en.wikipedia.org/wiki/HTTP_Live_Streaming" target="_blank" rel="external">wikipedia定义</a>。简单来说：</p>
<blockquote>
<p>HTTP Live Streaming是由Apple提出的基于HTTP的流媒体传输协议。 它将一整个音视频流切割成可由HTTP下载的一个个小的音视频流，并生成一个播放列表（M3U8），客户端只需要获取资源的 M3U8 播放列表即可播放音视频。</p>
</blockquote>
<h2 id="2-__u57FA_u672C_u6D41_u7A0B"><a href="#2-__u57FA_u672C_u6D41_u7A0B" class="headerlink" title="2. 基本流程"></a>2. 基本流程</h2><p>我们希望实现的是私有在线视频播放，所以首先需要在七牛建立一个私有空间。令我们视频所在的私有<code>bucket</code>名称是<code>privatebucket</code>，上传视频的<code>key</code>是<code>example.mp4</code>，并且希望分片之后的<code>m3u8</code>文件也位于<code>privatebucket</code>空间内，<code>key</code>是<code>example.m3u8</code></p>
<ol>
<li><p>首先向七牛上传我们自己的视频。</p>
</li>
<li><p>利用七牛的<a href="http://developer.qiniu.com/docs/v6/api/reference/fop/av/segtime.html" target="_blank" rel="external">音视频分片API</a>将视频切割成HLS分片格式。在此以七牛的命令行客户端<a href="http://developer.qiniu.com/docs/v6/tools/qrsctl.html" target="_blank" rel="external">qrsctl</a>为例调用该API：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目标路径的EncodedEntryURI格式</span></span><br><span class="line">entry=`<span class="built_in">echo</span> <span class="string">"privatebucket:example.m3u8"</span> | base64 | tr <span class="string">"+/"</span> <span class="string">"-_"</span>`</span><br><span class="line"><span class="comment"># 视频分片触发持久化处理（pfop）</span></span><br><span class="line">./qboxrsctl pfop privatebucket example.mp4 <span class="string">"avthumb/m3u8/ab/320k/r/24|saveas/<span class="variable">$entry</span>"</span></span><br></pre></td></tr></table></figure>
<p>至此，已经完成分片的视频的<code>example.m3u8</code>文件已经位于我们的<code>privatebucket</code>空间中了。</p>
<ol>
<li>在自己的服务器中实现视频播放列表<code>example.m3u8</code>和相应切片文件的授权访问。</li>
</ol>
<p>七牛详细下载授权文档参见<a href="http://developer.qiniu.com/docs/v6/api/reference/security/download-token.html" target="_blank" rel="external">七牛下载凭证文档</a>。</p>
<p>本文以node.js实现为例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/video'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 0. 在这里进行授权验证</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> authorization</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 获取原始下载URL</span></span><br><span class="line">  <span class="keyword">var</span> rawDownloadURL = req.query.url;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 为下载URL加上过期时间，这里设为1天</span></span><br><span class="line">  <span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">var</span> tomorrow = <span class="keyword">new</span> <span class="built_in">Date</span>(today);</span><br><span class="line">  tomorrow.setDate(today.getDate()+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> unixTime = <span class="built_in">Math</span>.floor(tomorrow.getTime() / <span class="number">1000</span>);</span><br><span class="line">  rawDownloadURL = rawDownloadURL + <span class="string">"?pm3u8/0/expires/86400&amp;e="</span> + unixTime.toString();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 对上一步得到的URL字符串计算HMAC-SHA1签名（假设SecretKey是MY_SECRET_KEY）</span></span><br><span class="line">  <span class="comment">// 并对结果做URL安全的Base64编码</span></span><br><span class="line">  <span class="keyword">var</span> sign = crypto.createHmac(<span class="string">'sha1'</span>, <span class="string">'MY_SECRET_KEY'</span>)</span><br><span class="line">      .update(rawDownloadURL)</span><br><span class="line">      .digest()</span><br><span class="line">      .toString(<span class="string">'base64'</span>)</span><br><span class="line">      .replace(<span class="regexp">/\+/g</span>, <span class="string">'-'</span>)</span><br><span class="line">      .replace(<span class="regexp">/\//g</span>, <span class="string">'_'</span>);</span><br><span class="line">      </span><br><span class="line">  <span class="comment">// 4. 将AccessKey（假设是MY_ACCESS_KEY）与上一步计算得到的结果以“:”连接起来</span></span><br><span class="line">  <span class="keyword">var</span> token = [<span class="string">'MY_ACCESS_KEY'</span>, sign].join(<span class="string">':'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 5. 将下载凭证添加到含过期时间参数的下载URL之后，作为最后一个参数（token参数）</span></span><br><span class="line">  <span class="keyword">var</span> realDownloadURL = rawDownloadURL + <span class="string">"&amp;token="</span> + token;</span><br><span class="line">  </span><br><span class="line">  res.end(realDownloadURL);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里需要解释一下URL拼接<code>rawDownloadURL = rawDownloadURL + &quot;?pm3u8/0/expires/86400&amp;e=&quot; + unixTime.toString();</code>中加入的<code>pm3u8/0</code>选项。</p>
<p>因为除了要对<code>.m3u8</code>播放列表文件实现授权访问之外，每个片段资源也同样处在私有空间里，所以每个分片也必须进行下载授权，即要求对<code>.m3u8</code>文件里的每一个URL进行授权。七牛云提供的<code>pm3u8</code>接口就是用来实现这一功能：</p>
<p>假设已有如下m3u8文件（保存在私有空间中）：<code>http://developer.qiniu.com/samples/live_net.m3u8</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#EXTM3U&#10;#EXT-X-VERSION:3&#10;#EXT-X-MEDIA-SEQUENCE:0&#10;#EXT-X-ALLOW-CACHE:YES&#10;#EXT-X-TARGETDURATION:31&#10;#EXTINF:30.826000,&#10;http://developer.qiniu.com/samples/fop/av/live_00000_.ts&#10;#EXTINF:30.826000,&#10;http://developer.qiniu.com/samples/fop/av/live_00001_.ts&#10;#EXTINF:30.826000,&#10;http://developer.qiniu.com/samples/fop/av/live_00002_.ts&#10;#EXTINF:30.826000,&#10;http://developer.qiniu.com/samples/fop/av/live_00003_.ts&#10;#EXTINF:30.826000,&#10;http://developer.qiniu.com/samples/fop/av/live_00004_.ts&#10;#EXTINF:30.826000,&#10;http://developer.qiniu.com/samples/fop/av/live_00005_.ts&#10;#EXTINF:30.827000,&#10;http://developer.qiniu.com/samples/fop/av/live_00006_.ts&#10;#EXTINF:30.826000,&#10;http://developer.qiniu.com/samples/fop/av/live_00007_.ts&#10;#EXTINF:30.827000,&#10;http://developer.qiniu.com/samples/fop/av/live_00008_.ts&#10;#EXTINF:25.149000,&#10;http://developer.qiniu.com/samples/fop/av/live_00009_.ts&#10;#EXT-X-ENDLIST</span><br></pre></td></tr></table></figure>
<p>那么在浏览器中键入如下URL即可得到相应的授权m3u8文件：<code>http://developer.qiniu.com/samples/live_net.m3u8?pm3u8/0&amp;e=1388734117&amp;token=u8WqmQu1jH21kxpIQmo2LqntzugM1VoHE9_pozCU:sKjXkO59AxPtdaO2cEtWtiHmzdo=</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#EXTM3U&#10;#EXT-X-VERSION:3&#10;#EXT-X-MEDIA-SEQUENCE:0&#10;#EXT-X-ALLOW-CACHE:YES&#10;#EXT-X-TARGETDURATION:31&#10;#EXTINF:30.826000,&#10;http://developer.qiniu.com/samples/fop/av/live_00000_.ts?e=1388773727&#38;token=u8WqmQu1jH21kxpIQmo2LqntzugM1VoHE9_pozCU:qhXZvVauNafcUMoBeo4SkRWaWiw&#10;#EXTINF:30.826000,&#10;http://developer.qiniu.com/samples/fop/av/live_00001_.ts?e=1388773727&#38;token=u8WqmQu1jH21kxpIQmo2LqntzugM1VoHE9_pozCU:h1Oy8oW7oAIOGWZP8QNVAPI82Vw&#10;#EXTINF:30.826000,&#10;http://developer.qiniu.com/samples/fop/av/live_00002_.ts?e=1388773727&#38;token=u8WqmQu1jH21kxpIQmo2LqntzugM1VoHE9_pozCU:OQ6GMLEjFRnCAne9K9YU8-tXeIg&#10;#EXTINF:30.826000,&#10;http://developer.qiniu.com/samples/fop/av/live_00003_.ts?e=1388773727&#38;token=u8WqmQu1jH21kxpIQmo2LqntzugM1VoHE9_pozCU:XWdLiYgUxNZbqikNLQ3joG3Mvhk&#10;#EXTINF:30.826000,&#10;http://developer.qiniu.com/samples/fop/av/live_00004_.ts?e=1388773727&#38;token=u8WqmQu1jH21kxpIQmo2LqntzugM1VoHE9_pozCU:3EKOMwcqSUWsdap3SaY4l3RoaCg&#10;#EXTINF:30.826000,&#10;http://developer.qiniu.com/samples/fop/av/live_00005_.ts?e=1388773727&#38;token=u8WqmQu1jH21kxpIQmo2LqntzugM1VoHE9_pozCU:j4uORlTKDBHk4Xwkv90eCM3I87U&#10;#EXTINF:30.827000,&#10;http://developer.qiniu.com/samples/fop/av/live_00006_.ts?e=1388773727&#38;token=u8WqmQu1jH21kxpIQmo2LqntzugM1VoHE9_pozCU:tp7CjnEBGxGHkDbRqd8OehlGSno&#10;#EXTINF:30.826000,&#10;http://developer.qiniu.com/samples/fop/av/live_00007_.ts?e=1388773727&#38;token=u8WqmQu1jH21kxpIQmo2LqntzugM1VoHE9_pozCU:QxYkdqWEAYj90kgX5jUPedFxXVo&#10;#EXTINF:30.827000,&#10;http://developer.qiniu.com/samples/fop/av/live_00008_.ts?e=1388773727&#38;token=u8WqmQu1jH21kxpIQmo2LqntzugM1VoHE9_pozCU:MQ7EDzKP2f_EtpXq-maGr88mazA&#10;#EXTINF:25.149000,&#10;http://developer.qiniu.com/samples/fop/av/live_00009_.ts?e=1388773727&#38;token=u8WqmQu1jH21kxpIQmo2LqntzugM1VoHE9_pozCU:jmx4dIZndnrNFqzLg72YZM-qtmY&#10;#EXT-X-ENDLIST</span><br></pre></td></tr></table></figure>
<p>至此，基于HLS流媒体视频的授权播放流程就已经完成了，只需要在<code>app.get(&#39;/video&#39;, function(){});</code>中实现自己的授权验证逻辑即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要利用七牛云存储和node.js实现基于HLS的在线视频授权播放。</p>
<h2 id="1-__u5173_u4E8EHLS_u683C_u5F0F"><a href="#1-__u5173_u4E8EHLS_u683C_u5F0F" class="headerl]]>
    </summary>
    
      <category term="HLS" scheme="http://nightfade.github.io/tags/HLS/"/>
    
      <category term="node" scheme="http://nightfade.github.io/tags/node/"/>
    
      <category term="qiniu" scheme="http://nightfade.github.io/tags/qiniu/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Actor模型与游戏编程的一点想法]]></title>
    <link href="http://nightfade.github.io/2013/12/20/actor-model-and-game-development/"/>
    <id>http://nightfade.github.io/2013/12/20/actor-model-and-game-development/</id>
    <published>2013-12-20T14:28:32.000Z</published>
    <updated>2016-01-18T08:03:37.000Z</updated>
    <content type="html"><![CDATA[<p>在读<em>gevent</em>的tutorial的时候，一段关于Actor模型的简要描述引起了我的注意：</p>
<blockquote>
<p>Actor模型是一个由于Erlang变得普及的更高层的并发模型。简单的说它的主要思想就是许多个独立的Actor，每个Actor有一个可以从其它Actor接收消息的收件箱。Actor内部的主循环遍历它收到的消息，并根据它期望的行为来采取行动。</p>
</blockquote>
<p>看到这段描述突然就想到了七八月份做的MINI项目以及现在正在开发的游戏中，对于游戏的个体之间的交互行为的处理。总结起来，有以下几个关键点：</p>
<ul>
<li><p>游戏中的各个实体之间的交互行为是很多的，如果单纯使用对象之间相互调用方法的方式来实现交互，代码很快就会耦合成一团乱麻。而Actor模型的消息和收件箱机制，可以很好的解决这个问题，只需要搭建起一个合适的消息中转机制即可。</p>
</li>
<li><p>大多数游戏的本质是模拟现实世界，而现实世界中的个体本身就是具有并发性的特点的。我们可以在游戏中串行化地模拟这些个体，从而简化编程过程。但是使用Actor模型，理论上来说可以让我们直接并发地去模拟这些个体。</p>
</li>
<li><p>Actor模型的“信箱”确实是一个可以处理并发问题的利器。最初在MINI项目中大量使用多线程的时候，就意识到如果可以用队列来处理并发线程之间的所有交互，那么并发问题就可以得到大大简化。队列其实就是一个有序的“信箱”。只是当时并没有想过要把这个思路抽象出来，建立一个统一的框架来处理所有的并发问题。</p>
</li>
</ul>
<p>严谨起见还是去查了一下Wikipedia的定义：</p>
<blockquote>
<p>The actor model in computer science is a mathematical model of concurrent computation that <strong>treats “actors” as the universal primitives</strong> of concurrent digital computation: in response to a message that it receives, an actor can make local decisions, create more actors, send more messages, and determine how to respond to the next message received.</p>
</blockquote>
<p>基本概念：</p>
<blockquote>
<p>The Actor model adopts the philosophy that <strong>everything is an actor</strong>. This is similar to the everything is an object philosophy used by some object-oriented programming languages, but differs in that object-oriented software is typically executed sequentially, while the Actor model is inherently concurrent.<br>An actor is a computational entity that, in response to a message it receives, can concurrently:</p>
<ol>
<li>send a finite number of messages to other actors;</li>
<li>create a finite number of new actors;</li>
<li>designate the behavior to be used for the next message it receives.</li>
</ol>
<p>There is no assumed sequence to the above actions and they could be carried out in parallel.</p>
</blockquote>
<p>目前看起来，这个模型用在游戏开发中非常适合。但是真正使用起来会遇到什么困难还是需要实践之后才能知晓。后面的开发中会尝试把Actor模型真正用起来，踩一踩这里面的坑：）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在读<em>gevent</em>的tutorial的时候，一段关于Actor模型的简要描述引起了我的注意：</p>
<blockquote>
<p>Actor模型是一个由于Erlang变得普及的更高层的并发模型。简单的说它的主要思想就是许多个独立的Actor，每个Acto]]>
    </summary>
    
      <category term="Actor" scheme="http://nightfade.github.io/tags/Actor/"/>
    
      <category term="GameDev" scheme="http://nightfade.github.io/tags/GameDev/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Implement an Asynchronous RPC Basing on Protocol Buffers]]></title>
    <link href="http://nightfade.github.io/2013/12/15/implement-an-asynchronous-rpc-basing-on-protocol-buffers/"/>
    <id>http://nightfade.github.io/2013/12/15/implement-an-asynchronous-rpc-basing-on-protocol-buffers/</id>
    <published>2013-12-15T03:12:41.000Z</published>
    <updated>2016-01-18T08:03:26.000Z</updated>
    <content type="html"><![CDATA[<p>在前一篇博文《Dive Into Protocol Buffers Python API》中对<em>protobuf</em>的Python API的代码进行了分析。现在进入实践阶段，利用<em>protobuf</em>的<code>service</code> API实现一套异步RPC机制。</p>
<p>严谨起见，从<em>wikipedia</em>上摘录下一般情况下一次RPC调用的过程：</p>
<blockquote>
<ol>
<li>The client calls the client stub. The call is a <strong>local procedure call</strong>, with parameters pushed on to the stack in the normal way.</li>
<li>The client stub packs the parameters into a message and makes a system call to send the message. Packing the parameters is called <strong>marshalling</strong>.</li>
<li>The client’s local operating system <strong>sends</strong> the message from the client machine to the server machine.</li>
<li>The local operating system on the server machine passes the <strong>incoming</strong> packets to the server stub.</li>
<li>The server stub unpacks the parameters from the message. Unpacking the parameters is called <strong>unmarshalling</strong>.</li>
<li>Finally, the server stub calls <strong>the server procedure</strong>. The reply traces the same steps in the reverse direction.</li>
</ol>
</blockquote>
<p>上面过程中的第1和第6步已经由<em>protobuf</em>的<code>service</code> API为我们实现好了，我们只需要在proto文件中定义所需的具体调用接口即可。</p>
<p>对于第2和第5步的<em>marshalling</em>和<em>unmarshalling</em>步骤，<code>service</code> API虽然没有为我们完全实现，但是<em>protobuf</em>为方法以及参数已经准备好了完善的<em>serialization</em>的机制，我们只需要自己决定如何用这些序列化的数据拼装数据包即可。</p>
<p>最后，第3和第4步的通信机制则是完全需要由我们自己来实现的，这也是<em>protobuf</em>设计的初衷，在最多变的部分（多种多样的网络结构、协议和通信机制）留出足够的空间让程序员可以针对特定场景自己实现，使得<em>protobuf</em>可以应用在更多的场景。</p>
<p>回到标题所说的<em>Asynchronous RPC</em>。一次函数调用通常包含了输入和输出两个过程。对于RPC来说，我们可以像大多数本地函数那样，在进行调用之后一直等待，直到计算结果返回才继续向下执行。但是由于网络传输的过程相对比较耗时，采取这样的策略无疑是非常低效的。因此我们采取另外一种策略：调用者发送调用请求之后不等待结果的返回就立即继续执行后续的操作，当收到RPC返回的计算结果之后再回来处理。这里将前一种策略称为<em>Synchronous RPC</em>，而后一种就是本文要实现的<em>Asynchronous RPC</em>。</p>
<p>实现的方式其实也很简单，就是把客户端发起的一次RPC调用拆分成两次来处理：首先由客户端发起RPC调用，之后无需等待继续向后执行；而服务端接收到RPC调用请求并处理完成之后，再向客户端发起另外一次RPC调用，将计算结果通过参数通知客户端。</p>
<p>关于RPC需要说明的东西大概就到这里，接下来我们首先解决第3和第4步的通信机制的实现。</p>
<h2 id="u5B9E_u73B0_u901A_u4FE1_u5C42"><a href="#u5B9E_u73B0_u901A_u4FE1_u5C42" class="headerlink" title="实现通信层"></a>实现通信层</h2><p>我们选择使用asyncore和TCP协议实现RPC的通信层。关于asyncore的具体用法可以参考<a href="http://docs.python.org/2/library/asyncore.html" target="_blank" rel="external">asyncore的文档</a>。</p>
<p>首先将端到端的链接和传输抽象出来，一个端到端的通信可以用下面这样一个<code>TcpConnection</code>来进行封装：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpConnection</span><span class="params">(asyncore.dispatcher)</span>:</span></span><br><span class="line"></span><br><span class="line">    ST_INIT = <span class="number">0</span></span><br><span class="line">    ST_ESTABLISHED = <span class="number">1</span></span><br><span class="line">    ST_DISCONNECTED = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sock)</span>:</span></span><br><span class="line">        asyncore.dispatcher.__init__(self, sock)</span><br><span class="line">        self.peername = peername</span><br><span class="line">        self.writebuff = <span class="string">''</span></span><br><span class="line">        self.status = TcpConnection.ST_ESTABLISHED <span class="keyword">if</span> sock <span class="keyword">else</span> TcpConnection.ST_INIT</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_read</span><span class="params">(self)</span>:</span></span><br><span class="line">        data = self.recv(<span class="number">4096</span>)</span><br><span class="line">        <span class="comment"># process data here</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_write</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.writebuff:</span><br><span class="line">            size = self.send(self.writebuff)</span><br><span class="line">            self.writebuff = self.writebuff[size:]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">writable</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.status == TcpConnection.ST_ESTABLISHED:</span><br><span class="line">            <span class="keyword">return</span> len(self.writebuff) &gt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.writebuff += data</span><br></pre></td></tr></table></figure>
<p>客户端负责主动向服务端发起连接请求，在请求成功后维护自己到服务端的<strong>一条</strong>连接。因此我们可以通过继承<code>TcpConnection</code>并增加<code>connect</code>行为得到通信的客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpClient</span><span class="params">(TcpConnection)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ip, port)</span>:</span></span><br><span class="line">        TcpConnection.__init__(self, <span class="keyword">None</span>)</span><br><span class="line">        self.ip = ip</span><br><span class="line">        self.port = port</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">async_connect</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.connect(self.peername)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_connect</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.status = TcpConnection.ST_ESTABLISHED</span><br></pre></td></tr></table></figure>
<p>服务端则负责监听并接受客户端的连接请求，并为每一个客户维护一条连接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span><span class="params">(asyncore.dispatcher)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ip, port)</span>:</span></span><br><span class="line">        asyncore.dispatcher.__init__(self)</span><br><span class="line">        self.ip = ip</span><br><span class="line">        self.port = port</span><br><span class="line"></span><br><span class="line">        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.set_reuse_addr()</span><br><span class="line">        self.bind((self.ip, self.port))</span><br><span class="line">        self.listen(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_accept</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sock, addr = self.accept()</span><br><span class="line">        <span class="keyword">except</span> socket.error, e:</span><br><span class="line">            self.logger.warning(<span class="string">'accept error: '</span> + e.message)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">except</span> TypeError, e:</span><br><span class="line">            self.logger.warning(<span class="string">'accept error: '</span> + e.message)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        conn = TcpConnection(sock, addr)</span><br><span class="line">        self.handle_new_connection(conn)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_new_connection</span><span class="params">(self, conn)</span>:</span></span><br><span class="line">    	<span class="string">""" handle new connection here """</span></span><br><span class="line">    	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>至此，我们就完成了一个简陋但有效的C/S模式的通信层。</p>
<h2 id="u5B9E_u73B0Echo_u670D_u52A1"><a href="#u5B9E_u73B0Echo_u670D_u52A1" class="headerlink" title="实现Echo服务"></a>实现Echo服务</h2><p>有了通信层，我们就可以继续向下进行。既然是RPC，那么就不可能脱离具体的业务，因此这里以经典的<em>Echo</em>服务为例，利用<em>protobuf</em>实现RPC。</p>
<p>我们为Echo定义proto如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package nightfade;</span><br><span class="line"></span><br><span class="line">option py_generic_services = true;</span><br><span class="line"></span><br><span class="line">message Void &#123;&#125;</span><br><span class="line"></span><br><span class="line">message EchoString &#123;</span><br><span class="line">    required string message = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service IEchoService &#123;</span><br><span class="line">    rpc echo(EchoString) returns(Void);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service IEchoClient &#123;</span><br><span class="line">    rpc respond(EchoString) returns(Void);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如前所述，因为要实现的是<em>Asynchronous RPC</em>，所以RPC调用分为两部分：</p>
<p>客户端首先调用<code>echo</code>，之后服务端接收到RPC请求并处理之后再调用<code>respond</code>将结果通知客户端。</p>
<p>使用<em>protoc</em>编译proto文件以及对生成的文件的分析这里就不在赘述，可以参考《Dive Into Protocol Buffers Python API》。这里需要关注的问题有两个：</p>
<ol>
<li>如何实现<em>Service</em>。</li>
<li>如何将实现好的<em>Service</em>与我们的通信层关联起来。</li>
</ol>
<p>因为Echo服务本身非常简单，所以第一个问题可以轻易解决：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoService</span><span class="params">(IEchoService)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(self, rpc_controller, echo_string, callback=None)</span>:</span></span><br><span class="line">        client_stub = IEchoClient_Stub(rpc_controller.rpc_channel)</span><br><span class="line">        client_stub.respond(rpc_controller, echo_string, callback=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<p>接下来我们需要考虑的就是与通信层的关联问题。</p>
<p>要将<em>protobuf</em>的<code>service</code>与通信层关联的关键在于<code>RpcChannel</code>。</p>
<p>首先来看调用端这一边。</p>
<p>调用端通过<em>stub</em>对RPC过程的调用最终会转向对<code>RpcChannel.CallMethod()</code>的调用，而这个方法也正是<em>protobuf</em>留给我们实现调用端进行<strong>marshalling</strong>和数据发送的地方。这样一来问题就很容易解决了，我们为RpcChannel实现<code>CallMethod</code>方法：</p>
<ol>
<li>无论是调用端还是被调用端，一个<code>method_descriptor</code>在其所在<em>Service</em>内的<em>index</em>是一致的。因此<em>method_descriptor</em>的部分只需要对其<em>index</em>进行<em>marshalling</em>即可。</li>
<li>RPC调用的参数可以直接使用<em>protobuf</em>的<code>SerializeToString()</code>方法进行<em>marshalling</em>，进而在接收端通过<code>ParseFromString()</code>方法<em>unmarshalling</em>。</li>
<li>数据包的<em>Framing</em>问题，则使用一个简单的方案：在数据包之前发送一个32位整数的<em>HEAD</em>用来告知接收端后续数据包的大小。</li>
</ol>
<p>具体实现来看代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RpcChannel</span><span class="params">(service.RpcChannel)</span>:</span></span><br><span class="line"></span><br><span class="line">    HEAD_FMT = <span class="string">'!I'</span></span><br><span class="line">    INDEX_FMT = <span class="string">'!H'</span></span><br><span class="line">    HEAD_LEN = struct.calcsize(HEAD_FMT)</span><br><span class="line">    INDEX_LEN = struct.calcsize(INDEX_FMT)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, conn)</span>:</span></span><br><span class="line">        super(RpcChannel, self).__init__()</span><br><span class="line">        self.conn = conn</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CallMethod</span><span class="params">(self,</span><br><span class="line">                   method_descriptor,</span><br><span class="line">                   rpc_controller,</span><br><span class="line">                   request,</span><br><span class="line">                   response_class,</span><br><span class="line">                   done)</span>:</span></span><br><span class="line">        index = method_descriptor.index</span><br><span class="line">        data = request.SerializeToString()</span><br><span class="line">        size = RpcChannel.INDEX_LEN + len(data)</span><br><span class="line"></span><br><span class="line">        self.conn.send_data(struct.pack(RpcChannel.HEAD_FMT, size))</span><br><span class="line">        self.conn.send_data(struct.pack(RpcChannel.INDEX_FMT, index))</span><br><span class="line">        self.conn.send_data(data)</span><br></pre></td></tr></table></figure>
<p>接下来实现被调用端。</p>
<p><em>protobuf</em>的<code>service</code> API在被调用端为我们完成的工作是，当使用合适的<code>method_descriptor</code>和<code>request</code>参数调用<code>IEchoService.CallMethod()</code>时，会自动调用我们对相应方法接口的具体实现。因此在服务端需要做的工作主要由：</p>
<ol>
<li>接受调用端发来的数据。</li>
<li>对接收到的数据包进行<em>unmashalling</em>，解析得到<code>method_descriptor</code>和<code>request</code>参数。</li>
<li>调用<code>EchoService.CallMethod()</code>。</li>
</ol>
<p>我们实现的<code>TcpConnection</code>可以完成接受数据的工作，只是还没能与后续的步骤关联起来。既然<em>marshalling</em>的工作是由<code>RpcChannel</code>来完成的，<em>unmarshalling</em>的功能我们也同样在<code>RpcChannel</code>中实现，为其增加<code>receive</code>方法。当<code>TcpConnection</code>接受到数据之后，就交给<code>RpcChannel.receive</code>进行处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rpc_calls = self.rpc_parser.feed(data)</span><br><span class="line">    <span class="keyword">except</span> (AttributeError, IndexError), e:</span><br><span class="line">        self.close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> method_descriptor, request <span class="keyword">in</span> rpc_calls:</span><br><span class="line">        self.service_local.CallMethod(method_descriptor, self.rpc_controller, request, callback=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<p>其中<code>rpc_parser</code>负责将数据流<em>unmarshalling</em>成一系列的<code>method_descriptor</code>和<code>request</code>参数，具体实现就不再贴代码了。<code>service_local</code>则是服务端提供的服务<code>EchoService</code>。</p>
<p>至此，我们的整个RPC调用的的基本实现就已经完成了！限于篇幅，所以只贴了一些代码片段，完整的代码可以查看我的repository：<a href="https://github.com/nightfade/protobuf-RPC" target="_blank" rel="external">https://github.com/nightfade/protobuf-RPC</a>。</p>
<h2 id="u5176_u4ED6"><a href="#u5176_u4ED6" class="headerlink" title="其他"></a>其他</h2><p>在这个RPC的实现中，其实还欠缺了一个重要部分<code>RpcController</code>。这个部分是干什么用的呢？依然引用<em>wikipedia</em>的一段说明：</p>
<blockquote>
<p>An important difference between remote procedure calls and local calls is that remote calls can fail because of unpredictable network problems. Also, callers generally must deal with such failures without knowing whether the remote procedure was actually invoked. Idempotent procedures (those that have no additional effects if called more than once) are easily handled, but enough difficulties remain that code to call remote procedures is often confined to carefully written low-level subsystems.</p>
</blockquote>
<p>简单来说，RPC过程总是可能由于网络问题等不可预测的原因出错的，我们需要有一种途径来捕获并处理RPC过程中所发生的错误。<code>RpcController</code>就是为此而存在的，它定义了一些常用的错误处理的抽象接口，可以根据具体的场景进行实现。</p>
<p>鉴于<code>RpcController</code>的定义非常简单明确，并且是和具体场景紧密关联的，这里就不在上面花费更多精力了。以后业务逻辑逐渐复杂的时候，再根据需要case by case的进行实现即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在前一篇博文《Dive Into Protocol Buffers Python API》中对<em>protobuf</em>的Python API的代码进行了分析。现在进入实践阶段，利用<em>protobuf</em>的<code>service</code> API]]>
    </summary>
    
      <category term="Network" scheme="http://nightfade.github.io/tags/Network/"/>
    
      <category term="RPC" scheme="http://nightfade.github.io/tags/RPC/"/>
    
      <category term="protobuf" scheme="http://nightfade.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Dive into Protocol Buffers Python API]]></title>
    <link href="http://nightfade.github.io/2013/12/13/dive-into-protocol-buffers-python-api/"/>
    <id>http://nightfade.github.io/2013/12/13/dive-into-protocol-buffers-python-api/</id>
    <published>2013-12-13T15:01:13.000Z</published>
    <updated>2016-01-18T08:03:17.000Z</updated>
    <content type="html"><![CDATA[<p><em>Google Protocol Buffers</em>是Google使用的数据交换格式，在RPC协议和文件存储等有广泛的应用。其基本使用方法就不在赘述，可以参看<em>protobuf</em>的项目主页：<a href="https://code.google.com/p/protobuf/" target="_blank" rel="external">https://code.google.com/p/protobuf/</a>。本文的主要内容是剖析<em>protobuf</em>的Python API的具体实现。</p>
<p>由于我们需要的不仅仅是单纯的<code>message</code>结构，后续还希望使用<em>protobuf</em>的<code>service</code>实现RPC机制，因此本文会对这两部分内容进行分析。同时，为了使得剖析过程尽可能清晰，使用最简单的<code>message</code>和<code>service</code>结构作为研究对象，但是思路理清楚之后，更复杂的结构分析起来也是大同小异的。本文的以如下的proto文件及其编译出的代码作为剖析的起点：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package sample;</span><br><span class="line"></span><br><span class="line">option py_generic_services = true;</span><br><span class="line"></span><br><span class="line">message Void &#123;&#125;</span><br><span class="line"></span><br><span class="line">message SampleMessage &#123;</span><br><span class="line">    required string message = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service SampleService &#123;</span><br><span class="line">    rpc echo(SampleMessage) returns(Void);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>protoc</code>进行编译，即可得到对应的Python模块sample_pb2.py：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --python_out=. sample.proto</span><br></pre></td></tr></table></figure>
<p>生成的py代码超过100行，为了方便剖析，接下来按照结构分块进行剖析。</p>
<h2 id="message"><a href="#message" class="headerlink" title="message"></a>message</h2><p>对<code>message</code>的剖析，使用<code>message SampleMessage</code>的生成代码。</p>
<p><code>message SampleMessage</code>对应的Python class的定义非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleMessage</span><span class="params">(_message.Message)</span>:</span></span><br><span class="line">    __metaclass__ = _reflection.GeneratedProtocolMessageType</span><br><span class="line">    DESCRIPTOR = _SAMPLEMESSAGE</span><br></pre></td></tr></table></figure>
<p>这里涉及到的<code>__metaclass__</code>可以参看上一篇博文<a href="/blog/2013/12/12/python-meta-programming/">《Python Meta-programming》</a>。</p>
<p>这里的<code>_SAMPLEMESSAGE</code>的具体定义是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_SAMPLEMESSAGE = _descriptor.Descriptor(</span><br><span class="line">  name=<span class="string">'SampleMessage'</span>,</span><br><span class="line">  full_name=<span class="string">'sample.SampleMessage'</span>,</span><br><span class="line">  filename=<span class="keyword">None</span>,</span><br><span class="line">  file=DESCRIPTOR,</span><br><span class="line">  containing_type=<span class="keyword">None</span>,</span><br><span class="line">  fields=[</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">'message'</span>, full_name=<span class="string">'sample.SampleMessage.message'</span>, index=<span class="number">0</span>,</span><br><span class="line">      number=<span class="number">1</span>, type=<span class="number">9</span>, cpp_type=<span class="number">9</span>, label=<span class="number">2</span>,</span><br><span class="line">      has_default_value=<span class="keyword">False</span>, default_value=unicode(<span class="string">""</span>, <span class="string">"utf-8"</span>),</span><br><span class="line">      message_type=<span class="keyword">None</span>, enum_type=<span class="keyword">None</span>, containing_type=<span class="keyword">None</span>,</span><br><span class="line">      is_extension=<span class="keyword">False</span>, extension_scope=<span class="keyword">None</span>,</span><br><span class="line">      options=<span class="keyword">None</span>),</span><br><span class="line">  ],</span><br><span class="line">  extensions=[</span><br><span class="line">  ],</span><br><span class="line">  nested_types=[],</span><br><span class="line">  enum_types=[</span><br><span class="line">  ],</span><br><span class="line">  options=<span class="keyword">None</span>,</span><br><span class="line">  is_extendable=<span class="keyword">False</span>,</span><br><span class="line">  extension_ranges=[],</span><br><span class="line">  serialized_start=<span class="number">32</span>,</span><br><span class="line">  serialized_end=<span class="number">64</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>看起来我们在proto文件中所定义的信息基本都在这里了，事实上如果查看<code>Descriptor</code>的代码，这个结构的琐碎细节也主要是用来组织数据而已。而动态生成相应class的机制，应该主要是由<code>GeneratedProtocolMessageType</code>实现的，就让我们来看一下其源码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratedProtocolMessageType</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    _DESCRIPTOR_KEY = <span class="string">'DESCRIPTOR'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, dictionary)</span>:</span></span><br><span class="line">        descriptor = dictionary[GeneratedProtocolMessageType._DESCRIPTOR_KEY]</span><br><span class="line">        bases = _NewMessage(bases, descriptor, dictionary)</span><br><span class="line">        superclass = super(GeneratedProtocolMessageType, cls)</span><br><span class="line"></span><br><span class="line">        new_class = superclass.__new__(cls, name, bases, dictionary)</span><br><span class="line">        setattr(descriptor, <span class="string">'_concrete_class'</span>, new_class)</span><br><span class="line">        <span class="keyword">return</span> new_class</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dictionary)</span>:</span></span><br><span class="line">        descriptor = dictionary[GeneratedProtocolMessageType._DESCRIPTOR_KEY]</span><br><span class="line">        _InitMessage(descriptor, cls)</span><br><span class="line">        superclass = super(GeneratedProtocolMessageType, cls)</span><br><span class="line">        superclass.__init__(name, bases, dictionary)</span><br></pre></td></tr></table></figure>
<p>看到之前<code>__metaclass__</code>，其实我们就已经可以知道其是利用Python的Meta-programming机制来动态生成类的了。而上面这段<code>GeneratedProtocolMessageType</code>正是继承了<code>type</code>类，因此也是一个元类。</p>
<p>这里需要解释一下我们在使用<code>class</code>语法定义一个类的时候，传给Metaclass的三个参数的赋值内容。在这里我们可以简单的做一个实验，用如下方式定义一个类及其元类，并生成一个实例对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaType</span><span class="params">(type)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, dictionary)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'name: '</span> + pprint.pformat(name)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'bases'</span> + pprint.pformat(bases)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'dictionary'</span> + pprint.pformat(dictionary)</span><br><span class="line"></span><br><span class="line">        superclass = super(MetaType, cls)</span><br><span class="line">        new_class = superclass.__new__(cls, name, bases, dictionary)</span><br><span class="line">        <span class="keyword">return</span> new_class</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dictionary)</span>:</span></span><br><span class="line">        superclass = super(MetaType, cls)</span><br><span class="line">        superclass.__init__(name, bases, dictionary)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = MetaType</span><br><span class="line">    </span><br><span class="line">    CLASS_PROPERTY = <span class="string">'CLASS_PROPERTY'</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">instance = A()</span><br></pre></td></tr></table></figure>
<p>运行该脚本得到如下输出结果：</p>
<pre><code>name: &apos;A&apos;
bases(&lt;type &apos;object&apos;&gt;,)
dictionary{&apos;CLASS_PROPERTY&apos;: &apos;CLASS_PROPERTY&apos;,
 &apos;__metaclass__&apos;: &lt;class &apos;__main__.MetaType&apos;&gt;,
 &apos;__module__&apos;: &apos;__main__&apos;,
 &apos;method&apos;: &lt;function method at 0x110193b18&gt;}
</code></pre><p>到这里，实例化<code>message</code>所对应的对象实例的过程就已经很清楚了：</p>
<p>首先protoc编译proto文件，生成对应与<code>message</code>的<code>Descriptor</code>以及一个简单的<code>class</code>骨架，这个<code>class</code>的主要作用就是通过类属性把对应<code>Descriptor</code>传给<code>GeneratedProtocolMessageType</code>。</p>
<p>而Python解释器真正要生成<code>message</code>所对应的<code>class</code>的时候，<code>GeneratedProtocolMessageType</code>会读取<code>Descriptor</code>中的属性和域的信息，动态的在生成的类实例中通过<code>InitMessage</code>（其最终是通过调用<code>setattr</code>）插入相应的属性和方法。</p>
<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>相对于<code>message</code>来说，service的组成结构就更复杂一些，项目文档里对<code>service</code>也不够详细。概括来说，<code>service</code>主要是根据proto文件中的接口定义生成一个RPC调用的抽象层。这个抽象层是被设计成独立于任何RPC实现的，也就是说protobuf的作用只是帮助你在不同语言之间生成统一的调用接口，你可以在这个接口之下使用任何的通信机制来实现RPC过程。</p>
<p>虽然听起来很美，但是这样的抽象层也带来了过多不必要的间接层，在<em>protobuf 2.3</em>版本之后已经不鼓励继续使用<code>service</code>来实现RPC。但是一方面由于要取代<code>service</code>的<code>plugins</code>机制依然还在试验阶段，另一方面目前现有的很多的RPC实现依然是基于<code>service</code>，因此本文还是以<code>service</code>为研究对象来剖析如何利用<code>protobuf</code>来实现RPC机制。</p>
<p>利用<em>protobuf</em>的<code>service</code>来实现RPC，主要涉及三个对象：</p>
<ol>
<li><p><code>Service</code>： 提供了RPC可调用的方法的抽象层接口，由具体的服务或stub继承这个抽象接口，并进行具体实现。</p>
</li>
<li><p><code>RpcChannel</code>：其负责与一个<code>Service</code>进行通信并调用其提供的RPC方法，通常情况下会在调用端实现一个<code>stub</code>对<code>RpcChannel</code>进行封装，通过调用<code>stub</code>的函数接口将调用行为转换为数据流通过<code>RpcChannel</code>进行传输，而不会直接使用<code>RpcChannel</code>。</p>
</li>
<li><p><code>RpcController</code>：主要作用是提供一种可以控制RPC调用过程或者查明RPC过程中发生的错误的方式。</p>
</li>
</ol>
<p>在这里我们依然结合之前的实例来对<code>service</code>进行剖析。同时，还会通过简单实现一个<em>Echo Service</em>的RPC调用来说明<code>service</code>的三个抽象对象是如何协作的。</p>
<p>同样的，我们从前面的proto文件编译出的py代码开始进行分析。其中对应<code>service</code>接口的两个抽象类的定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleService</span><span class="params">(_service.Service)</span>:</span></span><br><span class="line">    __metaclass__ = service_reflection.GeneratedServiceType</span><br><span class="line">    DESCRIPTOR = _SAMPLESERVICE</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleService_Stub</span><span class="params">(SampleService)</span>:</span></span><br><span class="line">    __metaclass__ = service_reflection.GeneratedServiceStubType</span><br><span class="line">    DESCRIPTOR = _SAMPLESERVICE</span><br></pre></td></tr></table></figure>
<p><code>SampleService</code>是为服务的<strong>被调用端</strong>提供的抽象接口，被调用段通过继承该接口并实现相应方法为调用端提供服务。</p>
<p><code>SampleService_Stub</code>则是为<strong>调用端</strong>提供的<code>stub</code>的抽象接口。调用端需要做的事情则是继承该接口，将RPC函数接口的调用转化为数据流，并通过通信管道传递到被调用一端。</p>
<p>和<code>message</code>一样，这两个类只是一个骨架，其真正的实现是通过<code>__metaclass__</code>以及<code>Descriptor</code>进行实现。</p>
<p>我们首先来看一下<code>service</code>的<code>Descriptor</code>是什么样子的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_SAMPLESERVICE = _descriptor.ServiceDescriptor(</span><br><span class="line">  name=<span class="string">'SampleService'</span>,</span><br><span class="line">  full_name=<span class="string">'sample.SampleService'</span>,</span><br><span class="line">  file=DESCRIPTOR,</span><br><span class="line">  index=<span class="number">0</span>,</span><br><span class="line">  options=<span class="keyword">None</span>,</span><br><span class="line">  serialized_start=<span class="number">66</span>,</span><br><span class="line">  serialized_end=<span class="number">126</span>,</span><br><span class="line">  methods=[</span><br><span class="line">  _descriptor.MethodDescriptor(</span><br><span class="line">    name=<span class="string">'echo'</span>,</span><br><span class="line">    full_name=<span class="string">'sample.SampleService.echo'</span>,</span><br><span class="line">    index=<span class="number">0</span>,</span><br><span class="line">    containing_service=<span class="keyword">None</span>,</span><br><span class="line">    input_type=_SAMPLEMESSAGE,</span><br><span class="line">    output_type=_VOID,</span><br><span class="line">    options=<span class="keyword">None</span>,</span><br><span class="line">  ),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>这个<code>Descriptor</code>依然包含了许多属性，但是我们其实更多的只需要关注<code>methods</code>这个属性，它是一个<code>list</code>，包含了我们在<code>service</code>中的定义的所有方法。之所以要关注<code>methods</code>，是因为在后续做RPC底层通信的具体实现的时候，主要需要传递的数据就是我们所调用的RPC方法及相应参数的描述。</p>
<p>接下来我们看一下被调用端的<code>Service</code>的元类<strong><code>GeneratedServiceType</code></strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratedServiceType</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    _DESCRIPTOR_KEY = <span class="string">'DESCRIPTOR'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dictionary)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> GeneratedServiceType._DESCRIPTOR_KEY <span class="keyword">not</span> <span class="keyword">in</span> dictionary:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        descriptor = dictionary[GeneratedServiceType._DESCRIPTOR_KEY]</span><br><span class="line">        service_builder = _ServiceBuilder(descriptor)</span><br><span class="line">        service_builder.BuildService(cls)</span><br></pre></td></tr></table></figure>
<p>这一层的定义依然非常简单，具体的细节我们需要进一步向前追溯到<code>_ServiceBuilder.BuildService</code>的代码才能一探究竟：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ServiceBuilder</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, service_descriptor)</span>:</span></span><br><span class="line">        self.descriptor = service_descriptor</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BuildService</span><span class="params">(self, cls)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_WrapCallMethod</span><span class="params">(srvc, method_descriptor,</span><br><span class="line">                            rpc_controller, request, callback)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self._CallMethod(srvc, method_descriptor,</span><br><span class="line">                           rpc_controller, request, callback)</span><br><span class="line">        self.cls = cls</span><br><span class="line">        cls.CallMethod = _WrapCallMethod</span><br><span class="line">        cls.GetDescriptor = staticmethod(<span class="keyword">lambda</span>: self.descriptor)</span><br><span class="line">        cls.GetDescriptor.__doc__ = <span class="string">"Returns the service descriptor."</span></span><br><span class="line">        cls.GetRequestClass = self._GetRequestClass</span><br><span class="line">        cls.GetResponseClass = self._GetResponseClass</span><br><span class="line">        <span class="keyword">for</span> method <span class="keyword">in</span> self.descriptor.methods:</span><br><span class="line">            setattr(cls, method.name, self._GenerateNonImplementedMethod(method))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_CallMethod</span><span class="params">(self, srvc, method_descriptor,</span><br><span class="line">                    rpc_controller, request, callback)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> method_descriptor.containing_service != self.descriptor:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                <span class="string">'CallMethod() given method descriptor for wrong service type.'</span>)</span><br><span class="line">        method = getattr(srvc, method_descriptor.name)</span><br><span class="line">        <span class="keyword">return</span> method(rpc_controller, request, callback)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_GetRequestClass</span><span class="params">(self, method_descriptor)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> method_descriptor.containing_service != self.descriptor:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                <span class="string">'GetRequestClass() given method descriptor for wrong service type.'</span>)</span><br><span class="line">        <span class="keyword">return</span> method_descriptor.input_type._concrete_class</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_GetResponseClass</span><span class="params">(self, method_descriptor)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> method_descriptor.containing_service != self.descriptor:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                <span class="string">'GetResponseClass() given method descriptor for wrong service type.'</span>)</span><br><span class="line">        <span class="keyword">return</span> method_descriptor.output_type._concrete_class</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_GenerateNonImplementedMethod</span><span class="params">(self, method)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> inst, rpc_controller, request, callback: (</span><br><span class="line">            self._NonImplementedMethod(method.name, rpc_controller, callback))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_NonImplementedMethod</span><span class="params">(self, method_name, rpc_controller, callback)</span>:</span></span><br><span class="line">        rpc_controller.SetFailed(<span class="string">'Method %s not implemented.'</span> % method_name)</span><br><span class="line">        callback(<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<p><code>BuildService</code>函数主要做了两件事情：</p>
<ol>
<li><p>将自身的<code>_CallMethod</code>、<code>_GetRequestClass</code>、<code>_GetResponseClass</code>等公用方法的引用赋给新生成的类。其内部有一个<code>_WrapCallMethod</code>的嵌套函数，该嵌套函数存在的目的只是为了在使用<code>Service</code>实例对象进行方法调用<code>CallMethod</code>的时候可以把自身作为<code>srvc</code>参数传递给<code>_CallMethod</code>方法。</p>
</li>
<li><p>将我们在proto中定义的<code>service</code>的RPC调用接口通过<code>setattr</code>“注入”到类的定义中。</p>
</li>
</ol>
<p>这里尤其需要注意的是<code>_CallMethod</code>方法，可以看到这个方法主要的作用是讲传入的<code>method_descriptor</code>转化解析成为对<code>srvc</code>中相应方法的调用。因此，只要我们可以通过反序列化从通信的数据流中解析出RPC调用的<code>MethodDescriptor</code>，即可直接利用<code>_CallMethod</code>方法调用到相应的服务。这一点正是被调用端抽象接口需要实现的关键部分。</p>
<p>而调用端的<strong><code>GeneratedServiceStubType</code></strong>结构也是类似的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratedServiceStubType</span><span class="params">(GeneratedServiceType)</span>:</span></span><br><span class="line"></span><br><span class="line">    _DESCRIPTOR_KEY = <span class="string">'DESCRIPTOR'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dictionary)</span>:</span></span><br><span class="line">        super(GeneratedServiceStubType, cls).__init__(name, bases, dictionary)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> GeneratedServiceStubType._DESCRIPTOR_KEY <span class="keyword">not</span> <span class="keyword">in</span> dictionary:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        descriptor = dictionary[GeneratedServiceStubType._DESCRIPTOR_KEY]</span><br><span class="line">        service_stub_builder = _ServiceStubBuilder(descriptor)</span><br><span class="line">        service_stub_builder.BuildServiceStub(cls)</span><br></pre></td></tr></table></figure>
<p><code>GeneratedServiceStubType</code>不仅包含了<code>GeneratedServiceType</code>对类对象的全部定义，还在此基础上通过<code>_ServiceStubBuilder</code>增加了<code>stub</code>所特有的属性。<code>_ServiceStubBuilder</code>的实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ServiceStubBuilder</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, service_descriptor)</span>:</span></span><br><span class="line">        self.descriptor = service_descriptor</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BuildServiceStub</span><span class="params">(self, cls)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_ServiceStubInit</span><span class="params">(stub, rpc_channel)</span>:</span></span><br><span class="line">            stub.rpc_channel = rpc_channel</span><br><span class="line">        self.cls = cls</span><br><span class="line">        cls.__init__ = _ServiceStubInit</span><br><span class="line">        <span class="keyword">for</span> method <span class="keyword">in</span> self.descriptor.methods:</span><br><span class="line">            setattr(cls, method.name, self._GenerateStubMethod(method))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_GenerateStubMethod</span><span class="params">(self, method)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">lambda</span> inst, rpc_controller, request, callback=<span class="keyword">None</span>:</span><br><span class="line">            self._StubMethod(inst, method, rpc_controller, request, callback))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_StubMethod</span><span class="params">(self, stub, method_descriptor,</span><br><span class="line">                    rpc_controller, request, callback)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> stub.rpc_channel.CallMethod(</span><br><span class="line">            method_descriptor, rpc_controller, request,</span><br><span class="line">            method_descriptor.output_type._concrete_class, callback)</span><br></pre></td></tr></table></figure>
<p>其主要作用是实现对<code>RpcChannel</code>的包裹，从而将远端的RPC调用伪装成一个本地调用。这段代码里比较关键的两步：</p>
<ol>
<li><code>_GenerateStubMethod</code>生成的包裹方法将所有对<code>stub</code>方法的调用统一转换为对<code>_StubMethod</code>方法的调用，同时还将对具体方法的调用转化为了传入一个<code>MethodDescriptor</code>，使得后续进行通信的时候可以将调用行为序列化。</li>
<li><code>_StubMethod</code>方法则进一步将方法的调用传递给了<code>RpcChannel.CallMethod</code>，从而可以通过<code>RpcChannel</code>将调用行为通过通信管道传递出去。也就是说，调用端抽象接口实现主要需要关注的是<code>RpcChannel.CallMethod</code>如何处理调用行为以及参数的序列化以及数据的传递。</li>
</ol>
<p>既然如此，我们就来继续看一下<code>RpcChannel</code>的定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RpcChannel</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CallMethod</span><span class="params">(self, method_descriptor, rpc_controller,</span><br><span class="line">                   request, response_class, done)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure>
<p>RpcChannel接口非常简单明了，就是一个有待我们实现的<code>CallMethod</code>方法。回想一下<code>GeneratedServiceType</code>为我们的<code>Service</code>会添加一个非常相似的<code>CallMethod</code>方法。区别只在于被调用端的<code>CallMethod</code>会直接通过返回值传回<code>response</code>，而这里通过函数参数指定<code>response</code>的类型。所以，只要讲调用端的<code>CallMethod</code>和被调用端的<code>CallMethod</code>通过通信管道链接在一起，即可完成一个RPC过程！</p>
<p>目前为止，我们还遗漏了一项：<code>RpcController</code>。这个类主要是为了我们可以捕获RPC调用过程中的一些异常情况，并提供了一些额外的控制。具体实现方式因人而异，其定义也非常简单，仅仅是提供了一些基本的函数接口。这里不再赘述，具体要实现的内容可参看<em>protobuf Python API</em> <code>service.py</code>文件中<code>RpcController</code>代码的注释。</p>
<p>到目前为止，我们掌握的信息已经足以去利用<code>protobuf</code>具体实现一套PRC机制。在下一篇博文《Implement an Asynchronous RPC Basing on Protocol Buffers》中将基于本文的内容，具体说明如何构建一个可供RPC调用的<code>Echo Service</code>:)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>Google Protocol Buffers</em>是Google使用的数据交换格式，在RPC协议和文件存储等有广泛的应用。其基本使用方法就不在赘述，可以参看<em>protobuf</em>的项目主页：<a href="https://code.google.]]>
    </summary>
    
      <category term="Python" scheme="http://nightfade.github.io/tags/Python/"/>
    
      <category term="protobuf" scheme="http://nightfade.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python Meta-programming]]></title>
    <link href="http://nightfade.github.io/2013/12/12/python-meta-programming/"/>
    <id>http://nightfade.github.io/2013/12/12/python-meta-programming/</id>
    <published>2013-12-12T15:47:23.000Z</published>
    <updated>2016-01-18T08:03:09.000Z</updated>
    <content type="html"><![CDATA[<p>在实际工作中，Python的Meta-programming的使用其实是比较少的。另一方面使用这个语言特性很容易导致代码可维护性下降，所以应该是尽可能的避免使用的。</p>
<p>但是对于一些特殊的代码，例如目前正在研究的<em>Google Protocol Buffers</em>的Python API，由于其需要根据用户定义的proto文件生成特定的class，因此需要对class很强的定制能力。而这正是Meta-programming所擅长的事情。</p>
<p>Python的新式类可以通过通过两种方式在运行时修改类的定义，通过<code>__new__</code>方法，以及通过指定<code>__metaclass__</code>。protobuf主要使用的就是后者。本文参考《Expert Python Programming》中”Meta-programming”章节，对这两种方法分别进行说明。</p>
<h2 id="u4F7F_u7528__new___u65B9_u6CD5_u5728_u5B9E_u4F8B_u5316_u8FC7_u7A0B_u4E2D_u4FEE_u6539_u7C7B_u5B9A_u4E49"><a href="#u4F7F_u7528__new___u65B9_u6CD5_u5728_u5B9E_u4F8B_u5316_u8FC7_u7A0B_u4E2D_u4FEE_u6539_u7C7B_u5B9A_u4E49" class="headerlink" title="使用__new__方法在实例化过程中修改类定义"></a>使用<code>__new__</code>方法在实例化过程中修改类定义</h2><p><code>__new__</code>方法被称为<code>meta-constructor</code>，每个类在实例化过程中都会首先调用<code>__new__</code>方法得到对象实例，之后才会去调用可能存在的<code>__init__</code>方法。</p>
<p>一个简单的实验：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'__new__ called'</span></span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'__init__ called'</span></span><br><span class="line"></span><br><span class="line">instance = MyClass()</span><br></pre></td></tr></table></figure></p>
<p>运行这段脚本可以看到输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__new__ called</span><br><span class="line">__init__ called</span><br></pre></td></tr></table></figure>
<p>因此通过这种方式，我们可以通过重载<code>__new__</code>方法来更改一个类的实例化行为。一个典型的应用是通过重载<code>__new__</code>方法来实现单例模式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    _instance = <span class="keyword">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._instance:</span><br><span class="line">            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure>
<p>另外一些关键的初始化可以在<code>__new__</code>函数内进行。即使该类被继承，并且子类忘记调用基类的<code>__init__</code>方法，依然可以保证代码的正确运行，或者至少给出相应的提示。threading模块的Thread类就是用这种机制来避免未初始化的子类。</p>
<h2 id="u66F4_u52A0_u81EA_u7531_u7075_u6D3B_u7684__metaclass"><a href="#u66F4_u52A0_u81EA_u7531_u7075_u6D3B_u7684__metaclass" class="headerlink" title="更加自由灵活的__metaclass__"></a>更加自由灵活的<code>__metaclass__</code></h2><p>元类(<code>Metaclass</code>)，简单说来就是用来生成类的类。这里我们把<code>class</code>本身称作“类对象”，由“类对象”实例化得到的对象称作“实例对象”。在Python中，默认情况下所有的类对象都是<code>type</code>类的实例对象，即<code>type</code>类是所有<code>class</code>的<code>Metaclass</code>，甚至包括type类自身的<code>Metaclass</code>也是<code>type</code>类。</p>
<h3 id="Python_u7684type_u5173_u952E_u5B57"><a href="#Python_u7684type_u5173_u952E_u5B57" class="headerlink" title="Python的type关键字"></a>Python的<code>type</code>关键字</h3><p>Python中的<code>type</code>关键字是Python语言里少数违反单一性原则的特例之一：</p>
<ol>
<li>当使用单参数调用<code>type(instance)</code>的时候，<code>type</code>是一个函数，其作用是返回<code>instance</code>（实例对象）的<code>class</code>类型。</li>
<li>当使用三参数调用<code>type(classname, base_types, dict)</code>的时候，<code>type</code>是一个类，其作用是根据给定参数实例化出一个<code>class</code>（类对象）。</li>
</ol>
<p>前面说到所有<code>class</code>都是<code>type</code>类的实例，可以很容易的根据<code>type</code>的这两种用法通过代码来验证一下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#62;&#62;&#62; class A(object):&#10;...     pass&#10;... &#10;&#62;&#62;&#62; instance = A()&#10;&#62;&#62;&#62; type(instance)&#10;&#60;class &#39;__main__.A&#39;&#62;&#10;&#62;&#62;&#62; type(A)&#10;&#60;type &#39;type&#39;&#62;&#10;&#62;&#62;&#62; type(type)&#10;&#60;type &#39;type&#39;&#62;</span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528_u81EA_u5B9A_u4E49_u7684Metaclass_u751F_u6210_u7C7B_u5BF9_u8C61"><a href="#u4F7F_u7528_u81EA_u5B9A_u4E49_u7684Metaclass_u751F_u6210_u7C7B_u5BF9_u8C61" class="headerlink" title="使用自定义的Metaclass生成类对象"></a>使用自定义的<code>Metaclass</code>生成类对象</h3><p>想要使用自定义的<code>Metaclass</code>生成类对象，首先弄清楚Python默认的<code>type</code>是如何作为<code>Metaclass</code>生成类对象的。其实根据前面<code>type</code>的第二种用法，你应该也已经猜到大概了，我们只需要给定所需要生成的<code>class</code>的名字、基类以及相应的属性和方法，就可以由<code>type</code>实例化出我们所要的类对象。也就是说，如下两段代码可以看做是等价的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MyClass = type(<span class="string">'MyClass'</span>, (object,), &#123;<span class="string">'method'</span>: method&#125;)</span><br><span class="line"></span><br><span class="line">instance = MyClass()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">instance = MyClass()</span><br></pre></td></tr></table></figure>
<p>Python为指定类的自定义<code>Metaclass</code>提供了更加便捷的语法<code>__metaclass__</code>，其具体使用方式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = MyMetaClass</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_method</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>其中，自定义的<code>Metaclass</code>(<code>MyMetaClass</code>)只需要满足的如下两个条件（只要满足这些条件即可，自定义的<code>Metaclass</code>不必一定是一个类）：</p>
<ol>
<li>可以接受与<code>type</code>相同的参数列表，也就是类名、基类的元组以及属性的字典。</li>
<li>返回一个类对象。</li>
</ol>
<p>借用《Expert Python Programming》上一个例子来简单说明<code>__metaclass__</code>的用法，这里为没有指定<code>docstring</code>的类在生成阶段指定一个默认的<code>docstring</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">type_with_default_doc</span><span class="params">(classname, base_types, dict)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'__doc__'</span> <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">        dict[<span class="string">'__doc__'</span>] = <span class="string">'default doc'</span></span><br><span class="line">    <span class="keyword">return</span> type(classname, base_types, dict)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassWithDoc</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = type_with_default_doc</span><br></pre></td></tr></table></figure>
<p><code>__metaclass__</code>的用法其实就是这样，相对来说还是比较简单的。但是正如开篇提到的那样，在不是非常必要的时候，还是应该尽量避免使用这样的语言特性，因为使用过多<code>Metaclass</code>的项目必然是很难维护的。</p>
<p>而本文的目的，主要还是为剖析<em>Google Protocol Buffers</em>的Python API的实现做铺垫。其内部主要就是使用<code>__metaclass__</code>机制来生成由proto文件定义的结构体和service。这部分内容会在后续的博文中进行更详细的阐述：）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在实际工作中，Python的Meta-programming的使用其实是比较少的。另一方面使用这个语言特性很容易导致代码可维护性下降，所以应该是尽可能的避免使用的。</p>
<p>但是对于一些特殊的代码，例如目前正在研究的<em>Google Protocol Buffer]]>
    </summary>
    
      <category term="Python" scheme="http://nightfade.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Building Cross-platform Project Using CMake]]></title>
    <link href="http://nightfade.github.io/2013/12/07/building-cross-platform-project-using-cmake/"/>
    <id>http://nightfade.github.io/2013/12/07/building-cross-platform-project-using-cmake/</id>
    <published>2013-12-07T12:01:32.000Z</published>
    <updated>2016-01-18T08:02:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Why_CMake"><a href="#Why_CMake" class="headerlink" title="Why CMake"></a>Why CMake</h2><p>第一次在使用CMake作为项目的构建工具还是在实验室写Structure from Motion系统的时候。一方面是因为要求程序可以在Windows和Linux下都能够编译，另外一个重要原因还是因为实在厌倦了不断的手工去改VS工程文件的各种选项。</p>
<p>在此之前，在有道的做OCR系统的时候也使用过SCons。当时主要考虑的还是因为SCons是使用Python作为脚本，不需要额外的再去学习一门语言。如果项目仅仅需要在Linux下进行编译，那么SCons是一个不错的选择。但是在跨平台方面，和CMake差距还是比较大的。而目前使用CMake的大型项目也有很多，足够证明CMake的可用性：KDE、MySQL、Second Life、OpenCV等。</p>
<p>列举一下CMake的众多优点：</p>
<ol>
<li>仅仅需要一套Build文本配置文件（CMakeLists.txt），就可以在所有平台进行项目构建。不再需要为每一个平台都维护一份项目文件。</li>
<li>可以根据CMakeLists直接生成Native的项目文件（Visual Studio、XCode、CodeBlocks、Makefile、Eclipse、KDevelop等）。这就意味着我们在享有使用纯文本配置项目构建的便利同时还可以继续使用IDE来编写代码。对于iOS等必须通过XCode对程序进行签名才能完成构建的项目，更是巨大的便利。</li>
<li>自动推断源代码文件之间的依赖关系，并且在大多数平台上支持并行编译。</li>
<li>具有编译时的配置的能力，对于有众多可选组件的项目来说，可以很容易的让用户配置自己所需的组件。</li>
<li>具有众多内置的功能，诸如自动搜索系统中已经安装的依赖库、头文件，自动检测平台特性等。</li>
<li>可以在source tree以外进行项目的构建，始终保持source tree的干净。对于有代码洁癖的coder来说，这一点也同样至关重要。</li>
</ol>
<h2 id="Building_Project_Using_CMake"><a href="#Building_Project_Using_CMake" class="headerlink" title="Building Project Using CMake"></a>Building Project Using CMake</h2><p>以下内容大多参考《Mastering CMake》，以尽可能短的篇幅说明如何编写CMake脚本文件。CMake的安装和执行就不再赘述，可参看官方说明<a href="http://www.cmake.org/cmake/help/install.html" target="_blank" rel="external">Installing CMake</a>以及<a href="http://www.cmake.org/cmake/help/runningcmake.html" target="_blank" rel="external">Running CMake</a>。</p>
<h3 id="Basic_CMake_Usage_and_Syntax"><a href="#Basic_CMake_Usage_and_Syntax" class="headerlink" title="Basic CMake Usage and Syntax"></a>Basic CMake Usage and Syntax</h3><p>类似于传统的Makefile，CMake使用项目目录下的一个或多个CMakeLists文件来控制构建过程。CMakeLists文件包含了控制构建过程的一系列命令，这些命令具有以下形式：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command (args...)</span><br></pre></td></tr></table></figure>
<p>command是命令的名称，args是空格分隔的参数列表。CMake对命令名字大小写不敏感。</p>
<p>一个虽然简短但是包含了诸如平台相关源码、搜索依赖库以及链接的CMakeLists样例如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (<span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(HELLO)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> (HELLO_SRCS Hello.c File2.c File3.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WIN32)</span><br><span class="line">    <span class="keyword">set</span> (HELLO_SRCS <span class="envvar">$&#123;HELLO_SRCS&#125;</span> WinSupport.c)</span><br><span class="line"><span class="keyword">else</span> ()</span><br><span class="line">    <span class="keyword">set</span> (HELLO_SRCS <span class="envvar">$&#123;HELLO_SRCS&#125;</span> UnixSupport.c)</span><br><span class="line"><span class="keyword">endif</span> ()</span><br><span class="line"></span><br><span class="line"><span class="comment"># look for the Tcl library</span></span><br><span class="line"><span class="keyword">find_library</span> (TCL_LIBRARY</span><br><span class="line">    NAMES tcl tcl84 tcl83 tcl82 tcl80</span><br><span class="line">    PATHS /usr/lib /usr/local/lib</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TCL_LIBRARY)</span><br><span class="line">    target_link_library (Hello <span class="envvar">$&#123;TCL_LIBRARY&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<p>CMake中各单位的基本关系：</p>
<ol>
<li>若干源码文件构成一个<code>target</code>，一个<code>target</code>通常是一个可执行文件或库。</li>
<li>一个directory表示source tree中包含一个CMakeLists文件的目录，并且有一个或多个target与之关联。</li>
<li>每个目录有一个local generator负责生成这个目录下的Makefile或者工程文件。</li>
</ol>
<h4 id="u57FA_u672C_u7684COMMAND"><a href="#u57FA_u672C_u7684COMMAND" class="headerlink" title="基本的COMMAND"></a>基本的COMMAND</h4><p>0. 在CMakeLists.txt首部增加对CMake的最低版本要求：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimun_required (VERSION <span class="number">2.6</span>)</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>1. 定义工程名：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span> (MyProject [CXX] [C] [JAVA]) <span class="comment"># 默认支持以上所有语言</span></span><br></pre></td></tr></table></figure>
<p>定义工程名通常是项目的顶级目录下的CMakeLists.txt的第一条命令。对于每一个<code>project</code>命令，CMake会创建一个对应的顶层IDE工程文件，其包含了该CMakeLists种定义的所有Target以及该文件中所有使用<code>add_subdirectory</code>指定的子目录中定义的Target。</p>
<p>2. 加入子目录：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(SOURCE_DIR [BINARY_DIR] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure>
<p>生成子目录下的模块或程序并放在build的相应子目录下，如果指定了EXCLUDE_FROM_ALL选项，那么该目录下生成的工程将不会出现在顶层的Makefile或工程文件里。这对于将很多sample作为子项目的工程来说是很有意义的。</p>
<p>3. 设置变量：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> (VARIABLE_NAME value1 [value2 ...])</span><br></pre></td></tr></table></figure>
<p>这里定义的变量是一个由空格分隔的参数列表。set的变量会在当前文件以及add_subdirectory所有子目录下的CMakeLists中生效。但是任何子域下set的变量不会影响父域。</p>
<p>4. 输出提示信息：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span> ([SEND_ERROR | STATUS | FATAL_ERROR] <span class="string">"message"</span>)</span><br></pre></td></tr></table></figure>
<p>5. 定义可执行对象target：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span> (MyExe <span class="envvar">$&#123;SRC_FILES&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>6. 定义静态库、动态库target：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span> (MyLib [SHARED | STATIC | MODULE] <span class="string">"$&#123;SRC_FILES&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>7. 增加INCLUDE目录：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span> (<span class="string">"$&#123;PROJECT_BINARY_DIR&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>8. 增加link的库目录：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_directories</span> (<span class="string">"$&#123;PROJECT_BINARY_DIR&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>9. 为target增加链接对象:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span> (MyExe <span class="string">"$&#123;LIB_NAMES&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>10. 增加项目依赖：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_dependencies</span> (target-name depend-target1 depend-target2)</span><br></pre></td></tr></table></figure>
<p>定义target依赖其他target，保证在编译本target之前，其他target已经被构建。</p>
<h4 id="u5185_u7F6E_u53D8_u91CF"><a href="#u5185_u7F6E_u53D8_u91CF" class="headerlink" title="内置变量"></a>内置变量</h4><p>CMAKE提供了一些内置变量，通过读取或设置这些变量的值可以控制编译：</p>
<p>1. 指定二进制目标的保存位置：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定编译的可执行文件输出到项目build目录下的bin文件夹</span></span><br><span class="line"><span class="keyword">set</span> (EXECUTABLE_OUTPUT_PATH <span class="envvar">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定编译的库文件输出到项目build目录下的lib文件夹</span></span><br><span class="line"><span class="keyword">set</span> (LIBRARY_OUTPUT_PATH <span class="envvar">$&#123;PROJECT_BINARY_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure>
<p>无论是否在ADD_SUBDIRECTORY中制定了编译输出目录，都可以指定最终二进制的位置。</p>
<p>2. CMake中系统信息的内置变量：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CMAKE_SYSTEM		<span class="comment"># 系统名称，比如Linux-2.6.22</span></span><br><span class="line"></span><br><span class="line">CMAKE_SYSTEM_NAME	<span class="comment"># 不包含版本的系统名，比如Linux</span></span><br><span class="line"></span><br><span class="line">APPLE				<span class="comment"># Mac OS X上返回TRUE</span></span><br><span class="line"></span><br><span class="line">UNIX				<span class="comment"># 所有的类UNIX平台上为TRUE，包括OS X和cygwin</span></span><br><span class="line"></span><br><span class="line">WIN32				<span class="comment"># 所有win32平台上为TRUE，包括cygwin</span></span><br><span class="line"></span><br><span class="line">CYGWIN				<span class="comment"># cygwin下返回TRUE</span></span><br><span class="line"></span><br><span class="line">MSVC				<span class="comment"># 使用 Microsoft Visual C 时返回TRUE</span></span><br></pre></td></tr></table></figure>
<p>3. 其他常用变量</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CMAKE_BINARY_DIR &amp; PROJECT_BINARY_DIR	<span class="comment"># 执行cmake的目录。</span></span><br><span class="line"></span><br><span class="line">CMAKE_SOURCE_DIR $ PROJECT_SOURCE_DIR	<span class="comment"># 工程顶层目录</span></span><br><span class="line"></span><br><span class="line">CMAKE_CURRENT_SOURCE_DIR				<span class="comment"># 当前处理的CMakeLists.txt的所在路径</span></span><br><span class="line"></span><br><span class="line">CMAKE_CURRENT_BINARY_DIR				<span class="comment"># 当前处理的CMakeLists.txt的输出路径</span></span><br></pre></td></tr></table></figure>
<h4 id="u6D41_u7A0B_u63A7_u5236"><a href="#u6D41_u7A0B_u63A7_u5236" class="headerlink" title="流程控制"></a>流程控制</h4><p>CMake提供了三种流程控制命令：</p>
<p>1. 条件指令（if）</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FOO)</span><br><span class="line">	<span class="comment"># do something</span></span><br><span class="line"><span class="keyword">else</span> ()</span><br><span class="line">	<span class="comment"># do something</span></span><br><span class="line"><span class="keyword">endif</span> ()</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MSVC80)</span><br><span class="line">	<span class="comment"># do something</span></span><br><span class="line"><span class="keyword">elseif</span> (MSVC90)</span><br><span class="line">	<span class="comment"># do something</span></span><br><span class="line"><span class="keyword">elseif</span> (APPLE)</span><br><span class="line">	<span class="comment"># do something</span></span><br><span class="line"><span class="keyword">endif</span> ()</span><br></pre></td></tr></table></figure>
<p>其中<code>if</code>可支持的形式有：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (variable)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (NOT variable)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (variable1 <span class="keyword">AND</span> variable2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (variable1 <span class="keyword">OR</span> variable2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EXISTS file-name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EXISTS directory-name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_DIRECTORY name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ABSOLUTE name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (name1 IS_NEWER_THAN name2)</span><br><span class="line"></span><br><span class="line"><span class="operator">EQUAL</span>, <span class="operator">LESS</span>, <span class="operator">GREATER</span> <span class="comment"># 数值比较</span></span><br><span class="line"><span class="operator">STRLESS</span>, <span class="operator">STREQUAL</span>, STRGEATER <span class="comment"># ZIFUCHUAN BIJIAO</span></span><br></pre></td></tr></table></figure></p>
<p>2. 循环结构（foreach &amp; while）</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (tfile</span><br><span class="line">		file1</span><br><span class="line">		file2</span><br><span class="line">		file3)</span><br><span class="line">	<span class="comment"># do something with tfile</span></span><br><span class="line"><span class="keyword">endforeach</span> (tfile)</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="envvar">$&#123;var&#125;</span> <span class="operator">LESS</span> <span class="number">3600</span>)</span><br><span class="line">	<span class="comment"># do something</span></span><br><span class="line"><span class="keyword">endwhile</span> ()</span><br></pre></td></tr></table></figure>
<p>3. 过程定义 (macro &amp; function)</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (FunctionName param)</span><br><span class="line">	<span class="comment"># do something with $&#123;param&#125;</span></span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line">FunctionName(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>
<p>macro和function的使用方法一样，但是macro不涉及变量作用于的变化。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span> (assert TEST COMMENT)</span><br><span class="line">	<span class="comment"># do something</span></span><br><span class="line"><span class="keyword">endmacro</span> (assert)</span><br><span class="line"></span><br><span class="line">FunctionName(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528Modules"><a href="#u4F7F_u7528Modules" class="headerlink" title="使用Modules"></a>使用Modules</h3><p>Module就是放在一个单独文件中的一段CMake命令。可以通过<code>include</code>命令来使用：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> (FindTCL)</span><br><span class="line"></span><br><span class="line">target_link_library (FOO <span class="envvar">$&#123;TCL_LIBRARY&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>CMake内置了大量的Module，可以很方便的定位已安装的库或头文件或查看系统属性。具体的Module项目以及用法可以查看cmake安装目录下的Module目录。</p>
<p>Find<xx>.cmake模块通常的规则是：</xx></p>
<pre><code>&lt;XX&gt;_INCLUDE_DIRS: 头文件目录

&lt;XX&gt;_LIBRARIES: LINK目录

&lt;XX&gt;_DEFINITIONS: 编译该库需要使用的预处理define

&lt;XX&gt;_FOUND: 是否找到
</code></pre><h3 id="u901A_u8FC7find_path_uFF0Cfind_library_u547D_u4EE4_u81EA_u5DF1_u6307_u5B9A_u76EE_u5F55_u8FDB_u884C_u641C_u7D22"><a href="#u901A_u8FC7find_path_uFF0Cfind_library_u547D_u4EE4_u81EA_u5DF1_u6307_u5B9A_u76EE_u5F55_u8FDB_u884C_u641C_u7D22" class="headerlink" title="通过find_path，find_library命令自己指定目录进行搜索"></a>通过<code>find_path</code>，<code>find_library</code>命令自己指定目录进行搜索</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_library</span> (TIFF_LIBRARY</span><br><span class="line">			  NAMES tiff tiff2</span><br><span class="line">			  PATHS /usr/local/lib /usr/lib)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_path</span> (TIFF_INCLUDES tiff.h</span><br><span class="line">		   /usr/local/<span class="keyword">include</span></span><br><span class="line">		   /usr/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span> (<span class="envvar">$&#123;TIFF_INCLUDES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (mytiff mytiff.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span> (mytiff <span class="envvar">$&#123;TIFF_LIBRARY&#125;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="u4E3A_u7F16_u8BD1_u5668_u4F20_u9012_u7F16_u8BD1_u9009_u9879"><a href="#u4E3A_u7F16_u8BD1_u5668_u4F20_u9012_u7F16_u8BD1_u9009_u9879" class="headerlink" title="为编译器传递编译选项"></a>为编译器传递编译选项</h3><p>1. 使用<code>add_definitions</code>为编译器增加预处理define：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> (DEBUG_BUILD <span class="string">"Build with extra debug message"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (DEBUG_BUILD)</span><br><span class="line">	<span class="keyword">add_definitions</span> (-DDEBUG_BUILD)</span><br><span class="line"><span class="keyword">endif</span> ()</span><br></pre></td></tr></table></figure>
<p>2. 为单个的目录，target，或源代码指定编译选项：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_property</span> (</span><br><span class="line">	DIRECTORY	<span class="comment"># 当前目录及子目录</span></span><br><span class="line">	PROPERTY COMPILE_DEFINITIONS A AV=<span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_property</span> (</span><br><span class="line">	TARGET mylib</span><br><span class="line">	PROPERTY COMPILE_DEFINITONS B BV=<span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_property</span> (</span><br><span class="line">	SOURCE src1.c</span><br><span class="line">	PROPERTY COMPILE_DEFINITIONS C CV=<span class="number">3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="u6587_u4EF6_u64CD_u4F5C"><a href="#u6587_u4EF6_u64CD_u4F5C" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">file (WRITE filename <span class="string">"message to write"</span>)</span><br><span class="line"></span><br><span class="line">file (APPEND filename <span class="string">"message to write"</span>)</span><br><span class="line"></span><br><span class="line">file (READ filename variable)</span><br><span class="line"></span><br><span class="line">file (GLOB variable [RELATIVE PATH] [GLOBBING EXPRESSIONS])</span><br><span class="line"></span><br><span class="line">file (GLOB_RECURSE variable [RELATIVE PATH] [GLOBBING EXPRESSIONS])</span><br><span class="line"></span><br><span class="line">file (<span class="keyword">REMOVE</span> [DIRECTORY])</span><br><span class="line"></span><br><span class="line">file (REMOVE_RECURSE [DIRECTORY])</span><br><span class="line"></span><br><span class="line">file (<span class="keyword">MAKE_DIRECTORY</span> [DIRECTORY])</span><br></pre></td></tr></table></figure>
<h3 id="u5176_u4ED6"><a href="#u5176_u4ED6" class="headerlink" title="其他"></a>其他</h3><p>至此，CMAKE的基本用法基本阐述完毕。然而，这次重新捡起CMake的主要目的还是在于希望用CMake进行cocos2d-x的跨平台构建。这就涉及到如何使用CMake进行交叉编译。这部分内容我会在下一篇博文中进行阐述。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Why_CMake"><a href="#Why_CMake" class="headerlink" title="Why CMake"></a>Why CMake</h2><p>第一次在使用CMake作为项目的构建工具还是在实验室写Structure from ]]>
    </summary>
    
      <category term="CMake" scheme="http://nightfade.github.io/tags/CMake/"/>
    
      <category term="Tools" scheme="http://nightfade.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Notes on Protected Mode]]></title>
    <link href="http://nightfade.github.io/2013/12/07/notes-on-protected-mode/"/>
    <id>http://nightfade.github.io/2013/12/07/notes-on-protected-mode/</id>
    <published>2013-12-07T03:13:54.000Z</published>
    <updated>2016-01-18T08:03:05.000Z</updated>
    <content type="html"><![CDATA[<p>在IA32下，CPU有两种工作模式：实模式和保护模式。两种模式都使用<code>Segment:Offset</code>的方式进行寻址。但是两种模式下，段和偏移的含义是完全不一样的。</p>
<h3 id="u5B9E_u6A21_u5F0F"><a href="#u5B9E_u6A21_u5F0F" class="headerlink" title="实模式"></a>实模式</h3><p>计算机启动之后首先进入实模式。在实模式下遵循<code>Intel8086</code>的16位CPU模式，具有16位寄存器，16位数据总线，<em>20位地址总线</em>。<strong>物理地址</strong>遵循如下计算公式：</p>
<pre><code>Physical_Address = Segment &lt;&lt; 4 + Offset
</code></pre><h3 id="u4FDD_u62A4_u6A21_u5F0F"><a href="#u4FDD_u62A4_u6A21_u5F0F" class="headerlink" title="保护模式"></a>保护模式</h3><p>保护模式工作在<code>Intel80386</code>之后的CPU上。在保护模式下我们有32位地址线，和32位寄存器，单纯使用一个寄存器就可以寻址4GB的空间。但是在保护模式下，寻址方式依然采用<code>Segment:Offset</code>的方式，但是此时的段和偏移的含义与实模式是完全不同的。<em>此时的段和偏移仅仅作为索引指向内存中的一个数据结构的一个表项</em>。这个数据结构称为<strong>GDT(Global Descriptor Table)</strong>。GDT可为系统提供<em>段式存储机制</em>。</p>
<p>以下是《Orange’s 一个操作系统的实现》中一个GDT表的样例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; usage: Descriptor Base, Limit, Attr&#10;;&#9;&#9; Base: dd&#10;;&#9;&#9; Limit: dd (low 20 bits available)&#10;;&#9;&#9; Attr: dw&#10;%macro Descriptor 3&#10;&#9;dw&#9;%2&#9;&#38;&#9;0FFFFh&#10;&#9;dw&#9;%1&#9;&#38;&#9;0FFFFh&#10;&#9;db&#9;(%1&#9;&#62;&#62; 16) &#38; 0FFh&#10;&#9;dw&#9;((%2 &#62;&#62; 8) &#38; 0F00h) | (%3 &#38; 0F0FFh)&#10;&#9;db&#9;(%1&#9;&#62;&#62; 24) &#38; 0FFh&#10;%endmacro&#10;&#10;[Section .gdt]&#10;&#10;LABEL_GDT:         Descriptor        0,                 0,            0&#10;LABEL_DESC_CODE32: Descriptor        0,  SegCode32Len - 1, DA_C + DA_32&#10;LABEL_DESC_VIDEO:  Descriptor  0B8000h,            0ffffh,       DA_DRW&#10;&#10;GdtLen  equ&#9;$ - LABEL_GDT&#10;GdtPtr  dw  GdtLen - 1&#10;           dd  0&#10;&#10;SelectorCode32&#9;equ&#9;LABEL_DESC_CODE32&#9;- LABEL_GDT&#10;SelectorVideo&#9;equ&#9;LABEL_DESC_VIDEO&#9;- LABEL_GDT&#10;; END of [SECTION .gdt]</span><br></pre></td></tr></table></figure>
<p>概括来说，GDT的每个表项用三部分内容描述一个段：段基址，段界限，段属性。</p>
<p><code>GdtPtr</code>的48位内存用来指向GDT，其结构为：<code>[32位基地址|16位界限]</code>。可通过指令<code>lgdt [GdtPtr]</code>加载到48位寄存器<code>gdtr</code>。</p>
<p>代码中<code>Selector*</code>称作选择子，当选择子低位的TI位是0的时候可以简单看做是表项在GDT中的偏移索引，后续可以被加载到段寄存器中，与<code>gdtr</code>寄存器中得GDT基址一起来定位一个段。否则就是LDT中的一个表项。</p>
<p>此时<code>Segment:Offset</code>构成一个<strong>逻辑地址</strong>。段机制将逻辑地址（Logical Address）转化成线性地址（Linear Address）的基本过程如下：</p>
<ol>
<li>首先由段寄存器中存储的Segment(也是就一个Seletor)与<code>gdtr</code>存储的GDT表项的基址定位到GDT中的段表项.</li>
<li>之后由该表项中的段基址与Offset定位到线性地址空间。</li>
</ol>
<h3 id="u6A21_u5F0F_u5207_u6362"><a href="#u6A21_u5F0F_u5207_u6362" class="headerlink" title="模式切换"></a>模式切换</h3><p>从实模式切换到保护模式，有两个关键的位需要设置。</p>
<ol>
<li><p>设置A20地址线位：8086下只有20位地址线，如果试图访问超过1M的地址，则会对地址进行回卷。80286之后可以访问到得地址空间更大，但是为了兼容8086，则用A20地址位来控制访问超过1M的地址空间时是否对地址进行回卷。</p>
</li>
<li><p><code>cr0</code>寄存器的第0位。当该位为0时，CPU工作在实模式，否则工作在保护模式。保护模式下，所有寻址相关的指令，都使用<em>逻辑地址</em>的寻址方式，而不再是实模式下的<em>物理地址</em>的寻址方式。</p>
</li>
</ol>
<h3 id="u63CF_u8FF0_u7B26_u5C5E_u6027"><a href="#u63CF_u8FF0_u7B26_u5C5E_u6027" class="headerlink" title="描述符属性"></a>描述符属性</h3><p>在GDT表项中，每一个段描述符都有其属性描述位，保护模式也正是依赖这些属性实现操作系统的代码权限的保护及内存管理。例如：</p>
<ul>
<li>P位（Present）表示该段是否在内存中存在。</li>
<li>DPL特权级（Descriptor Privilege Level）描述了该段代码的特权级别。</li>
<li>S位指明描述符是数据段/代码段，还是系统段/门描述符。</li>
<li>TYPE描述了该段的类型（读写，只读，只执行，一致代码段等）。</li>
</ul>
<p>转移到一致代码段的时候，当前的特权级会延续下去。通过<code>call</code>或<code>jmp</code>指令在不同特权级代码段之间跳转的规则如下：</p>
<table><br>    <tr> <td>【目标代码段】</td> <td>【低→高】</td> <td>【高→低】</td> <td>【相同特权级】</td> <td>【适用何种代码】</td> </tr><br>    <tr> <td>一致代码段</td> <td>YES</td> <td>NO</td> <td>YES</td> <td>不访问受保护的资源的系统代码</td> </tr><br>    <tr> <td>非一致代码段</td> <td>NO</td> <td>NO</td> <td>YES</td> <td>避免低特权程序访问的系统代码</td> </tr><br>    <tr> <td>数据段（总是非一致）</td> <td>NO</td> <td>YES</td> <td>YES</td> <td>-</td> </tr><br></table>


<h3 id="u95E8_u63CF_u8FF0_u7B26"><a href="#u95E8_u63CF_u8FF0_u7B26" class="headerlink" title="门描述符"></a>门描述符</h3><p>门描述符描述了一个由一个选择子和一个偏移地址所指定的线性地址，程序可以通过这个地址进行转移。通过调用门可以实现从第特权级到高特权级的转移，无论代码段是一致的还是非一致的。</p>
<p>假设代码A通过一个调用门G转移到代码B，即调用门G中的目标选择子指向代码B的段。需要涉及到：CPL、RPL、代码B的DPL_B、调用门G的DPL_G。</p>
<ol>
<li>当A访问G的调用门时，规则相当于访问一个数据段，要求CPL和RPL特权级都不低于DPL_G。</li>
<li>系统还比较CPL和DPL_B，如果是一致代码段，则要求DPL_B特权级不低于CPL；如果是非一致特权级，调用<code>call</code>指令要求DPL_B特权级不低于CPL，调用<code>jmp</code>指令要求DPL_B特权级与CPL相同。</li>
</ol>
<p>注意对比描述符属性中直接跳转的权限规则。会发现这里可以由低权限代码跳转到高权限的非一致代码段，而直接跳转是不允许的。同时，调用门也只能实现特权级由低到高的转移。</p>
<h3 id="u7279_u6743_u7EA7_u89C4_u5219"><a href="#u7279_u6743_u7EA7_u89C4_u5219" class="headerlink" title="特权级规则"></a>特权级规则</h3><p>处理器通过CPL、DPL、RPL三种特权级进行特权级检验。</p>
<ol>
<li><strong>CPL(Current Privilege Level)</strong> CPL是当前执行的程序或任务的特权级，存储在<code>cs</code>和<code>ss</code>的第0位和第1位。通常情况下CPL等于代码段所在段的特权级，当程序转移到不同的特权级代码段时，处理器将改变CPL。<em>但是当跳转到一个一致代码段时，CPL不会改变。</em></li>
</ol>
<ol>
<li><p><strong>DPL(Descriptor Privilege Level)</strong> DPL表示段或门的特权级，存储在段或门的描述符字段中。当代码尝试访问一个段或者门时，DPL将与CPL或门选择子的RPL比较，以判断是否可以访问。</p>
</li>
<li><p><strong>RPL(Requested Privilege Level)</strong> RPL存储在选择子（一个段可以有多个选择子）的第0位和第1位。处理器通过检查RPL和CPL确认访问请求是否合法，在判断权限时，取RPL和CPL中权限最低的那个。</p>
</li>
</ol>
<p>程序从一个代码段转移到另外一个代码段之前，目标代码段的选择子会被加载到<code>cs</code>中。在加载过程中，处理器会检查描述符的界限、类型、特权级等内容。检验成功后<code>cs</code>才会被加载。</p>
<p>通过<code>jmp</code>或<code>call</code>可实现的四种转移：</p>
<ol>
<li>目标操作数包含目标代码段的段选择子。</li>
<li>目标操作数指向一个包含目标代码段的选择子的<strong>调用门描述符</strong>。</li>
<li>目标操作数指向一个包含目标代码段选择子的<strong>TSS(Task-State Stack)</strong>。</li>
<li>目标操作数指向一个<strong>任务门</strong>，这个任务门指向一个包含目标代码段选择子的TSS。</li>
</ol>
<h3 id="u7279_u6743_u7EA7_u8F6C_u79FB"><a href="#u7279_u6743_u7EA7_u8F6C_u79FB" class="headerlink" title="特权级转移"></a>特权级转移</h3><p>特权级转移的同时，堆栈也要随之变化，以避免高特权级的过程受到干扰。<code>jmp</code>指令仅仅涉及指令跳转，而<code>call</code>指令会影响堆栈。在段内跳转时，只要将参数和调用者的<code>eip</code>入栈即可。而段间跳转涉及到得还有cs的入栈，以及特权级变化的时候相应堆栈的切换。一个任务之多可以在4个特权级之间切换，因此需要4个堆栈，当特权级发生转移时，堆栈内的入栈参数会复制到目标特权级对应的堆栈中。</p>
<p><strong>TSS（Task-State Stack）</strong>是一个数据结构，可以记录一个任务不同特权级的<code>ss</code>和<code>esp</code>地址。</p>
<p>整个转移过程CPU所做的工作如下：</p>
<ol>
<li>根据目标代码段的DPL（新的CPL）从TSS中选择应该切换到哪个<code>ss</code>和<code>esp</code>。</li>
<li>从TSS中读取新的<code>ss</code>和<code>esp</code>，并检验是否越界等。</li>
<li>暂时保存当前<code>ss</code>和<code>esp</code>，并加载新<code>ss</code>和<code>esp</code>。</li>
<li>将刚刚保存起来的<code>ss</code>和<code>esp</code>压栈。</li>
<li>从调用者堆栈中将参数复制到被调用者的堆栈。</li>
<li>将当前<code>cs</code>和<code>eip</code>压栈。</li>
<li>加载调用门中指定的<code>cs</code>和<code>eip</code>，并开始执行被调用者过程。</li>
</ol>
<p>与<code>call</code>对应的<code>ret</code>过程也同样涉及相同的过程，CPU的工作包括：</p>
<ol>
<li>检查<strong>保存的<code>cs</code>中的RPL</strong>以判断返回时是否需要变换特权级。</li>
<li>加载被调用者堆栈上的<code>cs</code>和<code>eip</code>（此时会进行代码段描述符和选择子类型和特权级检验）。</li>
<li>如果ret指令含有参数，则增加<code>esp</code>的值以跳过参数。然后<code>esp</code>指向被保存过的调用者<code>ss</code>和<code>esp</code>。</li>
<li>加载<code>ss</code>和<code>esp</code>，切换到调用者堆栈。并检查ss描述符、ds、es、fs、gs等得值，如果某个寄存器指向的段的DPL小于CPL，则置空。</li>
</ol>
<h3 id="u9875_u5F0F_u5B58_u50A8"><a href="#u9875_u5F0F_u5B58_u50A8" class="headerlink" title="页式存储"></a>页式存储</h3><p>页式存储是由CPU的保护模式支持的。前面已经说到保护模式下，由<code>Segment:Offset</code>描述了逻辑地址，再经过段机制将其转换为线性地址。在未打开分页机制时，线性地址等同于物理地址。但是当分页开启时，线性地址要通过分页机制才能转化为物理地址。分页机制是否生效的开关位于<code>cr0</code>寄存器的PG位。</p>
<p>正如以往操作系统教材里描述的，使用两级页表来进行线性地址到物理地址的变换。第一级称作页目录其表项称为PDE(Page Directory Entry)；第二级为页表，其表项称为（Page Table Entry）。</p>
<p>进行转换时，首先由<code>cr3</code>指定的页目录中根据线性地址的高10位得到页表地址，之后在页表中根据线性地址的12到21位得到物理页首地址，将这个首地址加上线性地址的低12位便得到了物理地址。</p>
<p>利用CPU提供的页式存储机制，操作系统才能够为进程统一的提供<strong>互不干扰的线性地址</strong>，并且无需考虑物理内存在不同平台下得差异。在进程切换的时候，只需要更改<code>cr3</code>切换对应的页表即可。</p>
<h3 id="u4E2D_u65AD_u4E0E_u5F02_u5E38"><a href="#u4E2D_u65AD_u4E0E_u5F02_u5E38" class="headerlink" title="中断与异常"></a>中断与异常</h3><p>保护模式下的中断与实模式下也不同，实模式下得中断向量表和BIOS中断在保护模式下都不可用。保护模式下通过<strong>IDT(Interrupt Descriptor Table)</strong>实现中断调用。中断门和陷阱门都是特殊的调用门，作用机理几乎一样，只是由中断和异常触发而非<code>call</code>指令。</p>
<h3 id="u4FDD_u62A4_u6A21_u5F0F_u5C0F_u7ED3"><a href="#u4FDD_u62A4_u6A21_u5F0F_u5C0F_u7ED3" class="headerlink" title="保护模式小结"></a>保护模式小结</h3><ol>
<li>在GDT、LDT以及IDT中，每个描述符都有自己的界限和属性，对描述符所描述的对象进行了限定和保护。</li>
<li>分页机制的PDE和PTE包含的R/W和U/S等提供了页级的保护。</li>
<li>页式存储的使用使得应用程序使用的是线性地址空间而不是物理地址，保护了物理内存，也避免了程序之间的相互干扰。</li>
<li>中断也提供了特权检验等内容。</li>
<li>I/O指令也不再随便使用，提供了端口的保护。</li>
<li>不同特权级之间的切换伴随着CPL、PRL、DPL、IOPL等检验，同时伴随堆栈切换，对不同层级的程序进行了保护。</li>
</ol>
<p>操作系统所能提供的大多保护其实都是依赖于处理器的硬件才能实现的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在IA32下，CPU有两种工作模式：实模式和保护模式。两种模式都使用<code>Segment:Offset</code>的方式进行寻址。但是两种模式下，段和偏移的含义是完全不一样的。</p>
<h3 id="u5B9E_u6A21_u5F0F"><a href="#u5B]]>
    </summary>
    
      <category term="Operating System" scheme="http://nightfade.github.io/tags/Operating-System/"/>
    
  </entry>
  
</feed>
