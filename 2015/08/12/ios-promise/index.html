<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS开发中的Promise模式 | Nightfade's Techlog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS开发中的Promise模式</h1><a id="logo" href="/.">Nightfade's Techlog</a><p class="description">Programming</p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">iOS开发中的Promise模式</h1><div class="post-meta">Aug 12 2015 | </div><span data-disqus-identifier="2015/08/12/ios-promise/" class="disqus-comment-count"></span><div class="post-content"><h1 id="u4EC0_u4E48_u662FPromise"><a href="#u4EC0_u4E48_u662FPromise" class="headerlink" title="什么是Promise"></a>什么是Promise</h1><p>借用<a href="http://promisekit.org" target="_blank" rel="external"><code>PromiseKit</code></a>文档中的定义：</p>
<blockquote>
<p>A promise represents the future value of an asynchronous task.</p>
</blockquote>
<p>如果去Google一下<code>Promise模式</code>关键字，会发现基本都是和<code>JavaScript</code>相关的，在<code>JavaScript</code>中，<code>Promise</code>模式应用的非常多，因为<code>JavaScript</code>语言自身的特点（函数是一等对象），以及运行环境（浏览器，Node.js）决定了在<code>JavaScript</code>里异步操作运用的非常多，所以很多<code>JavaScript</code>开发者也想了很多办法更好的管理这些异步操作，<code>Promise</code>模式是其中最简洁有效的一种。</p>
<p>在iOS开发中，同样会面临和<code>JavaScript</code>运行环境类似的问题。作为客户端开发，我们必须要保证用户界面流畅不卡顿，所以要尽量避免有长时间运行的操作阻塞主线程。那使用的方式就是把耗时比较长的比如I/O操作、网络请求、数据库查询之类的操作放到后台线程里去做，等操作完成之后再通知主线程更新UI。这些放到后台里任务就构成了一系列异步操作。最传统的处理异步任务的方式是使用回调(<code>Callback</code>)。回调本身没什么问题，但是使用回调的异步操作代码相对来说更难看了。</p>
<p>编造一个真实场景的例子，假设我们要处理一个用户登录的流程：</p>
<ol>
<li>首先向服务器发起网络请求验证用户的账号密码。</li>
<li>验证成功之后查询本地数据库里有没有用户的相关信息：<br> a. 如果没有，向服务器发起网络请求拉取用户信息.<br> b. 如果有，把本地用户数据的时间戳发送给服务器检查需不需要更新数据，如果需要的话同样也做一次数据拉取。</li>
<li>拉取用户信息成功之后，把拉取到用户信息写回到数据库。</li>
</ol>
<p>整个流程中还需要考虑每一步的错误处理。</p>
<p>如果不考虑主线程阻塞的问题，就可以这么写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSync &#123; </span><br><span class="line">    <span class="built_in">BOOL</span> loginSuccess = [_client loginWithUsername:<span class="string">@"aUser"</span> andPassword:<span class="string">@"123456"</span>];</span><br><span class="line">    <span class="keyword">if</span> (!loginSuccess) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"登录验证失败！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">id</span> userData = [_db queryWithUsername:<span class="string">@"aUser"</span>];</span><br><span class="line">    <span class="built_in">BOOL</span> needFetch = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (userData) &#123;</span><br><span class="line">        <span class="built_in">NSNumber</span> * timestamp = [userData timestamp];</span><br><span class="line">        needFetch = [_client checkTimestamp:timestamp];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needFetch) &#123;</span><br><span class="line">        <span class="keyword">id</span> userData = [_client fetchUserData];</span><br><span class="line">        [_db writeUserData:userData];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"操作成功"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整个流程写下来非常清晰。但是真实情况下，为了避免阻塞线程，我们都会把网络操作、I/O操作包括数据库操作等等写成异步接口，这种情况下我们再看下代码要怎么写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doAsync &#123;</span><br><span class="line">    [_client loginWithUsername:<span class="string">@"aUser"</span> andPassword:<span class="string">@"123456"</span> result:^(<span class="built_in">BOOL</span> success)&#123;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            [_db queryWithUsername:<span class="string">@"aUser"</span> result:^(<span class="keyword">id</span> userData)&#123;</span><br><span class="line">                <span class="keyword">if</span> (userData) &#123;</span><br><span class="line">                    <span class="built_in">NSNumber</span> * timestamp = [userData timestamp];</span><br><span class="line">                    [_client checkTimestamp:timestamp result:^(<span class="built_in">BOOL</span> needFetch)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (needFetch) &#123;</span><br><span class="line">                            [_client fetchUserDataWithResult:^(<span class="keyword">id</span> userData)&#123;</span><br><span class="line">                                [_db writeUserData:userData result:^&#123;</span><br><span class="line">                                    <span class="built_in">NSLog</span>(<span class="string">@"操作成功!"</span>);                                </span><br><span class="line">                                &#125;]                            </span><br><span class="line">                            &#125;];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="built_in">NSLog</span>(<span class="string">@"操作成功!"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;];                </span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"登录失败！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后再看一下用了<code>Promise</code>模式的异步接口，代码是什么样子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doPromiseAsync &#123;</span><br><span class="line">    P<span class="built_in">MKPromise</span> *loginPromise = [_client loginWithUsername:<span class="string">@"aUser"</span> andPassword:<span class="string">@"123456"</span>];</span><br><span class="line">    P<span class="built_in">MKPromise</span> * queryPromise = loginPromise<span class="variable">.then</span>(^&#123;</span><br><span class="line">        <span class="keyword">return</span> [_db queryWithUsername:<span class="string">@"aUser"</span>];    </span><br><span class="line">    &#125;);</span><br><span class="line">    P<span class="built_in">MKPromise</span> * checkPromise = queryPromise<span class="variable">.then</span>(^(<span class="keyword">id</span> userData)&#123;</span><br><span class="line">        <span class="keyword">if</span> (userData) &#123;</span><br><span class="line">            <span class="built_in">NSNumber</span> * timestamp = [userData timestamp];</span><br><span class="line">            <span class="keyword">return</span> [_client checkTimestamp:timestamp];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    P<span class="built_in">MKPromise</span> * needFetchPromise = checkPromise<span class="variable">.then</span>(^(<span class="built_in">BOOL</span> needFetch)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!needFetch) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        P<span class="built_in">MKPromise</span> * fetchPromise = [_client fetchUserData];</span><br><span class="line">        P<span class="built_in">MKPromise</span> * writePromise = fetchPromise<span class="variable">.then</span>(^(<span class="keyword">id</span> userData)&#123;</span><br><span class="line">            <span class="keyword">return</span> [_db writeUserData:userData];    </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    needFetchPromise<span class="variable">.then</span>(^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"操作成功！"</span>);</span><br><span class="line">    &#125;)<span class="variable">.catch</span>(^(<span class="built_in">NSError</span> *err)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"操作失败：%@"</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>Promise</code>构建的异步操作的代码结构变得和同步接口很相似了，调用异步接口直接通过返回值返回一个<code>Promise</code>对象，这个对象‘保证‘会把相应异步操作会在将来到来的结果的值，通过<code>then</code>方法交给后续的调用。<code>Promise</code>支持链式调用，所以上面的例子中，我们可以省略中间变量，写成下面这种更简洁的方式：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doPromiseAsync &#123;</span><br><span class="line">    [_client loginWithUsername:<span class="string">@"aUser"</span> andPassword:<span class="string">@"123456"</span>]<span class="variable">.then</span>(^&#123;</span><br><span class="line">        <span class="keyword">return</span> [_db queryWithUsername:<span class="string">@"aUser"</span>];    </span><br><span class="line">    &#125;)<span class="variable">.then</span>(^(<span class="keyword">id</span> userData)&#123;</span><br><span class="line">        <span class="keyword">if</span> (userData) &#123;</span><br><span class="line">            <span class="built_in">NSNumber</span> * timestamp = [userData timestamp];</span><br><span class="line">            <span class="keyword">return</span> [_client checkTimestamp:timestamp];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)<span class="variable">.then</span>(^(<span class="built_in">BOOL</span> needFetch)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!needFetch) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> [_client fetchUserData]<span class="variable">.then</span>(^(<span class="keyword">id</span> userData)&#123;</span><br><span class="line">            <span class="keyword">return</span> [_db writeUserData:userData];    </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)<span class="variable">.then</span>(^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"操作成功！"</span>);</span><br><span class="line">    &#125;)<span class="variable">.catch</span>(^(<span class="built_in">NSError</span> *err)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"操作失败：%@"</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简而言之，使用<code>Promise</code>模式写异步操作，避免了层层嵌套的回调，使得代码结构和逻辑更直接更清晰。像使用同步接口一样，代码的书写顺序就是代码的执行顺序。</p>
<h1 id="PromiseKit_u7684_u57FA_u672C_u4F7F_u7528"><a href="#PromiseKit_u7684_u57FA_u672C_u4F7F_u7528" class="headerlink" title="PromiseKit的基本使用"></a>PromiseKit的基本使用</h1><p>直接引用<a href="http://promisekit.org" target="_blank" rel="external"><code>PromiseKit</code></a>首页的说明：</p>
<blockquote>
<p>PromiseKit is not just a promises implementation, it is also a collection of helper functions that make the typical asynchronous patterns we use as iOS developers delightful too.</p>
</blockquote>
<p>首先看一下<code>Promise</code>对象<code>PMKPromise</code>的主要接口：</p>
<h2 id="then"><a href="#then" class="headerlink" title="then"></a><code>then</code></h2><p><code>then</code>用来传入异步操作完成之后对结果的操作的Block。例如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIAlertView</span> *alertView = [<span class="built_in">UIAlertView</span> …];</span><br><span class="line">[alertView promise]<span class="variable">.then</span>(^(<span class="built_in">NSNumber</span> *dismissedIndex)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index %@ pressed."</span>, dismissedIndex);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Block的返回值可以是任意对象类型，值类型，<code>PMKPromise</code>对象类型，或者<code>NSError</code>类型。<code>then</code>的返回值也是<code>PMKPromise</code>类型。为了方便描述，假设原<code>PMKPromise</code>对象是<code>A</code>，<code>A</code>的<code>then</code>方法返回的<code>PMKPromise</code>对象是<code>B</code>。</p>
<ul>
<li>如果Block的返回值是对象类型或者值类型，那么<code>B</code>也会进一步向后传递这个值或者对象给<code>then</code>的Block。</li>
<li>如果Block的返回值也是<code>PMKPromise</code>对象，称作<code>C</code>，那么会首先执行<code>C</code>对应的异步操作，再把将<code>C</code>的Block的返回值传递给<code>B</code>。</li>
<li>如果Block的返回值类型是<code>NSError</code>，那么将触发错误处理流程。这部分在错误处理的章节会做详细说明。</li>
</ul>
<p>举例说明：</p>
<ol>
<li><p>Block返回值是值/对象类型：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[alertView promise]<span class="variable">.then</span>(^(<span class="built_in">NSNumber</span> *dismissedIndex)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index %@ pressed."</span>, dismissedIndex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.contacts</span>[dismissedIndex<span class="variable">.integerValue</span>];</span><br><span class="line">&#125;)<span class="variable">.then</span>(^(<span class="keyword">id</span> contact)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"contact name: %@ pressed."</span>, [contact name]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Block返回值类型也是<code>PMKPromise</code>类型：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[alertView promise]<span class="variable">.then</span>(^(<span class="built_in">NSNumber</span> *dismissedIndex)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index %@ pressed."</span>, dismissedIndex);</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span><span class="variable">.client</span> promiseQueryCotactAtIndex:dismissedIndex];</span><br><span class="line">&#125;)<span class="variable">.then</span>(^(<span class="keyword">id</span> contact)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"contact name: %@ pressed."</span>, [contact name]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a><code>catch</code></h2><p>如果调用链上某个Block返回值类型是<code>NSError</code>类型，<code>NSError</code>对象会直接跳过调用链上的<code>then</code>方法向下传递，直到遇到<code>catch</code>方法进行处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[alertView promise]<span class="variable">.then</span>(^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *dismissedIndex)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index %@ pressed."</span>, dismissedIndex);</span><br><span class="line">    <span class="keyword">if</span> (dismissedIndex &lt; <span class="keyword">self</span><span class="variable">.contacts</span><span class="variable">.count</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.contacts</span>[dismissedIndex<span class="variable">.integerValue</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSDemoErrorDomain</span> code:<span class="number">123</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="variable">.then</span>(^(<span class="keyword">id</span> contact)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"contact name: %@ pressed."</span>, [contact name]);</span><br><span class="line">&#125;)<span class="variable">.catch</span>(^(<span class="built_in">NSError</span> *err)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"error occurred with code: %@"</span>, @(err<span class="variable">.code</span>));    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>catch</code>方法除了可以进行错误处理，甚至还可以进行错误恢复。如果<code>catch</code>方法有非<code>NSError</code>的返回值，那就暗示着错误已经被处理了，所以后续的调用链会继续执行：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[alertView promise]<span class="variable">.then</span>(^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *dismissedIndex)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index %@ pressed."</span>, dismissedIndex);</span><br><span class="line">    <span class="keyword">if</span> (dismissedIndex &lt; <span class="keyword">self</span><span class="variable">.contacts</span><span class="variable">.count</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.contacts</span>[dismissedIndex<span class="variable">.integerValue</span>]<span class="variable">.name</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSDemoErrorDomain</span> code:<span class="number">123</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="variable">.catch</span>(^(<span class="built_in">NSError</span> *err)&#123;</span><br><span class="line">    <span class="keyword">if</span> (err<span class="variable">.code</span> == <span class="number">123</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@"Unknown Name"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// return err;</span></span><br><span class="line">        <span class="keyword">@throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="variable">.then</span>(^(<span class="built_in">NSString</span> * contactName)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"contact name: %@ pressed."</span>, contactName);</span><br><span class="line">&#125;)<span class="variable">.catch</span>(^(<span class="built_in">NSError</span> *err)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"fatal error: %@"</span>, @(err<span class="variable">.code</span>));    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p><code>finally</code>是<code>then</code>和<code>catch</code>的补充，无论调用链最终执行<code>then</code>还是<code>catch</code>，<code>finally</code>的代码块始终都会得到执行：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[alertView promise]<span class="variable">.then</span>(^<span class="keyword">id</span>(<span class="built_in">NSNumber</span> *dismissedIndex)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index %@ pressed."</span>, dismissedIndex);</span><br><span class="line">    <span class="keyword">if</span> (dismissedIndex &lt; <span class="keyword">self</span><span class="variable">.contacts</span><span class="variable">.count</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.contacts</span>[dismissedIndex<span class="variable">.integerValue</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSDemoErrorDomain</span> code:<span class="number">123</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="variable">.then</span>(^(<span class="keyword">id</span> contact)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"contact name: %@ pressed."</span>, [contact name]);</span><br><span class="line">&#125;)<span class="variable">.catch</span>(^(<span class="built_in">NSError</span> *err)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"error occurred with code: %@"</span>, @(err<span class="variable">.code</span>));    </span><br><span class="line">&#125;)<span class="variable">.finally</span>(^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"operation completed."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>了解了<code>PMKPromise</code>的主要对象，我们看一下怎么封装我们自己的<code>Promise</code>模式的异步API：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (P<span class="built_in">MKPromise</span> *)users &#123;</span><br><span class="line">    <span class="keyword">return</span> [P<span class="built_in">MKPromise</span> promiseWithResolverBlock:^(P<span class="built_in">MKResolver</span> resolve) &#123;</span><br><span class="line">        <span class="built_in">AVQuery</span> *query = [<span class="built_in">AVUser</span> query];</span><br><span class="line">        [query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *objects, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">            resolve(error ?: objects);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>PMKPromise</code>对象的<code>promiseWithResolverBlock</code>方法会传入的<code>resolve</code>参数，我们可以在异步操作完成的时候，讲异步操作的结果传给<code>resolve</code>。如果传入的是非<code>NSError</code>对象，那么就触发后续的<code>then</code>，否则触发后续的<code>catch</code>。</p>
<h1 id="PromiseKit_u8FDB_u9636"><a href="#PromiseKit_u8FDB_u9636" class="headerlink" title="PromiseKit进阶"></a>PromiseKit进阶</h1><h2 id="Dispatch_Queues"><a href="#Dispatch_Queues" class="headerlink" title="Dispatch Queues"></a>Dispatch Queues</h2><p>现在我们来讨论一下<code>PromiseKit</code>与<code>GCD</code>。之前我们看到的<code>PMKPromise</code>的<code>then</code>方法默认都是执行在主线程上的，但是我们可以很容易的通过<code>thenOn</code>方法把这些代码的执行<code>dispatch</code>到其他线程，例如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> url = <span class="string">@"http://www.baidu.com/test.png"</span>;</span><br><span class="line"><span class="keyword">id</span> q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">[<span class="built_in">NSURLConnection</span> GET:url]<span class="variable">.thenOn</span>(q, ^(<span class="built_in">UIImage</span> *image)&#123;</span><br><span class="line">    assert(![<span class="built_in">NSThread</span> isMainThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>PromiseKit</code>方法还提供了<code>thenInBackground</code>的便利函数，把后续的执行<code>dispatch</code>到<code>GCD</code>的<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>队列。</p>
<h2 id="when"><a href="#when" class="headerlink" title="when"></a><code>when</code></h2><p>之前我们例子里通过<code>then</code>去串行执行异步操作。很多时候我们还需要并行执行异步操作，等所有异步操作都执行完毕以后再继续后续操作。这时候就用到<code>when</code>方法，举例说明：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> search1 = [[[<span class="built_in">MKLocalSearch</span> alloc] initWithRequest:rq1] promise];</span><br><span class="line"><span class="keyword">id</span> search2 = [[[<span class="built_in">MKLocalSearch</span> alloc] initWithRequest:rq2] promise];</span><br><span class="line"><span class="comment">// PMKWhen(@[a, b]) 等价于 [PMKPromise when:@[a, b]]</span></span><br><span class="line">P<span class="built_in">MKWhen</span>(@[search1, search2])<span class="variable">.then</span>(^(<span class="built_in">NSArray</span> *results)&#123;</span><br><span class="line">    <span class="keyword">id</span> resultOfSearch1 = results[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">id</span> resultOfSearch2 = results[<span class="number">1</span>];</span><br><span class="line">&#125;)<span class="variable">.catch</span>(^(<span class="built_in">NSError</span> *error)&#123;</span><br><span class="line">    <span class="comment">// called if either search fails</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>至此，<code>PromiseKit</code>的常用的方法基本就是这些，其他更多的用法，可以参考<a href="http://promisekit.org" target="_blank" rel="external"><code>PromiseKit</code>文档</a>。</p>
</div><div class="tags"><a href="/tags/iOS/">iOS</a></div><div class="post-nav"><a href="/2015/08/28/notes-on-using-swift-with-cocoa-and-objective-c/" class="pre"><i class="icon-previous">《Using Swift with Cocoa and Objective-C》学习笔记</i></a><a href="/2015/08/09/ios-in-app-purchase/" class="next">iOS应用内购买IAP接入<i class="icon-next"></i></a></div><div id="disqus_thread"><script>var disqus_shortname = 'nightfade';
var disqus_identifier = '2015/08/12/ios-promise/';
var disqus_title = 'iOS开发中的Promise模式';
var disqus_url = 'http://nightfade.github.io/2015/08/12/ios-promise/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//nightfade.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://nightfade.github.io"/></form></div><div class="widget"><div class="widget-title">分类</div></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/HLS/" style="font-size: 15px;">HLS</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/CPP/" style="font-size: 15px;">CPP</a> <a href="/tags/Multithreading/" style="font-size: 15px;">Multithreading</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/ReactiveCocoa/" style="font-size: 15px;">ReactiveCocoa</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/SQLite/" style="font-size: 15px;">SQLite</a> <a href="/tags/CMake/" style="font-size: 15px;">CMake</a> <a href="/tags/qiniu/" style="font-size: 15px;">qiniu</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/GameDev/" style="font-size: 15px;">GameDev</a> <a href="/tags/Actor/" style="font-size: 15px;">Actor</a> <a href="/tags/protobuf/" style="font-size: 15px;">protobuf</a> <a href="/tags/RPC/" style="font-size: 15px;">RPC</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Operating-System/" style="font-size: 15px;">Operating System</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2015/09/15/cpp1x-atomic/">多线程内存模型和C++1x Atomic</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/01/reactivecocoa3-basic/">ReactiveCocoa 3.0 初步</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/28/notes-on-using-swift-with-cocoa-and-objective-c/">《Using Swift with Cocoa and Objective-C》学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/12/ios-promise/">iOS开发中的Promise模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/09/ios-in-app-purchase/">iOS应用内购买IAP接入</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/02/sql-summary/">SQLite中的常用SQL语法、锁机制和WAL</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/26/ios-markdown-rendering/">iOS开发中的Markdown渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/24/dynamic-height-cell/">可变高度的UITableViewCell</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/05/10/qiniu-hls/">使用七牛云存储实现HLS在线视频授权播放</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/12/20/actor-model-and-game-development/">关于Actor模型与游戏编程的一点想法</a></li></ul></div><div class="widget"><div class="widget-title">最近评论</div><script type="text/javascript" src="//nightfade.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title">友情链接</div></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">Nightfade's Techlog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"></div></body></html>