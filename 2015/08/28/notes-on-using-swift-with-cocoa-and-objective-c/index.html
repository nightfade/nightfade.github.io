<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>《Using Swift with Cocoa and Objective-C》学习笔记 | Nightfade's Techlog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《Using Swift with Cocoa and Objective-C》学习笔记</h1><a id="logo" href="/.">Nightfade's Techlog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">《Using Swift with Cocoa and Objective-C》学习笔记</h1><div class="post-meta">Aug 28 2015 | </div><span data-disqus-identifier="2015/08/28/notes-on-using-swift-with-cocoa-and-objective-c/" class="disqus-comment-count"></span><div class="post-content"><p>学习《<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/" target="_blank" rel="external">Using Swift with Cocoa and Objective-C</a>》的笔记。</p>
<h1 id="Interoperability"><a href="#Interoperability" class="headerlink" title="Interoperability"></a>Interoperability</h1><h2 id="Interacting_with_Objective-C_APIs"><a href="#Interacting_with_Objective-C_APIs" class="headerlink" title="Interacting with Objective-C APIs"></a>Interacting with Objective-C APIs</h2><h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><p>在Swift中初始化一个Objective-C的类：</p>
<ul>
<li>Objective-C中的<code>init</code>方法要删掉<code>init</code>前缀，只是表明这个方法是一个构造器。</li>
<li><code>initWith</code>开头的要连“With”一起删除。</li>
<li>删掉<code>initWith</code>之后的<code>selector</code>分片的第一个字母改成小写。并且作为参数名。</li>
<li>不需要调用<code>alloc</code>。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITableView</span> *myTableView = [[<span class="built_in">UITableView</span> alloc] initWithFrame:<span class="built_in">CGRectZero</span> style:<span class="built_in">UITableViewStyleGrouped</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTableView: <span class="type">UITableView</span> = <span class="type">UITableView</span>(frame: <span class="type">CGRectZero</span>, style: .<span class="type">Grouped</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>Objective-C中的工厂方法被映射为Swift中的<code>convenience initializer</code>。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *color = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.5</span> green:<span class="number">0.0</span> blue:<span class="number">0.5</span> alpha:<span class="number">1.0</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = <span class="type">UIColor</span>(red: <span class="number">0.5</span>, green: <span class="number">0.0</span>, blue: <span class="number">0.5</span>, alpha: <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Failable_Initialization"><a href="#Failable_Initialization" class="headerlink" title="Failable Initialization"></a>Failable Initialization</h4><p>Objective-C的构造器可以返回<code>nil</code>告知初始化失败，Swift通过可失败构造器达到相同的目的。Objective-C通过引入<code>Nullability and Optionals</code>语法表明构造器是不是可失败的，如果不可失败，Swift构造器是<code>init</code>，否则<code>init?</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> image = <span class="type">UIImage</span>(contentsOfFile: <span class="string">"MyImage.png"</span>) &#123;</span><br><span class="line">    <span class="comment">// loaded the imagesuccessfully</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// could not load the image</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Accessing_Properties"><a href="#Accessing_Properties" class="headerlink" title="Accessing Properties"></a>Accessing Properties</h3><ul>
<li>Objective-C中不同<code>nullability</code>特性的属性（<code>nonnull</code>，<code>nullable</code>，<code>null-resettable</code>）分别映射到Swift中的<code>optional</code>，<code>nonoptional</code>属性。</li>
<li>Objective-C的<code>readonly</code>属性导入到Swift变成<code>{ get }</code>的计算属性。</li>
<li>Objective-C的<code>weak</code>属性导入到Swift变成<code>weak var</code>属性。</li>
<li>Objective-C的<code>assign</code>、<code>copy</code>、<code>strong</code>、<code>unsafe_unretained</code>属性导入到Swift变成相应的存储属性。</li>
<li>Objective-C中的<code>atomic</code>和<code>nonatomic</code>在Swift中被忽略，全部都是<code>nonatomic</code>。</li>
<li>Objective-C中的<code>getter=</code>和<code>setter=</code>在Swift中被忽略。</li>
</ul>
<h3 id="Working_with_Methods"><a href="#Working_with_Methods" class="headerlink" title="Working with Methods"></a>Working with Methods</h3><ul>
<li>Objective-C中selector的第一部分作为相应Swift方法的方法名出现在括号外。</li>
<li>剩余的selector分片变成相应的参数名出现在括号内。</li>
<li>所有的selector分片在调用的时候都是必须有的。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[myTableView insertSubview:mySubview atIndex:<span class="number">2</span>];</span><br><span class="line">``` </span><br><span class="line">```swift</span><br><span class="line">myTableView<span class="variable">.insertSubview</span>(mySubview, atIndex: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="id_Compatibility"><a href="#id_Compatibility" class="headerlink" title="id Compatibility"></a>id Compatibility</h3><p>Swift有一个<code>AnyObject</code><em>协议</em>用来表示任意类型的对象，等价于Objective-C中的<code>id</code>。可以对其调用任意Objective-C的方法和访问任意属性而不需要强制转换成特定类型。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObjective: <span class="type">AnyObject</span> = <span class="type">UITableViewCell</span>()</span><br><span class="line">myObject = <span class="type">NSDate</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> futureDate = myObject.dateByAddingTimeInterval(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> timeSinceNow = myObject.timeIntervalSinceNow</span><br></pre></td></tr></table></figure></p>
<p>访问<code>AnyObject</code>不存在的方法或属性会触发<code>runtime error</code>，但是可以利用Swift的可选链消除错误。另外，访问<code>AnyObject</code>的属性总是返回一个可空值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myChar = myObject.characterAtIndex?(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
<p>也可以强制转换<code>AnyObject</code>到一个特定类型：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastRefreshDate: <span class="type">AnyObject</span>? = userDefaults.objectForKey(<span class="string">"LastRefreshDate"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> date = lastRefreshDate <span class="keyword">as</span>? <span class="type">NSDate</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Nullability_and_Options"><a href="#Nullability_and_Options" class="headerlink" title="Nullability and Options"></a>Nullability and Options</h3><p>Objective-C中引用对象的指针可以是<code>nil</code>，Swift中所有的对象都是非空的，如果要表示值缺失需要用<code>optional</code>类型。<br>Objective-C引入了<code>nullability</code>记号来表示一个参数、属性或者返回值是否可以<code>nil</code>。</p>
<ul>
<li>声明为<code>_Nonnull</code>或者包裹在<code>NS_ASSUME_NONNULL_BEGIN</code>和<code>NS_ASSUME_NONNULL_END</code>之间的类型被导入为Swift中的<code>non-optional</code>类型。</li>
<li>声明为<code>_Nullable</code>的类型被导入为Swift中的<code>optional</code>类型。</li>
<li>不带<code>nullability</code>记号的类型被导入为Swift肿的隐式<code>optional</code>类型。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (nullable) <span class="keyword">id</span> nullableProperty;</span><br><span class="line"><span class="keyword">@property</span> (nonnull) <span class="keyword">id</span> nonNullProperty;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">id</span> unannotatedProperty;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line">- (<span class="keyword">id</span>)returnsNonNullValue;</span><br><span class="line">- (<span class="keyword">void</span>)takesNonNullParameter:(<span class="keyword">id</span>)value;</span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br><span class="line">- (nullable <span class="keyword">id</span>)returnsNullableValue;</span><br><span class="line">- (<span class="keyword">void</span>)takeNullableParameter:(nullable <span class="keyword">id</span>)value;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)returnsUnannotatedValue;</span><br><span class="line">- (<span class="keyword">void</span>)takesUnannotatedParameter:(<span class="keyword">id</span>)value;</span><br></pre></td></tr></table></figure>
<p>导入为Swift:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableProperty: <span class="type">AnyObject</span>?</span><br><span class="line"><span class="keyword">var</span> nonNullProperty: <span class="type">AnyObject</span></span><br><span class="line"><span class="keyword">var</span> unannotatedProperty: <span class="type">AnyObject</span>!</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsNonNullValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesNonNullParameter</span><span class="params">(value: AnyObject)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsNullableValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>?</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesNullableParameter</span><span class="params">(value: AnyObject?)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsUnannotatedValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>!</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesUnannotatedParameter</span><span class="params">(value: AnyObject!)</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><p>Swift的<code>Extension</code>和Objective-C的<code>Category</code>类似。但是不能用<code>Extension</code>重写Objective-C中已经存在的方法和属性。</p>
<h3 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h3><p>Objective-C中的<code>block</code>被导入为Swift中的<code>closure</code>。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^completionBlock)(<span class="built_in">NSData</span> *, <span class="built_in">NSError</span> *) = ^(<span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>等价于：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> completionBlock: (<span class="type">NSData</span>, <span class="type">NSError</span>) -&gt; <span class="type">Void</span> = &#123; (data, error) <span class="keyword">in</span> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以把Swift的<code>closure</code>传给Objective-C中需要<code>block</code>的方法作为参数。</p>
<p><code>closure</code>捕获变量和<code>block</code>有一点不同：Objective-C中的<code>__block</code>行为在Swift是默认的。</p>
<h3 id="Object_Comparison"><a href="#Object_Comparison" class="headerlink" title="Object Comparison"></a>Object Comparison</h3><p>Swift的<code>==</code>比较运算符会调用Objective-C中<code>NSObject</code>定义的<code>isEqual:</code>方法。对于从<code>NSObject</code>继承来的类，应该实现相应的<code>isEqual:</code>方法。如果想要把对象用作字典的key，还需要实现<code>Hashable</code>协议中的<code>hashValue</code>属性。</p>
<h3 id="Swift_Type_Compatibility"><a href="#Swift_Type_Compatibility" class="headerlink" title="Swift Type Compatibility"></a>Swift Type Compatibility</h3><p>当从Objective-C的类创建一个Swift的类的时候，它的所有成员——属性、方法、下标和构造器都是可用的。但是如果要把Swift的类（不是从Objective-C的类继承来的，或者想改变借口的名字）暴露给Objective-C，就需要显式的指定<code>@objc</code>属性。</p>
<h4 id="Exposing_Swift_Interface_in_Objective-C"><a href="#Exposing_Swift_Interface_in_Objective-C" class="headerlink" title="Exposing Swift Interface in Objective-C"></a>Exposing Swift Interface in Objective-C</h4><p>如果Swift的类是从<code>NSObject</code>或者任意Objective-C的类继承来的，那这个类就自动和Objective-C兼容。否则，用<code>@objc</code>放在Swift的方法、属性、下标、构造器，或者类、枚举的声明之前。<code>@objc</code>还能为方法指定其他名称<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@objc</span>(<span class="type">SomeClass</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> 中文类名: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="preprocessor">@objc</span>(initWithName:)</span><br><span class="line">    <span class="keyword">init</span>(中文参数名: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="preprocessor">@objc</span>(hideNuts:inTree:)</span><br><span class="line">    <span class="func"><span class="keyword">func</span> 中文方法<span class="params">(参数<span class="number">1</span>: Int, 参数<span class="number">2</span>: Int)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Lightweight_Generics"><a href="#Lightweight_Generics" class="headerlink" title="Lightweight Generics"></a>Lightweight Generics</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSDate</span> *&gt; *dates;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *words;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSData</span> *&gt; *cachedData;</span><br></pre></td></tr></table></figure>
<p>Swift将导入为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dates: [<span class="type">NSDate</span>]</span><br><span class="line"><span class="keyword">var</span> words: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"><span class="keyword">var</span> cachedData: [<span class="type">NSURL</span>: <span class="type">NSData</span>]</span><br></pre></td></tr></table></figure></p>
<p>除了Foundation Collection的类以外，Objective-C中的lightweight generics都会被Swfit忽略。</p>
<h3 id="Objective-C_Selectors"><a href="#Objective-C_Selectors" class="headerlink" title="Objective-C Selectors"></a>Objective-C Selectors</h3><p>在Swift中，Objective-C的Selector被结构体<code>Selector</code>所表示。可以直接用字符串字面量构造一个Selector：<code>let mySelector: Selector = &quot;tappedButton:&quot;</code>。因为字符串字面量可以自动转换为Selector，所以可以把一个字符串字面量直接传给任意接收Selector参数的方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myButton.addTarget(<span class="keyword">self</span>, action: <span class="string">"tappedButton:"</span>, forControlEvents: .<span class="type">TouchUpInside</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="Writing_Swift_Classes_with_Objective-C_Behavior"><a href="#Writing_Swift_Classes_with_Objective-C_Behavior" class="headerlink" title="Writing Swift Classes with Objective-C Behavior"></a>Writing Swift Classes with Objective-C Behavior</h2><h3 id="Inheriting_from_Objective-C_Classes"><a href="#Inheriting_from_Objective-C_Classes" class="headerlink" title="Inheriting from Objective-C Classes"></a>Inheriting from Objective-C Classes</h3><p>Swift中可以直接定义Objective-C中类的子类。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySwiftViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要重写父类方法，需要加上<code>override</code>关键字。</p>
<h3 id="Adopting_Protocols"><a href="#Adopting_Protocols" class="headerlink" title="Adopting Protocols"></a>Adopting Protocols</h3><p>Swift可以采用Objective-C中定义的protocol。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySwiftViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为Swift中类的名字空间和protocol的名字空间是统一的，所以在Swift中，<code>NSObject</code>协议被映射为<code>NSObjectProtocol</code>。</p>
<h3 id="Integrating_with_Interface_Builder"><a href="#Integrating_with_Interface_Builder" class="headerlink" title="Integrating with Interface Builder"></a>Integrating with Interface Builder</h3><p>Swift中使用outlets和actions，只需要在属性前插入<code>@IBOutlet</code>或者<code>@IBAction</code>关键字。<code>@IBOutlet</code>使得属性编程隐式可选。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> button: <span class="type">UIButton</span>!</span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> textFields: [<span class="type">UITextField</span>]!</span><br><span class="line">    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">buttonTapped</span>:<span class="params">(<span class="number">_</span>: AnyObject)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"button tapped!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Specifying_Property_Attributes"><a href="#Specifying_Property_Attributes" class="headerlink" title="Specifying Property Attributes"></a>Specifying Property Attributes</h3><h4 id="Strong_and_Weak"><a href="#Strong_and_Weak" class="headerlink" title="Strong and Weak"></a>Strong and Weak</h4><p>Swift属性默认是<code>strong</code>的。用<code>weak</code>关键字指示属性是弱引用，并且该属性是可选类型。</p>
<h4 id="Read/Write_and_Read-Only"><a href="#Read/Write_and_Read-Only" class="headerlink" title="Read/Write and Read-Only"></a>Read/Write and Read-Only</h4><p>Swift里没有<code>readwrite</code>和<code>readonly</code>属性，如果声明存储属性，用<code>let</code>表示只读，用<code>var</code>表示可读可写。如果是计算属性，<code>{ get }</code>表示只读，<code>{ get set }</code>可读可写。</p>
<h4 id="Copy_Semantics"><a href="#Copy_Semantics" class="headerlink" title="Copy Semantics"></a>Copy Semantics</h4><p>Swift中，Objective-C的<code>copy</code>被转换成了<code>@NSCopying</code>，也就是说该属性必须符合<code>NSCopying</code>协议。</p>
<h3 id="Using_Swift_Class_Names_with_Objective-C_APIs"><a href="#Using_Swift_Class_Names_with_Objective-C_APIs" class="headerlink" title="Using Swift Class Names with Objective-C APIs"></a>Using Swift Class Names with Objective-C APIs</h3><p>Swift的类都放在他们所在的module的全局的命名空间里，在Objective-C引用也一样。例如，一个叫<code>MyFramework</code>的framework中的一个Swift的类<code>DataManager</code>的名字是<code>MyFramework.DataManager</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> muyPersonClass: <span class="type">AnyClass</span> = <span class="type">NSClassFromString</span>(<span class="string">"MyGreatApp.Person"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="Working_with_Cocoa_Data_Types"><a href="#Working_with_Cocoa_Data_Types" class="headerlink" title="Working with Cocoa Data Types"></a>Working with Cocoa Data Types</h2><p>Swift会自动的将一些Objective-C的类型转换为Swift的类型，也会把一些Swfit类型转换为Objective-C的类型，也有一些是可以直接互换的。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Swift自动的在<code>String</code>和<code>NSString</code>类型之间转换，不应该在Swift中使用<code>NSString</code>。<br>当Swift导入Objective-C的API的时候，会把所有的<code>NSString</code>类型替换成<code>String</code>。当Objective-C使用Swift类的时候，会把所有<code>String</code>类型替换成<code>NSString</code>。只需要<code>import Foundation</code>就可以开启两种类型的桥接。</p>
<h4 id="Localization"><a href="#Localization" class="headerlink" title="Localization"></a>Localization</h4><p>Swift中用一个函数<code>NSLocalizedString(key:tableName:bundle:value:comment:)</code>替换掉了Objective-C一组宏（<code>NSLocalizedString</code>、<code>NSLocalizedStringFromTable</code>、<code>NSLocalizedStringFromTableInBundle</code>、<code>NSLocalizedStringWithDefaultValue</code>），其中为<code>tableName</code>、<code>bundle</code>、<code>value</code>都提供了默认值。</p>
<h3 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h3><p>Swift自动把<code>Int</code>、<code>Float</code>等数值类型桥接到<code>NSNumber</code>。可以用这些数值类型创建<code>NSNumber</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">42</span></span><br><span class="line"><span class="keyword">let</span> m: <span class="type">NSNumber</span> = n</span><br></pre></td></tr></table></figure></p>
<h3 id="Collection_Classes"><a href="#Collection_Classes" class="headerlink" title="Collection Classes"></a>Collection Classes</h3><p>Swift把<code>NSArray</code>、<code>NSSet</code>、<code>NSDictionary</code>分别桥接到<code>Array</code>、<code>Set</code>、<code>Dictionary</code>。</p>
<h4 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h4><p>如果<code>NSArray</code>指定了参数化类型，则对应到Swift中的<code>[ObjectType]</code>，否则对应到<code>[AnyObject]</code>。可以用<code>as?</code>或者<code>as!</code>把<code>[AnyObject]</code>转换到<code>[SomeType]</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swiftArray = foundationArray <span class="keyword">as</span> [<span class="type">AnyObject</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> downcastedSwiftArray = swiftArray <span class="keyword">as</span>? [<span class="type">NSView</span>] &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要把Swift数组转换成<code>NSArray</code>，数组里的元素必须是符合<code>AnyObject</code>协议的。将Swift API导入Objective-C的时候，会把所有<code>Array</code>替换成<code>NSArray</code>。</p>
<h4 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h4><p><code>Set&lt;ObjectType&gt;</code>对应<code>NSSet&lt;ObjectType&gt;</code>，如果没有指定<code>ObjectType</code>，则对应到<code>Set&lt;AnyObject&gt;</code></p>
<h4 id="Dictionaries"><a href="#Dictionaries" class="headerlink" title="Dictionaries"></a>Dictionaries</h4><p><code>NSDictionary</code>如果没有指定参数化类型，则对应到<code>[NSObject: AnyObject]</code></p>
<h3 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h3><p>Swift把<code>ErrorType</code>（协议）和<code>NSError</code>进行桥接。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@objc</span> <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CustomError</span>: <span class="title">Int</span>, <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应到相应的Objective-C的声明：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> SWIFT_ENUM(<span class="built_in">NSInteger</span>, CustomError) &#123;</span><br><span class="line">    CustomErrorA = <span class="number">0</span>,</span><br><span class="line">    CustomErrorB = <span class="number">1</span>,</span><br><span class="line">    CustomErrorC = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> String * <span class="keyword">const</span> CustomErrorDomain = <span class="string">@"Project.CustomError"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Foundation_Data_Types"><a href="#Foundation_Data_Types" class="headerlink" title="Foundation Data Types"></a>Foundation Data Types</h3><p>Swift对Foundation Framework中的数据类型做了封装。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> size = <span class="type">CGSize</span>(width: <span class="number">20</span>, height: <span class="number">40</span>)</span><br><span class="line"><span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">50</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> width = rect.width <span class="comment">// 等价于CGRectGetWidth(rect)</span></span><br><span class="line"><span class="keyword">let</span> maxX = rect.maxY <span class="comment">// 等价于CGRectGetMaxY(rect)</span></span><br></pre></td></tr></table></figure></p>
<p>还把<code>NSUInteger</code>和<code>NSInteger</code>桥接到<code>Int</code>。</p>
<h3 id="Core_Foundation"><a href="#Core_Foundation" class="headerlink" title="Core Foundation"></a>Core Foundation</h3><h4 id="u91CD_u6620_u5C04_u7C7B_u578B_uFF1A"><a href="#u91CD_u6620_u5C04_u7C7B_u578B_uFF1A" class="headerlink" title="重映射类型："></a>重映射类型：</h4><p>Swift导入Core Foundation类型的时候，编译器吧类型名中的<code>Ref</code>移除。</p>
<h4 id="u5185_u5B58_u7BA1_u7406"><a href="#u5185_u5B58_u7BA1_u7406" class="headerlink" title="内存管理"></a>内存管理</h4><p>Swift中使用Core Foundation中<code>annotated</code>的API返回的对象会自动处理内存管理，不需要调用<code>CFRetain</code>、<code>CFRelase</code>或者<code>CFAutorelase</code>。<br>其他情况需要处理<code>Unmanaged&lt;Instance&gt;</code>。</p>
<h3 id="u9519_u8BEF_u5904_u7406"><a href="#u9519_u8BEF_u5904_u7406" class="headerlink" title="错误处理"></a>错误处理</h3><p>Cocoa中，会产生错误的方法把<code>NSError</code>指针作为最后一个参数，如果Objective-C方法的最后一个非block的参数是<code>NSError **</code>，Swift就把它替换成<code>throws</code>关键字，如果同时还是第一个关键字，会尝试简化方法名字，比如删除<code>WithError</code>或者<code>AndReturnError</code>后缀。如果这样的方法返回<code>BOOL</code>值表示方法成功或者失败，Swift会把返回值改成<code>Void</code>，如果返回<code>nil</code>表示失败，Swift会把返回值类型替换成<code>non-optional</code>类型。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)removeItemAtURL:(<span class="built_in">NSURL</span> *)URL error:(<span class="built_in">NSError</span> **)error;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">removeItemAtURL</span><span class="params">(URL: NSURL)</span></span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure>
<h2 id="Key-Value_Observing"><a href="#Key-Value_Observing" class="headerlink" title="Key-Value Observing"></a>Key-Value Observing</h2><p>Swift中可以对继承自<code>NSObject</code>的类使用KVO，用<code>dynamic</code>关键字表明属性是需要<code>observe</code>的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObjectToObserve</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> myDate = <span class="type">NSDate</span>()</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">updateDate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        myDate = <span class="type">NSDate</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> myContext = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> objectToObserve = <span class="type">MyObjectToObserve</span>()</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        objectToObserve.addObserver(<span class="keyword">self</span>, forKeyPath:<span class="string">"myDate"</span>, options: .<span class="type">New</span>, context: &amp;myContext)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">observeValueForKeyPath</span><span class="params">(keyPath:String?, ofObject object: AnyObject?, change: [String: AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        objectToObserve.removeObserver(<span class="keyword">self</span>, forKeyPath:<span class="string">"MyDate"</span>, context: &amp;myContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance: <span class="type">Singleton</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> instance = <span class="type">Singleton</span>()</span><br><span class="line">        <span class="comment">// setup code</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/Swift/">Swift</a><a href="/tags/iOS/">iOS</a></div><div class="post-nav"><a href="/2015/09/01/reactivecocoa3-basic/" class="pre"><i class="icon-previous">ReactiveCocoa 3.0 初步</i></a><a href="/2015/08/12/ios-promise/" class="next">iOS开发中的Promise模式<i class="icon-next"></i></a></div><div id="disqus_thread"><script>var disqus_shortname = 'nightfade';
var disqus_identifier = '2015/08/28/notes-on-using-swift-with-cocoa-and-objective-c/';
var disqus_title = '《Using Swift with Cocoa and Objective-C》学习笔记';
var disqus_url = 'http://nightfade.github.io/2015/08/28/notes-on-using-swift-with-cocoa-and-objective-c/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//nightfade.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://nightfade.github.io"/></form></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Operating-System/" style="font-size: 15px;">Operating System</a> <a href="/tags/CMake/" style="font-size: 15px;">CMake</a> <a href="/tags/CPP/" style="font-size: 15px;">CPP</a> <a href="/tags/Multithreading/" style="font-size: 15px;">Multithreading</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/ReactiveCocoa/" style="font-size: 15px;">ReactiveCocoa</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/SQLite/" style="font-size: 15px;">SQLite</a> <a href="/tags/HLS/" style="font-size: 15px;">HLS</a> <a href="/tags/qiniu/" style="font-size: 15px;">qiniu</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/GameDev/" style="font-size: 15px;">GameDev</a> <a href="/tags/Actor/" style="font-size: 15px;">Actor</a> <a href="/tags/protobuf/" style="font-size: 15px;">protobuf</a> <a href="/tags/RPC/" style="font-size: 15px;">RPC</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2015/09/15/cpp1x-atomic/">多线程内存模型和C++1x Atomic</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/01/reactivecocoa3-basic/">ReactiveCocoa 3.0 初步</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/28/notes-on-using-swift-with-cocoa-and-objective-c/">《Using Swift with Cocoa and Objective-C》学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/12/ios-promise/">iOS开发中的Promise模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/09/ios-in-app-purchase/">iOS应用内购买IAP接入</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/02/sql-summary/">SQLite中的常用SQL语法、锁机制和WAL</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/26/ios-markdown-rendering/">iOS开发中的Markdown渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/24/dynamic-height-cell/">可变高度的UITableViewCell</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/05/10/qiniu-hls/">使用七牛云存储实现HLS在线视频授权播放</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/12/20/actor-model-and-game-development/">关于Actor模型与游戏编程的一点想法</a></li></ul></div><div class="widget"><div class="widget-title">最近评论</div><script type="text/javascript" src="//nightfade.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title">友情链接</div></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">Nightfade's Techlog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"></div></body></html>