<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>SQLite中的常用SQL语法、锁机制和WAL | Nightfade's Techlog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">SQLite中的常用SQL语法、锁机制和WAL</h1><a id="logo" href="/.">Nightfade's Techlog</a><p class="description">Programming</p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">SQLite中的常用SQL语法、锁机制和WAL</h1><div class="post-meta">Aug 2 2015 | </div><span data-disqus-identifier="2015/08/02/sql-summary/" class="disqus-comment-count"></span><div class="post-content"><p>本文主要参考《SQLite权威指南》。</p>
<h1 id="u521B_u5EFA_u8868"><a href="#u521B_u5EFA_u8868" class="headerlink" title="创建表"></a>创建表</h1><p>创建表的通用形式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> [TEMP|<span class="keyword">TEMPORARY</span>] <span class="keyword">TABLE</span> table_name (column_definitions [, <span class="keyword">constraints</span>]);</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>TEMP/TEMPORARY</code>关键字表示声明的表是临时表，一旦当前数据库断开链接，就自动销毁。</li>
<li><code>table_name</code>是表名。</li>
<li><code>column_definitions</code>是由逗号分隔的字段列表组成。</li>
</ul>
<p>SQLite有5中本地类型：<code>INTEGER</code>，<code>REAL</code>，<code>TEXT</code>，<code>BLOB</code>，<code>NULL</code>。</p>
<p>下面是一个例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> contacts (<span class="keyword">id</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">                       <span class="keyword">name</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COLLATE</span> NOCASE,</span><br><span class="line">                       phone <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'UNKNOWN'</span>,</span><br><span class="line">                       <span class="keyword">UNIQUE</span> (<span class="keyword">name</span>, phone));</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u4FEE_u6539_u8868"><a href="#u4FEE_u6539_u8868" class="headerlink" title="修改表"></a>修改表</h1><p>修改表的一般格式为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name &#123; <span class="keyword">RENAME</span> <span class="keyword">TO</span> <span class="keyword">name</span> | <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="keyword">column</span> <span class="keyword">def</span> &#125;;</span></span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> contacts</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> email <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COLLATE</span> NOCASE;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u6570_u636E_u5E93_u67E5_u8BE2"><a href="#u6570_u636E_u5E93_u67E5_u8BE2" class="headerlink" title="数据库查询"></a>数据库查询</h1><p><code>select</code>命令的通用形式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="keyword">heading</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">tables</span></span><br><span class="line"><span class="keyword">WHERE</span> predicate</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">columns</span></span><br><span class="line"><span class="keyword">HAVING</span> predicate</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">columns</span> [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>]</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="keyword">count</span></span><br><span class="line"><span class="keyword">OFFSET</span> <span class="keyword">offset</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>理解<code>select</code>命令的最好方法是将其当成处理关系的<code>管道</code>。</p>
<h2 id="u8FC7_u6EE4"><a href="#u8FC7_u6EE4" class="headerlink" title="过滤"></a>过滤</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dogs <span class="keyword">WHERE</span> color=<span class="string">'purple'</span> <span class="keyword">AND</span> grin=<span class="string">'toothy'</span>;</span></span><br></pre></td></tr></table></figure>
<p>数据库会获取表<code>dogs</code>中的所有行，然后用<code>where</code>子句形成预测逻辑，如果为真，该行将会包含在结果集里。</p>
<h2 id="u9650_u5B9A_u548C_u6392_u5E8F"><a href="#u9650_u5B9A_u548C_u6392_u5E8F" class="headerlink" title="限定和排序"></a>限定和排序</h2><p>可以用<code>limit</code>和<code>offset</code>关键字限定结果集的大小和范围。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> foods <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'B%'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> type_id <span class="keyword">DESC</span>, <span class="keyword">name</span> <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">2</span>;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u51FD_u6570_uFF08Function_uFF09_u548C_u805A_u5408_uFF08Aggregate_uFF09"><a href="#u51FD_u6570_uFF08Function_uFF09_u548C_u805A_u5408_uFF08Aggregate_uFF09" class="headerlink" title="函数（Function）和聚合（Aggregate）"></a>函数（Function）和聚合（Aggregate）</h1><p>SQLite提供多种内置的函数和聚合。<br>函数的种类包括：</p>
<ul>
<li>数学函数，例如计算绝对值的<code>ABS()</code>。</li>
<li>字符串格式函数，例如将字符串转化为大写或小写的<code>UPPER()</code>和<code>LOWER()</code>。</li>
</ul>
<p>函数可以是任意表达式的一部分，可以用在<code>WHERE</code>子句中。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">UPPER</span>(<span class="keyword">name</span>), <span class="keyword">LENGTH</span>(<span class="keyword">name</span>) <span class="keyword">FROM</span> foods <span class="keyword">WHERE</span> <span class="keyword">LENGTH</span>(<span class="keyword">name</span>) &lt; <span class="number">5</span> <span class="keyword">LIMIT</span> <span class="number">5</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>聚合是一类特殊的函数，它从一组记录中计算聚合值。标准的聚合函数包括：<code>SUM()</code>，<code>AVG()</code>，<code>COUNT()</code>，<code>MIN()</code>，<code>MAX()</code>。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> foods <span class="keyword">WHERE</span> type_id=<span class="number">1</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>聚合不仅可以聚合字段，也可以聚合任意表达式，标扩函数。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">LENGTH</span>(<span class="keyword">name</span>)) <span class="keyword">FROM</span> foods;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u5206_u7EC4_uFF08Grouping_uFF09"><a href="#u5206_u7EC4_uFF08Grouping_uFF09" class="headerlink" title="分组（Grouping）"></a>分组（Grouping）</h1><p>聚合不只是能够计算整个结果集的聚合至，还可以把结果集分成多个组，然后计算每个组的聚合值，方法是使用<code>GROUP BY</code>子句，例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> type_id, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> foods <span class="keyword">GROUP</span> <span class="keyword">BY</span> type_id;</span></span><br></pre></td></tr></table></figure></p>
<p>从操作上讲，<code>GROUP BY</code>介于<code>WHERE</code>和<code>SELECT</code>子句中间。<code>GROUP BY</code>接收<code>WHERE</code>的输出，并将其分割成共享某个字段（或多个字段）上同等值的小组，这些组再传递给<code>SELECT</code>子句。<br>使用<code>GROUP BY</code>时，<code>SELECT</code>子句<em>对每组单独应用聚合，而不是对整个结果进行聚合</em>。因此，聚合对魅族生成一个值，并将这些组的行作为单行。</p>
<p><code>HAVING</code>是一个可以应用到<code>GROUP BY</code>的断言。它从<code>GROUP BY</code>中过滤组的方式与<code>WHERE</code>子句从<code>FROM</code>中过滤行的方式相同。唯一不同的是，<code>WHERE</code>子句的预测是针对单个行的，而<code>HAVING</code>的断言是针对聚合值的。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> type_id, <span class="keyword">COUNT</span>(*) <span class="keyword">from</span> foods</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> type_id <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &lt; <span class="number">20</span>;</span></span><br></pre></td></tr></table></figure></p>
<p><code>GROUP BY</code>接收<code>WHERE</code>子句的约束，将结果行分成共享某值的组。<code>HAVING</code>对每组应用过滤，通过过滤的组传递给<code>SELECT</code>子句来做聚合和映射。</p>
<h1 id="u53BB_u6389_u91CD_u590D"><a href="#u53BB_u6389_u91CD_u590D" class="headerlink" title="去掉重复"></a>去掉重复</h1><p><code>DISTINCT</code>处理<code>SELECT</code>的结果并过滤掉其中重复的行。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> type_id <span class="keyword">FROM</span> foods;</span></span><br></pre></td></tr></table></figure></p>
<p>该语句的工作流程：<code>WHERE</code>子句返回表<code>foods</code>的所有行，<code>SELECT</code>子句取出其中的<code>type_id</code>字段，最终<code>DISTINCT</code>删除重复行。</p>
<h1 id="u591A_u8868_u94FE_u63A5"><a href="#u591A_u8868_u94FE_u63A5" class="headerlink" title="多表链接"></a>多表链接</h1><p>连接(JOIN)是多表关系数据工作的关键，它是<code>SELECT</code>命令的第一个操作，连接操作的结果作为输入，供<code>SELECT</code>语句的其他部分过滤处理。</p>
<p>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> foods.<span class="keyword">name</span>, food_types.<span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> foods, food_types</span><br><span class="line"><span class="keyword">WHERE</span> foods.type_id=food_types.<span class="keyword">id</span></span><br><span class="line"><span class="keyword">LIMIt</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>要实现连接，数据库需要找出匹配的行。对于第一个表中的每一行，数据库都要查询的第二个表的所有行，寻找那些链接字段具有相同值的行，然后将他们包含到输入关系中。</p>
<p>SQLite支持六种不同类型的连接，其中一种称为<em>内连接</em>的连接是最普遍的。</p>
<h2 id="u5185_u8FDE_u63A5"><a href="#u5185_u8FDE_u63A5" class="headerlink" title="内连接"></a>内连接</h2><p>内连接就是通过表中的两个字段进行连接。内连接找出两边集合那些包含相似值的行，然后结合两者形成结果集。<br>内连接只返回满足给定字段关系的行，也称为连接条件。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> foods <span class="keyword">INNER</span> <span class="keyword">JOIN</span> food_types <span class="keyword">ON</span> foods.<span class="keyword">id</span> = food_types.<span class="keyword">id</span>;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u4EA4_u53C9_u8FDE_u63A5"><a href="#u4EA4_u53C9_u8FDE_u63A5" class="headerlink" title="交叉连接"></a>交叉连接</h2><p>如果没有连接条件，<code>SELECT</code>会产生一种更基础的连接，称为交叉连接、笛卡尔积或者交叉乘积。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> foods, food_types;</span></span><br></pre></td></tr></table></figure></p>
<p><code>FROM</code>在缺乏其他条件时产生交叉连接，<code>foods</code>中的每一行都与<code>food_types</code>的所有行组合在一起。</p>
<h2 id="u5916_u8FDE_u63A5"><a href="#u5916_u8FDE_u63A5" class="headerlink" title="外连接"></a>外连接</h2><p>内连接是根据给定关系选择表中的行。外连接选择内连接的所有行外加一些关系之外的行。<br>三种外连接类型分别是：左外连接、右外连接和全外连接。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> foods <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> foods_episodes <span class="keyword">ON</span> foods.<span class="keyword">id</span> = foods_episodes.food_id;</span></span><br></pre></td></tr></table></figure></p>
<p>左外连接试图将<code>foods</code>中的所有行与<code>foods_episodes</code>的所有行进行行连接关系的匹配，所有匹配的行都包含在结果集中。但是，如果我们在<code>foods</code>表中注册一些食品，这些食品没有在<code>foods_episodes</code>中出现，<code>foods</code>表中没有匹配<code>food_episodes</code>的剩余行仍然会出现在结果集中，foods_episodes没有提供相应的行，它会以null补充。</p>
<p>右外连接的工作方式类似，不管是否匹配，右表的行都包含在结果集中。</p>
<p>全外连接是左外连接和右外连接的结合。它包含所有的匹配航，然后是右边和左边表的不匹配行。</p>
<p>目前SQLite不支持右外连接和全外连接，但是右外连接可以用左外连接代替，全外连接可以通过使用复合查询执行。</p>
<h2 id="u81EA_u7136_u8FDE_u63A5"><a href="#u81EA_u7136_u8FDE_u63A5" class="headerlink" title="自然连接"></a>自然连接</h2><p>自然连接是内连接的另一种形式，自然连接通过表中共有的字段名称将两个表连接起来，因此，使用自然连接时，不用添加连接条件就可以获得内连接的结果。<br>如果表的设计一直在改变，最好清晰的定义查询中的连接条件，不要使用自然连接。</p>
<h2 id="u8BED_u6CD5_u504F_u597D"><a href="#u8BED_u6CD5_u504F_u597D" class="headerlink" title="语法偏好"></a>语法偏好</h2><p>语法上讲，可以通过各种方式制定连接，<code>foods</code>和<code>food_types</code>的内连接可以通过<code>WHERE</code>子句隐含实现：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> foods, food_types <span class="keyword">WHERE</span> foods.<span class="keyword">id</span> = food_types.food_id;</span></span><br></pre></td></tr></table></figure></p>
<p>这种隐式形式虽然简洁，但是是一种应该避免的果实的语法形式。SQL中正确的表达连接的方法是使用连接关键字：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">heading</span> <span class="keyword">FROM</span> left_table JOIN_TYPE right_table <span class="keyword">ON</span> join_condition;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u540D_u79F0_u548C_u522B_u540D"><a href="#u540D_u79F0_u548C_u522B_u540D" class="headerlink" title="名称和别名"></a>名称和别名</h1><p>举例说明：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">f</span>.<span class="keyword">name</span>, <span class="keyword">t</span>.<span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> foods <span class="keyword">f</span>, food_types <span class="keyword">t</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">f</span>.type_id = <span class="keyword">t</span>.<span class="keyword">id</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">f</span>.<span class="keyword">name</span> <span class="keyword">AS</span> food, e1.<span class="keyword">name</span>, e2.season, e2.<span class="keyword">name</span>, e2.season</span><br><span class="line"><span class="keyword">FROM</span> episodes e1, foods_episodes fe1, foods <span class="keyword">f</span>,</span><br><span class="line">     episodes e2, foods_episodes fe2</span><br><span class="line"><span class="keyword">WHERE</span> e1.<span class="keyword">id</span> = fe1.episode_id <span class="keyword">AND</span> e1.season = <span class="number">4</span> <span class="keyword">AND</span> fe1.food_id = <span class="keyword">f</span>.<span class="keyword">id</span> </span><br><span class="line">      <span class="keyword">AND</span> fe1.food_id = fe2.food_id</span><br><span class="line">      <span class="keyword">AND</span> fe2.episode_id = e2.<span class="keyword">id</span> <span class="keyword">AND</span> e2.season != e1.season</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">f</span>.<span class="keyword">name</span>;</span></span><br></pre></td></tr></table></figure>
<h1 id="u5B50_u67E5_u8BE2"><a href="#u5B50_u67E5_u8BE2" class="headerlink" title="子查询"></a>子查询</h1><p>子查询最常用的地方是<code>WHERE</code>子句，特别是<code>IN</code>操作符中：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) </span><br><span class="line"><span class="keyword">FROM</span> foods</span><br><span class="line"><span class="keyword">WHERE</span> type_id <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="keyword">id</span> </span><br><span class="line">     <span class="keyword">FROM</span> food_types</span><br><span class="line">     <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'Bakery'</span> <span class="keyword">OR</span> <span class="keyword">name</span>=<span class="string">'Cereal'</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>可以用来从其他表向结果集添加额外数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">name</span>,</span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> foods_episodes <span class="keyword">WHERE</span> food_id=<span class="keyword">f</span>.<span class="keyword">id</span>) <span class="keyword">AS</span> <span class="keyword">count</span></span><br><span class="line"><span class="keyword">FROM</span> foods <span class="keyword">f</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">count</span> <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>子查询中可以使用<code>ORDER BY</code>子句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(type_id) <span class="keyword">FROM</span> foods <span class="keyword">WHERE</span> type_id=<span class="keyword">f</span>.type_id) <span class="keyword">DESC</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>有时可能想与其他结果进行连接：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">f</span>.<span class="keyword">name</span>, types.<span class="keyword">name</span> <span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> food_types <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">6</span>) types <span class="keyword">ON</span> <span class="keyword">f</span>.type_id=types.<span class="keyword">id</span>;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u590D_u5408_u67E5_u8BE2"><a href="#u590D_u5408_u67E5_u8BE2" class="headerlink" title="复合查询"></a>复合查询</h1><p>复合查询与子查询相反，它是使用三种特殊的关系操作符处理多个查询的结果：<code>UNION</code>、<code>INTERSECT</code>、<code>EXCEPT</code>。<br>复合查询操作需要如下一些条件：</p>
<ul>
<li>涉及的关系的字段数目必须相同。</li>
<li>只能有一个<code>ORDER BY</code>子句，并且处在复合查询的最末尾，对联合结果进行排序。</li>
</ul>
<p><code>UNION</code>联合两个<code>SELECT</code>语句的结果，默认情况下，<code>UNION</code>会消除重复数据，如果想在结果中保留重复数据，可以使用<code>UNION ALL</code>。<br>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">f</span>.*, top_foods.<span class="keyword">count</span> <span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> food_id, <span class="keyword">COUNT</span>(food_id) <span class="keyword">AS</span> <span class="keyword">count</span> <span class="keyword">from</span> foods_episodes</span><br><span class="line">            <span class="keyword">GROUP</span> <span class="keyword">BY</span> food_id</span><br><span class="line">            <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">COUNT</span>(food_id) <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>) top_foods</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">f</span>.<span class="keyword">id</span>=top_foods.food_id</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">f</span>.*, bottom_foods.<span class="keyword">count</span> <span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> food_id, <span class="keyword">count</span>(food_id) <span class="keyword">AS</span> <span class="keyword">count</span> <span class="keyword">FROM</span> foods_episodes</span><br><span class="line">            <span class="keyword">GROUP</span> <span class="keyword">BY</span> food_id</span><br><span class="line">            <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">COUNT</span>(food_id) <span class="keyword">LIMIT</span> <span class="number">1</span>) bottom_foods</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">f</span>.<span class="keyword">id</span>=bottom_foods.food_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> top_foods.<span class="keyword">count</span> <span class="keyword">DESC</span>;</span></span><br></pre></td></tr></table></figure></p>
<p><code>INTERSECT</code>操作输入两个关系A和B，选择那些既在A也在B的行。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">f</span>.* <span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">        (<span class="keyword">SELECT</span> food_id, <span class="keyword">COUNT</span>(food_id) <span class="keyword">AS</span> <span class="keyword">count</span></span><br><span class="line">         <span class="keyword">FROM</span> foods_episodes</span><br><span class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> food_id</span><br><span class="line">         <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">COUNT</span>(food_id) <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">10</span>) top_foods</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">f</span>.<span class="keyword">id</span>=top_foods.food_id</span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">f</span>.* <span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> foods_spisodes fe <span class="keyword">ON</span> <span class="keyword">f</span>.<span class="keyword">id</span>=fe.food_id</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> episodes <span class="keyword">e</span> <span class="keyword">ON</span> fe.episode_id=<span class="keyword">e</span>.<span class="keyword">id</span></span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">e</span>.season <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">5</span></span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">f</span>.<span class="keyword">name</span>;</span></span><br></pre></td></tr></table></figure></p>
<p><code>EXCEPT</code>操作输入两个关系A和B，找出所有在A但不在B的行。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">f</span>.* <span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">        (<span class="keyword">SELECT</span> food_id, <span class="keyword">COUNT</span>(food_id) <span class="keyword">AS</span> <span class="keyword">count</span> <span class="keyword">FROM</span> foods_episodes</span><br><span class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> food_id</span><br><span class="line">         <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">COUNT</span>(food_id) <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">10</span>) top_foods</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">f</span>.<span class="keyword">id</span>=top_foods.food_id</span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">f</span>.* <span class="keyword">from</span> foods <span class="keyword">f</span></span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> foods_episodes fe <span class="keyword">ON</span> <span class="keyword">f</span>.<span class="keyword">id</span>=fe.food_id</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> foods_episodes <span class="keyword">e</span> <span class="keyword">ON</span> fe.episode_id=<span class="keyword">e</span>.<span class="keyword">id</span></span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">e</span>.season <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">f</span>.<span class="keyword">name</span>;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u6761_u4EF6_u7ED3_u679C"><a href="#u6761_u4EF6_u7ED3_u679C" class="headerlink" title="条件结果"></a>条件结果</h1><p><code>CASE</code>表达式允许在<code>SELECT</code>语句中处理各种情况。</p>
<ol>
<li><p>接受静态值并列出各种情况下<code>CASE</code>返回值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">name</span> || <span class="keyword">CASE</span> type_id</span><br><span class="line">                   <span class="keyword">WHEN</span> <span class="number">7</span> <span class="keyword">THEN</span> <span class="string">' is a drink'</span></span><br><span class="line">                   <span class="keyword">WHEN</span> <span class="number">8</span> <span class="keyword">THEN</span> <span class="string">' is a fruit'</span></span><br><span class="line">                   <span class="keyword">WHEN</span> <span class="number">9</span> <span class="keyword">THEN</span> <span class="string">' is junkfood'</span></span><br><span class="line">                   <span class="keyword">WHEN</span> <span class="number">13</span> <span class="keyword">THEN</span> <span class="string">' is seafood'</span></span><br><span class="line">                   <span class="keyword">ELSE</span> <span class="literal">NULL</span></span><br><span class="line">               <span class="keyword">END</span> <span class="keyword">AS</span> description</span><br><span class="line"><span class="keyword">FROM</span> foods</span><br><span class="line"><span class="keyword">WHERE</span> description <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>WHEN</code>条件中有表达式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">name</span>, (<span class="keyword">SELECT</span> <span class="keyword">CASE</span></span><br><span class="line">                  <span class="keyword">WHEN</span> <span class="keyword">COUNT</span>(*) &gt; <span class="number">4</span> <span class="keyword">THEN</span> <span class="string">'VERY HIGH'</span></span><br><span class="line">                  <span class="keyword">WHEN</span> <span class="keyword">COUNT</span>(*) = <span class="number">4</span> <span class="keyword">THEN</span> <span class="string">'HIGH'</span></span><br><span class="line">                  <span class="keyword">WHEN</span> <span class="keyword">COUNT</span>(*) <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>) <span class="keyword">THEN</span> <span class="string">'Moderate'</span></span><br><span class="line">                  <span class="keyword">ELSE</span> <span class="string">'Low'</span></span><br><span class="line">              <span class="keyword">END</span></span><br><span class="line">              <span class="keyword">FROM</span> foods_episodes</span><br><span class="line">              <span class="keyword">WHERE</span> food_id=<span class="keyword">f</span>.<span class="keyword">id</span>) <span class="keyword">AS</span> frequency</span><br><span class="line"><span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line"><span class="keyword">WHERE</span> frequency <span class="keyword">like</span> <span class="string">'%HIGH'</span>;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="u4FEE_u6539_u6570_u636E"><a href="#u4FEE_u6539_u6570_u636E" class="headerlink" title="修改数据"></a>修改数据</h1><h2 id="u63D2_u5165_u8BB0_u5F55"><a href="#u63D2_u5165_u8BB0_u5F55" class="headerlink" title="插入记录"></a>插入记录</h2><p>使用<code>INSERT</code>命令向表中插入记录，<code>INSERT</code>语句的一般格式为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column_list) <span class="keyword">VALUES</span> (value_list);</span></span><br></pre></td></tr></table></figure></p>
<p>插入一行：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> foods (<span class="keyword">name</span>, type_id) <span class="keyword">VALUES</span> (<span class="string">'Cinnamon Bobka'</span>, <span class="number">1</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>插入一组行：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> foods</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="literal">NULL</span>,</span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> food_types <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'Bakery'</span>),</span><br><span class="line">        <span class="string">'Blackberry Bobka'</span>);</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> foods</span><br><span class="line"><span class="keyword">SELECT</span> last_insert_rowid()+<span class="number">1</span>, type_id, <span class="keyword">name</span> <span class="keyword">FROM</span> foods</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'Chocolate Bobka'</span>;</span></span><br></pre></td></tr></table></figure>
<p>只要<code>SELECT</code>子句的字段数目与要插入的表的字段数目匹配，或者与提供的字段列表匹配，<code>INSERT</code>语句就可以正常工作。</p>
<h2 id="u66F4_u65B0_u8BB0_u5F55"><a href="#u66F4_u65B0_u8BB0_u5F55" class="headerlink" title="更新记录"></a>更新记录</h2><p><code>UPDATE</code>命令用于更新表中的记录，该命令可以修改一个表中的一行或多行中的一个或多个字段。<code>UPDATE</code>语句的一般格式为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> update_list <span class="keyword">WHERE</span> predicate;</span></span><br></pre></td></tr></table></figure></p>
<p><code>update_list</code>是一个或多个“字段赋值”的列表，字段赋值的格式为<code>column_name=value</code>。例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">UPDATE</span> foods <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">'CHOCOLATE BOBKA'</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'Chocolate Bobka'</span>;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u5220_u9664_u8BB0_u5F55"><a href="#u5220_u9664_u8BB0_u5F55" class="headerlink" title="删除记录"></a>删除记录</h2><p>使用<code>DELETE</code>命令可以删除表中的记录，<code>DELETE</code>语句的一般格式为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> predicate;</span></span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> foods <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'CHOCOLATE BOBKA'</span>;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u6570_u636E_u5B8C_u6574_u6027"><a href="#u6570_u636E_u5B8C_u6574_u6027" class="headerlink" title="数据完整性"></a>数据完整性</h1><p>数据完整性用于定义和保护表内部或表之间的数据关系。一般有四种完整性：域完整性、实体完整性、引用完整性和用户自定义完整性。</p>
<ul>
<li>域完整性：控制字段内的值。</li>
<li>实体完整性：表中的行。</li>
<li>引用完整性：表之间的行，也就是外键关系。</li>
<li>用户自定义完整性：其他。</li>
</ul>
<h2 id="u5B9E_u4F53_u5B8C_u6574_u6027"><a href="#u5B9E_u4F53_u5B8C_u6574_u6027" class="headerlink" title="实体完整性"></a>实体完整性</h2><p>行必须在某种方式上是唯一的，这就是<strong>主键</strong>的功能。<br>主键由至少带有<code>UNIQUE</code>约束的一个或一组字段组成。<br>唯一性约束：一个<code>UNIQUE</code>约束要求一个或一组字段的所有值互不相同，如果视图插入一个重复值，或者将一个值更新成一个已存在的值，数据库将引发一个约束非法，并终止操作。<br>主键约束：定义一个表时总要确定一个主键，不管自己有没有定义。这个字段是一个64bit的整形字段，称为<code>rowid</code>，还有两个别名<code>_rowid_</code>和<code>oid</code>。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> contacts (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> AUTOINCREMENT</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COLLATE</span> nocase,</span><br><span class="line">    phone <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'UNKNOWN'</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span>(<span class="keyword">name</span>, phone));</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u57DF_u5B8C_u6574_u6027"><a href="#u57DF_u5B8C_u6574_u6027" class="headerlink" title="域完整性"></a>域完整性</h2><ol>
<li><p>默认值：如果用<code>INSERT</code>语句插入记录时没有为该字段指定值，关键字<code>DEFAULT</code>将为字段提供一个默认值。<br><code>DEFAULT</code>还可以接受3中预定义格式的保留字，用于生成日期和时间。<code>current_time</code>将生成（HH:MM:SS）的当前时间，<code>current_date</code>将生成(YYYY-MM-DD)格式的当前日期，<code>current_timestamp</code>将生成一个日期时间的组合(YYYY-MM-DD HH:MM:SS)。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> times (<span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">                    <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">current_date</span>,</span><br><span class="line">                    <span class="keyword">time</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">current_time</span>,</span><br><span class="line">                    <span class="keyword">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">current_timestamp</span>);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>NOT NULL</code>约束：确保该字段值不为<code>NULL</code>。</p>
</li>
<li><p><code>CHECK</code>约束：允许自定义表达式来测试要插入或更新的字段值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> contacts (<span class="keyword">id</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">                       <span class="keyword">name</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COLLATE</span> NOCASE,</span><br><span class="line">                       phone <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'UNKNOWN'</span>,</span><br><span class="line">                       <span class="keyword">UNIQUE</span>(<span class="keyword">name</span>, phone),</span><br><span class="line">                       <span class="keyword">CHECK</span>(<span class="keyword">LENGTH</span>(<span class="keyword">name</span>) &gt;= <span class="number">7</span>));</span></span><br><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> foo (x <span class="built_in">INTEGER</span>,</span><br><span class="line">                  y <span class="built_in">INTEGER</span> <span class="keyword">CHECK</span> (y &gt; x),</span><br><span class="line">                  z <span class="built_in">INTEGER</span> <span class="keyword">CHECK</span> (z &gt; <span class="keyword">ABS</span>(y)));</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>外键约束：确保一个表中的关系值必须从另一个表中引用，且该数据必须在另一个表中实际存在，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (column_definitions <span class="keyword">REFERENCES</span> foreign_table (column_name) <span class="keyword">on</span> &#123;<span class="keyword">DELETE</span>|<span class="keyword">UPDATE</span>&#125; integrity_action [<span class="keyword">not</span>] deferrable [<span class="keyword">INITIALLY</span> &#123;DEFERED|<span class="keyword">IMMEDIATE</span>&#125;,]</span><br><span class="line">);</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>举例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> foods (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    type_id <span class="built_in">INTEGER</span> <span class="keyword">REFERENCES</span> food_types(<span class="keyword">id</span>) </span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT</span><br><span class="line">    DEFERRABLE <span class="keyword">INITIALLY</span> <span class="keyword">DEFERRED</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">TEXT</span></span><br><span class="line">)</span></span><br></pre></td></tr></table></figure></p>
<p><code>DELETE RESTRICT</code>阻止任何破坏完整性的行为。其他的选项有：</p>
<ul>
<li><code>SET NULL</code>：如果父值被删除或者不存在了，子值设置为<code>NULL</code>。</li>
<li><code>SET DEFAULT</code>：如果赋值不存在了就设置为默认值。</li>
<li><code>CASCADE</code>：更新父值时，更新所有匹配的子值。删除父值时，删除所有子值。</li>
<li><code>RESTRICT</code>：如果更新或删除父值可能出现孤立的子值，就阻止事务。</li>
<li><code>NO ACTION</code>：不干涉操作，只是在整个语句的结尾报错。</li>
</ul>
<p><code>DEFERRABLE</code>子句控制定义的约束是立即强制实施还是延迟到整个事务结束时。</p>
<ol>
<li>排序规则：SQLite内置三种排序规则，默认的是二进制排序规则，使用C函数<code>memcmp()</code>逐字节比较文本值。第二种，<code>NOCASE</code>是拉丁字母中26个ASCII字符的非大小写敏感排序算法。第三种，<code>REVERSE</code>排序规则，和二进制排序规则相反。</li>
</ol>
<h1 id="u89C6_u56FE"><a href="#u89C6_u56FE" class="headerlink" title="视图"></a>视图</h1><p>视图即虚拟表，也称为派生表，因为它们的内容都派生自其他表的查询结果。视图的内容是在使用时动态产生的。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="keyword">name</span> <span class="keyword">AS</span> <span class="keyword">select</span>-stmt;</span></span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> details <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">f</span>.<span class="keyword">name</span> <span class="keyword">AS</span> fd, ft.<span class="keyword">name</span> <span class="keyword">AS</span> tp, <span class="keyword">e</span>.<span class="keyword">name</span> <span class="keyword">AS</span> ep, <span class="keyword">e</span>.season <span class="keyword">AS</span> ssn</span><br><span class="line"><span class="keyword">FROM</span> foods <span class="keyword">f</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> food_types ft <span class="keyword">ON</span> <span class="keyword">f</span>.type_id=ft.<span class="keyword">id</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> foods_spisodes fe <span class="keyword">ON</span> <span class="keyword">f</span>.<span class="keyword">id</span>=fe.food_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> episodes <span class="keyword">e</span> <span class="keyword">ON</span> fe.episode_id=<span class="keyword">e</span>.<span class="keyword">id</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> fd <span class="keyword">AS</span> FOOD, ep <span class="keyword">AS</span> Episode <span class="keyword">FROM</span> details <span class="keyword">WHERE</span> ssn=<span class="number">7</span> <span class="keyword">AND</span> tp <span class="keyword">LIKE</span> <span class="string">'Drinks'</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>视图的内容是动态生成的，每次使用<code>details</code>时，基于数据库对当前数据执行相关的SQL语句，产生结果。<br>使用命令<code>DROP VIEW</code>删除视图：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="keyword">name</span>;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u7D22_u5F15"><a href="#u7D22_u5F15" class="headerlink" title="索引"></a>索引</h1><p>索引是一种用来在某种条件下加速查询的结构，例如如下查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> foods <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'JujyFruit'</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>当数据库搜索匹配行时，执行这种查询的默认方法是调用顺序扫描。如果表<code>foods</code>非常大，使用索引的方法查找数据就更有意义了。<br>创建索引的命令如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> [<span class="keyword">UNIQUE</span>] index_name <span class="keyword">ON</span> table_name (<span class="keyword">columns</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>关键字<code>UNIQUE</code>会在索引上添加约束，索引中的所有值必须是唯一的。<br>例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> <span class="keyword">UNIQUE</span> foo_index <span class="keyword">ON</span> foo (a, b);</span></span><br></pre></td></tr></table></figure></p>
<p>删除索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name;</span></span><br></pre></td></tr></table></figure></p>
<p>排序规则：索引中的每个字段都有相关的排序规则，例如，要在<code>foods.name</code>上创建大小写不敏感的索引，可以使用如下命令：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> foods_name_idx <span class="keyword">ON</span> foods (<span class="keyword">name</span> <span class="keyword">COLLATE</span> NOCASE);</span></span><br></pre></td></tr></table></figure></p>
<p>使用索引<br>对于下面会在<code>WHERE</code>子句中出现的表达式，SQLite将使用单个字段索引：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">column &#123;=|&gt;|&gt;=|&lt;=|&lt;&#125; expression</span><br><span class="line">expression &#123;=|&gt;|&gt;=|&lt;=|&lt;&#125; column</span><br><span class="line">column IN (expression-list)</span><br><span class="line">column IN (subquery)</span><br></pre></td></tr></table></figure></p>
<p>多字段索引有更复杂的条件，它从左到右智能的使用字段。</p>
<h1 id="u89E6_u53D1_u5668"><a href="#u89E6_u53D1_u5668" class="headerlink" title="触发器"></a>触发器</h1><p>当具体的表发生特定的数据库事件时，触发器执行对应的SQL命令。创建触发器的一般命令如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> [TEMP|<span class="keyword">TEMPORARY</span>] <span class="keyword">TRIGGER</span> <span class="keyword">name</span></span><br><span class="line">[<span class="keyword">BEFORE</span>|<span class="keyword">AFTER</span>] [<span class="keyword">INSERT</span>|<span class="keyword">DELETE</span>|<span class="keyword">UPDATE</span>|<span class="keyword">UPDATE</span> <span class="keyword">OF</span> <span class="keyword">columns</span>] <span class="keyword">ON</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">action</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> TEMP <span class="keyword">TRIGGER</span> foods_update_log <span class="keyword">UPDATE</span> <span class="keyword">OF</span> <span class="keyword">name</span> <span class="keyword">ON</span> foods</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">log</span> <span class="keyword">VALUES</span> (<span class="string">'updated foods: new name = '</span> || <span class="keyword">new</span>.<span class="keyword">name</span>);</span></span><br><span class="line"><span class="operator"><span class="keyword">END</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>UPDATE</code>触发器中，未更新行可以引用为<code>old</code>，已更新行可以引用为<code>new</code>。</p>
<p>错误处理：SQLite提供一个特殊的SQL函数<code>raise()</code>供触发器调用，该函数允许在触发器内产生错误，<code>raise()</code>定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span>(resolution, error_message);</span><br></pre></td></tr></table></figure></p>
<p>第一个参数是冲突解决策略（<code>abort</code>, <code>fail</code>, <code>ignore</code>, <code>rollback</code>等），第二个参数是错误消息。</p>
<p>可更新视图：可利用触发器实现可更新视图。<br>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> on_update_foods_view</span><br><span class="line">INSTEAD <span class="keyword">OF</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> foods_view</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> foods <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="keyword">new</span>.fname <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="keyword">new</span>.fid;</span></span><br><span class="line">    <span class="operator"><span class="keyword">UPDATE</span> food_types <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="keyword">new</span>.tname <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="keyword">new</span>.tid;</span></span><br><span class="line"><span class="operator"><span class="keyword">END</span>;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u4E8B_u52A1"><a href="#u4E8B_u52A1" class="headerlink" title="事务"></a>事务</h1><p>事务定义了一组SQL命令的边界，这组命令或者作为一个整体被全部执行，或者都不执行。<br>事务由3个命令控制：<code>BEGIN</code>、<code>COMMIT</code>和<code>ROLLBACK</code>。</p>
<ul>
<li><code>BEGIN</code>开始一个事务，<code>BEGIN</code>之后的所有操作都可以取消，如果连接终止前没有发出<code>COMMIT</code>，也会被取消。</li>
<li><code>COMMIT</code>提交事务开始后所执行的所有操作。</li>
<li><code>ROLLBACK</code>还原<code>BEGIN</code>之后的所有操作。</li>
</ul>
<p>例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">BEGIN</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> foods;</span></span><br><span class="line"><span class="operator"><span class="keyword">ROLLBACK</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> foods;</span> <span class="comment">-- output: 412</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u51B2_u7A81_u89E3_u51B3"><a href="#u51B2_u7A81_u89E3_u51B3" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>违反约束会导致事务终止，在对数据进行很多修改的过程中，命令终止会简单的将前面所做的修改全部取消。<br>通过冲突解决可以指定不同的方式处理约束违反的情况。<br>SQLite提供5种可能的冲突解决方案或策略：</p>
<ul>
<li><code>REPLACE</code>：违反唯一性约束时，将造成这种违反的记录删除，以插入或修改的新纪录替代。违反<code>NOT NULL</code>约束时，则使用该字段的默认值代替<code>NULL</code>，如果没有默认值，则应用<code>ABORT</code>策略。</li>
<li><code>IGNORE</code>：当违反约束发生时，允许命令继续执行，违反约束的行保持不变，命令继续处理其他且不报错。</li>
<li><code>FAIL</code>：当违反约束发生时，终止命令，但是不回复约束违反之前已经修改的记录，违反约束之后的都不回继续处理了。</li>
<li><code>ABORT</code>：违反约束发生时，恢复当前命令所有的所有改变并终止命令。这是SQLite中所有操作的默认解决办法。</li>
<li><code>ROLLBACK</code>：违反约束发生时，执行回滚。当前命令所做的改变和事务中之前命令的改变都回滚。</li>
</ul>
<p>冲突解决方法既可以在SQL命令中指定，也可以在表盒索引的定义中执行。具体来说，可以在<code>INSERT</code>、<code>UPDATE</code>、<code>CREATE TABLE</code>和<code>CREATE INDEX</code>中指定。<br>在<code>INSERT</code>和<code>UPDATE</code>中的语法形式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">OR</span> *RESOLUTION_TYPE* <span class="keyword">INTO</span> table_name (column_list) <span class="keyword">VALUES</span> (value_list);</span></span><br><span class="line"><span class="operator"><span class="keyword">UPDATE</span> <span class="keyword">OR</span> *RESOLUTION_TYPE* table_name <span class="keyword">SET</span> (value_list) <span class="keyword">WHERE</span> predicate;</span></span><br></pre></td></tr></table></figure></p>
<p>表内定义时，可以为单个字段指定冲突解决方法，例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">cast</span> (<span class="keyword">name</span> <span class="built_in">TEXT</span> <span class="keyword">UNIQUE</span> <span class="keyword">ON</span> CONFLICT <span class="keyword">ROLLBACK</span>);</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u6570_u636E_u5E93_u9501"><a href="#u6570_u636E_u5E93_u9501" class="headerlink" title="数据库锁"></a>数据库锁</h2><p>SQLite使用锁逐步提升机制，为了写数据库，连接需要逐级获得排它锁。SQLite有5种不同的锁状态：未加锁(<code>UNLOCKED</code>)、共享(<code>SHARED</code>)、预留(<code>RESERVED</code>)、未决(<code>PENDING</code>)和排他(<code>EXCLUSIVE</code>)。</p>
<ul>
<li>最初的状态是<code>UNLOCK</code>状态，此状态下连接还没有访问数据库。</li>
<li>为了能从数据库<strong>读</strong>数据，连接必须首先进入<code>SHARED</code>状态。多个连接可以同时获得并保持共享锁，只要有一个共享锁没有释放，就不允许任何连接写数据库。</li>
<li>如果一个连接想要写数据库，必须首先获得一个预留锁(<code>RESERVED</code>)。一个数据库只能有一个预留锁，该预留锁可以与共享锁共存，它不阻止其他拥有共享锁的连接继续读数据库，也不阻止其他连接获得新的共享锁。</li>
<li>一旦连接获得预留锁，就可以开始处理数据库的修改操作，此时修改只能在缓冲区中进行，不实际写磁盘。</li>
<li>当连接想要<strong>提交修改</strong>时，需要将预留锁提升为排他锁(<code>EXCLUSIVE</code>)。为了得到排他锁，必须首先将预留锁提升为未决锁(<code>PENDING</code>)。<strong>获得未决锁之后，其他连接不能再获得新的共享锁。</strong>此时，拥有未决锁的连接等待其他拥有共享锁的连接完成工作并释放共享锁。</li>
<li>一旦所有其他的共享锁都被释放，拥有未决锁的连接就可以将其锁提升至排它锁(<code>EXCLUSIVE</code>)，此时就可以自由对数据库进行修改，所有以前所缓存的修改都会被写到数据库文件中。</li>
</ul>
<h2 id="u4E8B_u52A1_u7684_u7C7B_u578B"><a href="#u4E8B_u52A1_u7684_u7C7B_u578B" class="headerlink" title="事务的类型"></a>事务的类型</h2><p>SQLite有三种不同的事务类型，它们以不同的锁状态启动事务。事务可以开始于：<code>DEFERED</code>、<code>IMMEDIATE</code>或<code>EXCLUSIVE</code>。事务类型在<code>BEGIN</code>命令中制定：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">BEGIN</span> [ <span class="keyword">DEFERRED</span> | <span class="keyword">IMMEDIATE</span> | EXCLUSIVE ] <span class="keyword">TRANSACTION</span>;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>一个<code>DEFERED</code>知道必须使用时才获取锁。对于延迟事务，<code>BEGIN</code>本身不会做什么事情——它从未锁定状态开始。只是默认的情况。多个连接可以在同一时刻未创建任何锁的情况下开始延迟事务。第一个对数据库的读操作获取共享锁，第一个对数据库的写操作试图获取预留锁。</li>
<li>由<code>BEGIN</code>开始的<code>IMMEDIATE</code>事务在<code>BEGIN</code>执行时视图获取预留锁。如果成功，<code>BEGIN IMMEDIATE</code>保证没有其他连接可以写数据库。</li>
<li><code>EXCLUSIVE</code>事务会试着获取对数据库的排它锁。一旦成功，<code>EXCLUSIVE</code>事务保证数据库中没有其他活动连接，可以对数据库进行任意读写操作。</li>
</ul>
<p>如果两个连接都用<code>DEFERED</code>事务，可能会出现死锁：都想写数据库，但是都没有放弃自己的锁（例如一个获取了未决锁，一个保持了共享锁）。但是如果都以<code>BEGIN IMMEDIATE</code>或者<code>BEGIN EXCLUSIVE</code>开始事务，就不会死锁。<br>基本准则是：如果数据库没有其他连接，用<code>BEGIN</code>就足够。如果有其他连接会进行写操作，需要使用<code>BEGIN IMMEDIATE</code>或者<code>BEGIN EXCLUSIVE</code>开始事务。</p>
<h1 id="u6570_u636E_u5E93_u7BA1_u7406"><a href="#u6570_u636E_u5E93_u7BA1_u7406" class="headerlink" title="数据库管理"></a>数据库管理</h1><h2 id="u9644_u52A0_u6570_u636E_u5E93"><a href="#u9644_u52A0_u6570_u636E_u5E93" class="headerlink" title="附加数据库"></a>附加数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ATTACH [database] filename AS database_name;</span><br><span class="line">DETACH [database] database_name;</span><br></pre></td></tr></table></figure>
<p>可以用<code>main</code>全名引用主数据库中的对象。<br>例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ATTACH database '/tmp/db' AS db2;</span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> db2.foo;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">main</span>.foods <span class="keyword">LIMIT</span> <span class="number">2</span>;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u6570_u636E_u5E93_u6E05_u7406"><a href="#u6570_u636E_u5E93_u6E05_u7406" class="headerlink" title="数据库清理"></a>数据库清理</h2><p>SQLite有两个命令用于清理数据库——<code>REINDEX</code>和<code>VACUUM</code>。<br><code>REINDEX</code>用于重建索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REINDEX collation_name;</span><br><span class="line">REINDEX table_name|index_name;</span><br></pre></td></tr></table></figure></p>
<p>第一种形式重建所有使用指定排序名称的索引，当腰改变用户定义的排序行为时才需要这种形式。要重构表中所有索引（或指定名称的索引），可以使用第二种形式的命令。</p>
<p><code>VACUUM</code>通过重构数据库文件清理那些未使用的空间。</p>
<h2 id="u7CFB_u7EDF_u76EE_u5F55"><a href="#u7CFB_u7EDF_u76EE_u5F55" class="headerlink" title="系统目录"></a>系统目录</h2><p><code>sqlite_master</code>表是系统表，包含数据库中所有表、视图、索引和触发器信息。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">type</span>, <span class="keyword">name</span>, rootpage <span class="keyword">FROM</span> sqlite_master;</span></span><br></pre></td></tr></table></figure></p>
<p><code>type</code>字段说明对象的类型，<code>name</code>字段是对象的名称，<code>rootpage</code>指对象的第一个B-tree页面在数据库文件中的位置。</p>
<h2 id="u67E5_u770B_u67E5_u8BE2_u8BA1_u5212"><a href="#u67E5_u770B_u67E5_u8BE2_u8BA1_u5212" class="headerlink" title="查看查询计划"></a>查看查询计划</h2><p>使用<code>EXPLAN QUERY PLAN</code>命令查看SQLite执行查询的方法：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAN QUERY PLAN <span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> foods <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">145</span>;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Write-Ahead_Logging"><a href="#Write-Ahead_Logging" class="headerlink" title="Write-Ahead Logging"></a>Write-Ahead Logging</h1><p>SQLite处理<code>Atomic Commit</code>和<code>Rollback</code>传统方法叫做<code>Rollback Journal</code>。当进程想要修改数据库的时候，首先把未修改的这部分内容记录在<code>Rollback Journal</code>里，这个时候原始数据库还没有改变。当<code>COMMIT</code>数据的时候，SQLite首先确保没有其他数据库连接正在读数据库，将修改直接写入数据库文件，删除<code>Rollback Journal</code>。如果这期间发生了crash或者<code>ROLLBACK</code>，再利用<code>Rollback Journal</code>记录的原始内容<code>REVERT</code>之前的变更。</p>
<p><code>Write-Ahead Logging</code>方法反其道而行之，把原始内容保存在数据库文件里，把修改记录在单独的<code>WAL</code>文件里，多个<code>Transaction</code>会按顺序追加在文件末尾。要读取数据库的时候，首先会查找<code>WAL</code>文件里最后一个合法的<code>COMMIT</code>记录，并查看要读取的页面是不是出现在这次记录里，如果出现在记录里，就从<code>WAL</code>读取修改以后的数据，否则就从原数据库文件里读取。因此在<code>WAL</code>模式下，从原始数据库文件中读数据和提交数据修改可以同时进行，但是写事务之间依然不可并行（要保证<code>COMMIT</code>的数据按顺序一次追加到<code>WAL</code>文件末尾）。在之后的某个时间点(checkpoint)，所有的修改事务再写回数据库。</p>
</div><div class="tags"><a href="/tags/SQLite/">SQLite</a><a href="/tags/database/">database</a></div><div class="post-nav"><a href="/2015/08/09/ios-in-app-purchase/" class="pre"><i class="icon-previous">iOS应用内购买IAP接入</i></a><a href="/2015/06/26/ios-markdown-rendering/" class="next">iOS开发中的Markdown渲染<i class="icon-next"></i></a></div><div id="disqus_thread"><script>var disqus_shortname = 'nightfade';
var disqus_identifier = '2015/08/02/sql-summary/';
var disqus_title = 'SQLite中的常用SQL语法、锁机制和WAL';
var disqus_url = 'http://nightfade.github.io/2015/08/02/sql-summary/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//nightfade.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://nightfade.github.io"/></form></div><div class="widget"><div class="widget-title">分类</div></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/HLS/" style="font-size: 15px;">HLS</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/CPP/" style="font-size: 15px;">CPP</a> <a href="/tags/Multithreading/" style="font-size: 15px;">Multithreading</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/ReactiveCocoa/" style="font-size: 15px;">ReactiveCocoa</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/SQLite/" style="font-size: 15px;">SQLite</a> <a href="/tags/CMake/" style="font-size: 15px;">CMake</a> <a href="/tags/qiniu/" style="font-size: 15px;">qiniu</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/GameDev/" style="font-size: 15px;">GameDev</a> <a href="/tags/Actor/" style="font-size: 15px;">Actor</a> <a href="/tags/protobuf/" style="font-size: 15px;">protobuf</a> <a href="/tags/RPC/" style="font-size: 15px;">RPC</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Operating-System/" style="font-size: 15px;">Operating System</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2015/09/15/cpp1x-atomic/">多线程内存模型和C++1x Atomic</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/01/reactivecocoa3-basic/">ReactiveCocoa 3.0 初步</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/28/notes-on-using-swift-with-cocoa-and-objective-c/">《Using Swift with Cocoa and Objective-C》学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/12/ios-promise/">iOS开发中的Promise模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/09/ios-in-app-purchase/">iOS应用内购买IAP接入</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/02/sql-summary/">SQLite中的常用SQL语法、锁机制和WAL</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/26/ios-markdown-rendering/">iOS开发中的Markdown渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/24/dynamic-height-cell/">可变高度的UITableViewCell</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/05/10/qiniu-hls/">使用七牛云存储实现HLS在线视频授权播放</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/12/20/actor-model-and-game-development/">关于Actor模型与游戏编程的一点想法</a></li></ul></div><div class="widget"><div class="widget-title">最近评论</div><script type="text/javascript" src="//nightfade.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title">友情链接</div></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">Nightfade's Techlog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"></div></body></html>