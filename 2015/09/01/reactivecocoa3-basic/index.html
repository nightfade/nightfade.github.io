<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ReactiveCocoa 3.0 初步 | Nightfade's Techlog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ReactiveCocoa 3.0 初步</h1><a id="logo" href="/.">Nightfade's Techlog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">ReactiveCocoa 3.0 初步</h1><div class="post-meta">Sep 1 2015 | </div><span data-disqus-identifier="2015/09/01/reactivecocoa3-basic/" class="disqus-comment-count"></span><div class="post-content"><p>本文总结了《<a href="http://blog.scottlogic.com/2015/04/24/first-look-reactive-cocoa-3.html" target="_blank" rel="external">A FIRST LOOK AT REACTIVECOCOA 3.0</a>》和《<a href="http://blog.scottlogic.com/2015/04/28/reactive-cocoa-3-continued.html" target="_blank" rel="external">REACTIVECOCOA 3.0 - SIGNAL PRODUCERS AND API CLARITY</a>》中关于<code>ReactiveCocoa 3.0</code>新的Swift API的基本用法。</p>
<p><code>ReactiveCocoa 3.0</code>的Swift API引入了泛型、<code>pipe-forward</code>运算符，并且还运用了<code>curried functions</code>。新的语言特性让<code>ReactiveCocoa</code>变的更好更简洁了。</p>
<h1 id="Creating_Signals"><a href="#Creating_Signals" class="headerlink" title="Creating Signals"></a>Creating Signals</h1><p>和<code>Objective-C</code>版本<code>ReactiveCocoa</code>中的<code>RACSignal</code>对应的是<code>Swift</code>版本中的<code>Signal</code>。关于<code>Signal</code>很重要的一点是这个类是个泛型类：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Signal</span>&lt;<span class="title">T</span>, <span class="title">E</span>: <span class="title">ErrorType</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类型<code>T</code>代表的是信号发出的<code>next</code> <code>event</code>中数据的类型；<code>E</code>表示错误的类型必须是符合<code>ErrorType</code>协议的。<br><code>Swift</code>的<code>Signal</code>创建的方式和<code>Objective-C</code>的<code>RACSignal</code>创建方式很相似：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">createSignal</span><span class="params">()</span></span> -&gt; <span class="type">Signal</span>&lt;<span class="type">String</span>, <span class="type">NoError</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">Signal</span> &#123;</span><br><span class="line">        sink <span class="keyword">in</span></span><br><span class="line">        <span class="type">NSTimer</span>.schedule(repeatInterval: <span class="number">1.0</span>) &#123;</span><br><span class="line">            timer <span class="keyword">in</span></span><br><span class="line">            sendNext(sink, <span class="string">"tick #<span class="subst">\(<span class="built_in">count</span>++)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Signal</code>的构造函数接受一个<code>generator</code>闭包的参数，这个<code>generator</code>被调用并且传入一个<code>sink</code>，在这个例子里<code>sink</code>的类型是<code>SinkOf&lt;Event&lt;String, NoError&gt;&gt;</code>。任何传给这个<code>sink</code>的<code>event</code>都会被<code>signal</code>发射出去。<br><code>sendNext</code>的第二个参数接收传入的值，并且构造成<code>event</code>传给<code>sink</code>。</p>
<h1 id="Observing_Signals"><a href="#Observing_Signals" class="headerlink" title="Observing Signals"></a>Observing Signals</h1><p>观察监听一个<code>Signal</code>有几种不同的方式，最简单的是用<code>observe</code>方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> signal = createSignal()</span><br><span class="line">signal.observe(next: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br></pre></td></tr></table></figure></p>
<p>这段代码的输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tick #0&#10;tick #1&#10;tick #2&#10;tick #3&#10;tick #4</span><br></pre></td></tr></table></figure></p>
<p>或者也可以提供一个<code>Sink</code>来观察<code>Signal</code>的<code>Event</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">createSignal().observe(<span class="type">SinkOf</span> &#123;</span><br><span class="line">    event <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Next</span>(data):</span><br><span class="line">        <span class="built_in">print</span>(data.unbox)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><code>Event</code>类型是一个枚举，其中的<code>Next</code>和<code>Error</code>事件类型包含了其相关值。上面例子中的<code>SinkOf</code>构造函数构造了一个类型是<code>SinkOf&lt;Event&lt;String, NoError&gt;&gt;</code>的<code>sink</code>。<br>由于<code>Swift</code>语言本身的限制，<code>Event</code>中封装的<code>data</code>是用<a href="https://github.com/LlamaKit/LlamaKit/blob/e28d7f6e82fbd5dcd5388b36e2acf4eedb44b4e8/LlamaKit/Result.swift#L156" target="_blank" rel="external"><code>LlamaKit Box Class</code></a>封装起来的，需要用<code>box/unbox</code>来处理一下。(注：<code>Swift 2.0</code>之后这个限制其实已经没有了)。</p>
<h1 id="Transforming_Signals"><a href="#Transforming_Signals" class="headerlink" title="Transforming Signals"></a>Transforming Signals</h1><p><code>Swift</code>的<code>Signal</code>和<code>Objective-C</code>的API另外一个显著的不同点就是对<code>Signal</code>的<code>Transforming</code>，以<code>map</code>操作举例，<code>map</code>函数被实现为一个<code>free function</code>，而不是<code>Signal</code>的成员函数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Signal</span>&lt;<span class="title">T</span>, <span class="title">E</span>: <span class="title">ErrorType</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">map</span><span class="params">(signal: Signal, transform: ...)</span></span> -&gt; <span class="type">Signal</span></span><br></pre></td></tr></table></figure></p>
<p>然而如果用<code>free function</code>做<code>Signal</code>的<code>Transforming</code>，代码就不再是『流式』的了：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> transformedSignal = <span class="built_in">filter</span>(<span class="built_in">map</span>(signal, &#123; ... &#125;), &#123; ... &#125;)</span><br></pre></td></tr></table></figure></p>
<p>所以<code>ReactiveCocoa</code>提供了<code>pipe-forward</code>运算符（从<code>F#</code>借鉴过来的idea）。<br><code>Swift</code>的<code>map</code>实际上是一个<code>curred function</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">map</span><span class="generics">&lt;T, U, E&gt;</span><span class="params">(transform: T -&gt; U)</span></span></span><br><span class="line">                        (signal: <span class="type">Signal</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;) -&gt; <span class="type">Signal</span>&lt;<span class="type">U</span>, <span class="type">E</span>&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，这个方法第一次调用的时候，我们先提供一个<code>transform</code>，从而得到一个新的函数，可以用给定的<code>transform</code>把一个<code>signal</code>映射为一个新的<code>signal</code>。<br><code>pipe-forward</code>运算符允许我们把<code>transform</code>串联起来：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> |&gt; <span class="generics">&lt;T, E, X&gt;</span><span class="params">(signal: Signal&lt;T, E&gt;,</span><br><span class="line">                         transform: Signal&lt;T, E&gt; -&gt; X)</span></span> -&gt; <span class="type">X</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> transform(signal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用<code>pip-forward</code>运算符，我们可以把<code>transforming</code>写成这样：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal</span><br><span class="line">    |&gt; <span class="built_in">map</span> &#123; $<span class="number">0</span>.uppercaseString &#125;</span><br><span class="line">    |&gt; observe(next: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</span><br></pre></td></tr></table></figure></p>
<p><code>free functions</code>比起成员函数有很多好处，其中之一就是不受继承关系的限制。例如<code>Swift</code>的<code>Foundation</code>定义了<code>map</code>函数，可以运用在任何实现了<code>CollectionType</code>协议的类或者结构体上，而不需要有任何继承关系。</p>
<h1 id="Cold_and_Hot_Signals"><a href="#Cold_and_Hot_Signals" class="headerlink" title="Cold and Hot Signals"></a>Cold and Hot Signals</h1><p>在之前版本的<code>ReactiveCocoa</code>中，<code>cold signal</code>和<code>hot signal</code>两个概念都是用<code>RACSignal</code>来表示的，也经常会造成一些困惑。<code>ReactiveCocoa 3.0</code>通过显式的定义两种不同类型（<code>Signal</code>和<code>SignalProducer</code>）把二者区分开。为了理解<code>Signal</code>和<code>SignalProducer</code>之间的区别，我们用个实例比较一下。</p>
<h2 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">createSignal</span><span class="params">()</span></span> -&gt; <span class="type">Signal</span>&lt;<span class="type">String</span>, <span class="type">NoError</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">Signal</span> &#123;</span><br><span class="line">        sink <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Creating the timer signal"</span>)</span><br><span class="line">        <span class="type">NSTimer</span>.schedule(repeatInterval: <span class="number">0.1</span>) &#123;</span><br><span class="line">            timer <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Emitting a next event"</span>)</span><br><span class="line">            sendNext(sink, <span class="string">"tick #<span class="subst">\(<span class="built_in">count</span>++)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> signal = createSignal()</span><br></pre></td></tr></table></figure>
<p>现在我们即使没有为<code>signal</code>增加<code>observer</code>，它依然在创建和发射<code>event</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating the timer signal&#10;Emitting a next event&#10;Emitting a next event&#10;Emitting a next event&#10;...</span><br></pre></td></tr></table></figure></p>
<h2 id="Signal_Producer"><a href="#Signal_Producer" class="headerlink" title="Signal Producer"></a>Signal Producer</h2><p><code>SignalProducer</code>的初始化结构和<code>Signal</code>很类似：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">createSignalProducer</span><span class="params">()</span></span> -&gt; <span class="type">SignalProducer</span>&lt;<span class="type">String</span>, <span class="type">NoError</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">SignalProducer</span> &#123;</span><br><span class="line">        sink, disposable <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Creating the timer signal producer"</span>)</span><br><span class="line">        <span class="type">NSTimer</span>.schedule(repeatInterval: <span class="number">0.1</span>) &#123;</span><br><span class="line">            timer <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Emitting a next event"</span>)</span><br><span class="line">            sendNext(sink, <span class="string">"tick #<span class="subst">\(<span class="built_in">count</span>++)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> signalProducer = createSignalProducer()</span><br></pre></td></tr></table></figure></p>
<p>我们创建了一个<code>SignalProducer</code>但是没有任何的<code>observer</code>，会发现控制台丽没有任何输出，<code>timer</code>也没有被触发。<br><code>SignalProducer</code>可以看做是个工厂，可以通过调用<code>SignalProducer</code>的成员方法<code>start</code>，或者通过<code>pipe-forward</code>运算符调用<code>start</code>这个<code>free function</code>创建一个<code>Signal</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">signalProducer</span><br><span class="line">    |&gt; start(next: &#123;</span><br><span class="line">        <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，对于<code>Signal</code>，即使添加了多个<code>observer</code>，<code>timer</code>也只会触发一次；对于<code>SignalProducer</code>，每次<code>start</code>都会创建一个新的<code>timer</code>。<br>通常我们会用<code>SignalProducer</code>表示一个操作或者任务，<code>start</code>一个<code>SignalProducer</code>会启动这个操作；而<code>Signal</code>用来表示事件流，无论是否有<code>Observer</code>监听。<code>SignalProducer</code>非常适合于网络请求，而<code>Signal</code>则非常适合表示UI的事件流。</p>
<h1 id="Signal_producer_Operations"><a href="#Signal_producer_Operations" class="headerlink" title="Signal producer Operations"></a>Signal producer Operations</h1><p>和<code>Signal</code>一样，<code>SignalProducer</code>的操作也被定义成<code>curried free function</code>。<br>例如用来在pipline中插入副作用的<code>on</code>操作（为了可读性省略了一些函数参数）：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">on</span><span class="generics">&lt;T, E&gt;</span><span class="params">(started: <span class="params">(<span class="params">()</span></span></span></span> -&gt; ())? = <span class="literal">nil</span>, ...)</span><br><span class="line">             (producer: <span class="type">SignalProducer</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;) -&gt; <span class="type">SignalProducer</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>pipe-forward</code>运算符也为<code>SignalProducer</code>进行了重载：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> |&gt; <span class="generics">&lt;T, E, X&gt;</span><span class="params">(producer: SignalProducer&lt;T, E&gt;,</span><br><span class="line">                         transform: SignalProducer&lt;T, E&gt; -&gt; X)</span></span> -&gt; <span class="type">X</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> transform(producer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，我们可以像这样为<code>SignalProducer</code>创建pipeline：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">signalProducer</span><br><span class="line">    |&gt; on(started: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Signal has started"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    |&gt; start(next: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Next received: <span class="subst">\($<span class="number">0</span>)</span>"</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="Applying_Signal_Operations_to_Signal_Producers"><a href="#Applying_Signal_Operations_to_Signal_Producers" class="headerlink" title="Applying Signal Operations to Signal Producers"></a>Applying Signal Operations to Signal Producers</h1><p><code>SignalProducer</code>通过<code>lift</code>方法来复用<code>Signal</code>上的操作，例如<code>map</code>、<code>filter</code>等。<code>lift</code>会将<code>Signal</code>的操作应用在<code>SignalProducer</code>通过<code>start</code>创建的信号上。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> signalProducer = createSignalProducer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapping: <span class="type">Signal</span>&lt;<span class="type">String</span>, <span class="type">NoError</span>&gt; -&gt; <span class="type">Signal</span>&lt;<span class="type">Int</span>, <span class="type">NoError</span>&gt; = <span class="built_in">map</span>(&#123;</span><br><span class="line">    string <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">count</span>(string)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> mappedProducer = signalProducer.lift(mapping)</span><br><span class="line"></span><br><span class="line">mappedProducer</span><br><span class="line">    |&gt; start(next: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Next received: <span class="subst">\($<span class="number">0</span>)</span>"</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p><code>pipe-forward</code>运算符也为<code>SignalProducer</code>做了重载：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> |&gt;<span class="generics">&lt;T, E, U, F&gt;</span><span class="params">(producer: SignalProducer&lt;T, E&gt;, </span><br><span class="line">                          transform: Signal&lt;T, E&gt; -&gt; Signal&lt;U, F&gt;)</span></span> -&gt; <span class="type">SignalProducer</span>&lt;<span class="type">U</span>, <span class="type">F</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> producer.lift(transform)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，<code>Signal</code>的操作都可以直接通过<code>pipe-forward</code>应用在<code>SignalProducer</code>上：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">signalProducer</span><br><span class="line">    |&gt; on(started: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Signal has started"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    |&gt; <span class="built_in">map</span> &#123; <span class="built_in">count</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    |&gt; start(next: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Next received: <span class="subst">\($<span class="number">0</span>)</span>"</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
</div><div class="tags"><a href="/tags/ReactiveCocoa/">ReactiveCocoa</a><a href="/tags/iOS/">iOS</a></div><div class="post-nav"><a href="/2015/09/15/cpp1x-atomic/" class="pre"><i class="icon-previous">多线程内存模型和C++1x Atomic</i></a><a href="/2015/08/28/notes-on-using-swift-with-cocoa-and-objective-c/" class="next">《Using Swift with Cocoa and Objective-C》学习笔记<i class="icon-next"></i></a></div><div id="disqus_thread"><script>var disqus_shortname = 'nightfade';
var disqus_identifier = '2015/09/01/reactivecocoa3-basic/';
var disqus_title = 'ReactiveCocoa 3.0 初步';
var disqus_url = 'http://nightfade.github.io/2015/09/01/reactivecocoa3-basic/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//nightfade.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://nightfade.github.io"/></form></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Operating-System/" style="font-size: 15px;">Operating System</a> <a href="/tags/CMake/" style="font-size: 15px;">CMake</a> <a href="/tags/CPP/" style="font-size: 15px;">CPP</a> <a href="/tags/Multithreading/" style="font-size: 15px;">Multithreading</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/ReactiveCocoa/" style="font-size: 15px;">ReactiveCocoa</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/SQLite/" style="font-size: 15px;">SQLite</a> <a href="/tags/HLS/" style="font-size: 15px;">HLS</a> <a href="/tags/qiniu/" style="font-size: 15px;">qiniu</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/GameDev/" style="font-size: 15px;">GameDev</a> <a href="/tags/Actor/" style="font-size: 15px;">Actor</a> <a href="/tags/protobuf/" style="font-size: 15px;">protobuf</a> <a href="/tags/RPC/" style="font-size: 15px;">RPC</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2015/09/15/cpp1x-atomic/">多线程内存模型和C++1x Atomic</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/01/reactivecocoa3-basic/">ReactiveCocoa 3.0 初步</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/28/notes-on-using-swift-with-cocoa-and-objective-c/">《Using Swift with Cocoa and Objective-C》学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/12/ios-promise/">iOS开发中的Promise模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/09/ios-in-app-purchase/">iOS应用内购买IAP接入</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/02/sql-summary/">SQLite中的常用SQL语法、锁机制和WAL</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/26/ios-markdown-rendering/">iOS开发中的Markdown渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/24/dynamic-height-cell/">可变高度的UITableViewCell</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/05/10/qiniu-hls/">使用七牛云存储实现HLS在线视频授权播放</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/12/20/actor-model-and-game-development/">关于Actor模型与游戏编程的一点想法</a></li></ul></div><div class="widget"><div class="widget-title">最近评论</div><script type="text/javascript" src="//nightfade.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title">友情链接</div></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">Nightfade's Techlog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"></div></body></html>