<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Dive into Protocol Buffers Python API | Nightfade's Techlog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Dive into Protocol Buffers Python API</h1><a id="logo" href="/.">Nightfade's Techlog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">Dive into Protocol Buffers Python API</h1><div class="post-meta">Dec 13 2013 | </div><span data-disqus-identifier="2013/12/13/dive-into-protocol-buffers-python-api/" class="disqus-comment-count"></span><div class="post-content"><p><em>Google Protocol Buffers</em>是Google使用的数据交换格式，在RPC协议和文件存储等有广泛的应用。其基本使用方法就不在赘述，可以参看<em>protobuf</em>的项目主页：<a href="https://code.google.com/p/protobuf/" target="_blank" rel="external">https://code.google.com/p/protobuf/</a>。本文的主要内容是剖析<em>protobuf</em>的Python API的具体实现。</p>
<p>由于我们需要的不仅仅是单纯的<code>message</code>结构，后续还希望使用<em>protobuf</em>的<code>service</code>实现RPC机制，因此本文会对这两部分内容进行分析。同时，为了使得剖析过程尽可能清晰，使用最简单的<code>message</code>和<code>service</code>结构作为研究对象，但是思路理清楚之后，更复杂的结构分析起来也是大同小异的。本文的以如下的proto文件及其编译出的代码作为剖析的起点：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package sample;</span><br><span class="line"></span><br><span class="line">option py_generic_services = true;</span><br><span class="line"></span><br><span class="line">message Void &#123;&#125;</span><br><span class="line"></span><br><span class="line">message SampleMessage &#123;</span><br><span class="line">    required string message = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service SampleService &#123;</span><br><span class="line">    rpc echo(SampleMessage) returns(Void);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>protoc</code>进行编译，即可得到对应的Python模块sample_pb2.py：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --python_out=. sample.proto</span><br></pre></td></tr></table></figure>
<p>生成的py代码超过100行，为了方便剖析，接下来按照结构分块进行剖析。</p>
<h2 id="message"><a href="#message" class="headerlink" title="message"></a>message</h2><p>对<code>message</code>的剖析，使用<code>message SampleMessage</code>的生成代码。</p>
<p><code>message SampleMessage</code>对应的Python class的定义非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleMessage</span><span class="params">(_message.Message)</span>:</span></span><br><span class="line">    __metaclass__ = _reflection.GeneratedProtocolMessageType</span><br><span class="line">    DESCRIPTOR = _SAMPLEMESSAGE</span><br></pre></td></tr></table></figure>
<p>这里涉及到的<code>__metaclass__</code>可以参看上一篇博文<a href="/blog/2013/12/12/python-meta-programming/">《Python Meta-programming》</a>。</p>
<p>这里的<code>_SAMPLEMESSAGE</code>的具体定义是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_SAMPLEMESSAGE = _descriptor.Descriptor(</span><br><span class="line">  name=<span class="string">'SampleMessage'</span>,</span><br><span class="line">  full_name=<span class="string">'sample.SampleMessage'</span>,</span><br><span class="line">  filename=<span class="keyword">None</span>,</span><br><span class="line">  file=DESCRIPTOR,</span><br><span class="line">  containing_type=<span class="keyword">None</span>,</span><br><span class="line">  fields=[</span><br><span class="line">    _descriptor.FieldDescriptor(</span><br><span class="line">      name=<span class="string">'message'</span>, full_name=<span class="string">'sample.SampleMessage.message'</span>, index=<span class="number">0</span>,</span><br><span class="line">      number=<span class="number">1</span>, type=<span class="number">9</span>, cpp_type=<span class="number">9</span>, label=<span class="number">2</span>,</span><br><span class="line">      has_default_value=<span class="keyword">False</span>, default_value=unicode(<span class="string">""</span>, <span class="string">"utf-8"</span>),</span><br><span class="line">      message_type=<span class="keyword">None</span>, enum_type=<span class="keyword">None</span>, containing_type=<span class="keyword">None</span>,</span><br><span class="line">      is_extension=<span class="keyword">False</span>, extension_scope=<span class="keyword">None</span>,</span><br><span class="line">      options=<span class="keyword">None</span>),</span><br><span class="line">  ],</span><br><span class="line">  extensions=[</span><br><span class="line">  ],</span><br><span class="line">  nested_types=[],</span><br><span class="line">  enum_types=[</span><br><span class="line">  ],</span><br><span class="line">  options=<span class="keyword">None</span>,</span><br><span class="line">  is_extendable=<span class="keyword">False</span>,</span><br><span class="line">  extension_ranges=[],</span><br><span class="line">  serialized_start=<span class="number">32</span>,</span><br><span class="line">  serialized_end=<span class="number">64</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>看起来我们在proto文件中所定义的信息基本都在这里了，事实上如果查看<code>Descriptor</code>的代码，这个结构的琐碎细节也主要是用来组织数据而已。而动态生成相应class的机制，应该主要是由<code>GeneratedProtocolMessageType</code>实现的，就让我们来看一下其源码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratedProtocolMessageType</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    _DESCRIPTOR_KEY = <span class="string">'DESCRIPTOR'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, dictionary)</span>:</span></span><br><span class="line">        descriptor = dictionary[GeneratedProtocolMessageType._DESCRIPTOR_KEY]</span><br><span class="line">        bases = _NewMessage(bases, descriptor, dictionary)</span><br><span class="line">        superclass = super(GeneratedProtocolMessageType, cls)</span><br><span class="line"></span><br><span class="line">        new_class = superclass.__new__(cls, name, bases, dictionary)</span><br><span class="line">        setattr(descriptor, <span class="string">'_concrete_class'</span>, new_class)</span><br><span class="line">        <span class="keyword">return</span> new_class</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dictionary)</span>:</span></span><br><span class="line">        descriptor = dictionary[GeneratedProtocolMessageType._DESCRIPTOR_KEY]</span><br><span class="line">        _InitMessage(descriptor, cls)</span><br><span class="line">        superclass = super(GeneratedProtocolMessageType, cls)</span><br><span class="line">        superclass.__init__(name, bases, dictionary)</span><br></pre></td></tr></table></figure>
<p>看到之前<code>__metaclass__</code>，其实我们就已经可以知道其是利用Python的Meta-programming机制来动态生成类的了。而上面这段<code>GeneratedProtocolMessageType</code>正是继承了<code>type</code>类，因此也是一个元类。</p>
<p>这里需要解释一下我们在使用<code>class</code>语法定义一个类的时候，传给Metaclass的三个参数的赋值内容。在这里我们可以简单的做一个实验，用如下方式定义一个类及其元类，并生成一个实例对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaType</span><span class="params">(type)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, dictionary)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'name: '</span> + pprint.pformat(name)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'bases'</span> + pprint.pformat(bases)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'dictionary'</span> + pprint.pformat(dictionary)</span><br><span class="line"></span><br><span class="line">        superclass = super(MetaType, cls)</span><br><span class="line">        new_class = superclass.__new__(cls, name, bases, dictionary)</span><br><span class="line">        <span class="keyword">return</span> new_class</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dictionary)</span>:</span></span><br><span class="line">        superclass = super(MetaType, cls)</span><br><span class="line">        superclass.__init__(name, bases, dictionary)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = MetaType</span><br><span class="line">    </span><br><span class="line">    CLASS_PROPERTY = <span class="string">'CLASS_PROPERTY'</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">instance = A()</span><br></pre></td></tr></table></figure>
<p>运行该脚本得到如下输出结果：</p>
<pre><code>name: &apos;A&apos;
bases(&lt;type &apos;object&apos;&gt;,)
dictionary{&apos;CLASS_PROPERTY&apos;: &apos;CLASS_PROPERTY&apos;,
 &apos;__metaclass__&apos;: &lt;class &apos;__main__.MetaType&apos;&gt;,
 &apos;__module__&apos;: &apos;__main__&apos;,
 &apos;method&apos;: &lt;function method at 0x110193b18&gt;}
</code></pre><p>到这里，实例化<code>message</code>所对应的对象实例的过程就已经很清楚了：</p>
<p>首先protoc编译proto文件，生成对应与<code>message</code>的<code>Descriptor</code>以及一个简单的<code>class</code>骨架，这个<code>class</code>的主要作用就是通过类属性把对应<code>Descriptor</code>传给<code>GeneratedProtocolMessageType</code>。</p>
<p>而Python解释器真正要生成<code>message</code>所对应的<code>class</code>的时候，<code>GeneratedProtocolMessageType</code>会读取<code>Descriptor</code>中的属性和域的信息，动态的在生成的类实例中通过<code>InitMessage</code>（其最终是通过调用<code>setattr</code>）插入相应的属性和方法。</p>
<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>相对于<code>message</code>来说，service的组成结构就更复杂一些，项目文档里对<code>service</code>也不够详细。概括来说，<code>service</code>主要是根据proto文件中的接口定义生成一个RPC调用的抽象层。这个抽象层是被设计成独立于任何RPC实现的，也就是说protobuf的作用只是帮助你在不同语言之间生成统一的调用接口，你可以在这个接口之下使用任何的通信机制来实现RPC过程。</p>
<p>虽然听起来很美，但是这样的抽象层也带来了过多不必要的间接层，在<em>protobuf 2.3</em>版本之后已经不鼓励继续使用<code>service</code>来实现RPC。但是一方面由于要取代<code>service</code>的<code>plugins</code>机制依然还在试验阶段，另一方面目前现有的很多的RPC实现依然是基于<code>service</code>，因此本文还是以<code>service</code>为研究对象来剖析如何利用<code>protobuf</code>来实现RPC机制。</p>
<p>利用<em>protobuf</em>的<code>service</code>来实现RPC，主要涉及三个对象：</p>
<ol>
<li><p><code>Service</code>： 提供了RPC可调用的方法的抽象层接口，由具体的服务或stub继承这个抽象接口，并进行具体实现。</p>
</li>
<li><p><code>RpcChannel</code>：其负责与一个<code>Service</code>进行通信并调用其提供的RPC方法，通常情况下会在调用端实现一个<code>stub</code>对<code>RpcChannel</code>进行封装，通过调用<code>stub</code>的函数接口将调用行为转换为数据流通过<code>RpcChannel</code>进行传输，而不会直接使用<code>RpcChannel</code>。</p>
</li>
<li><p><code>RpcController</code>：主要作用是提供一种可以控制RPC调用过程或者查明RPC过程中发生的错误的方式。</p>
</li>
</ol>
<p>在这里我们依然结合之前的实例来对<code>service</code>进行剖析。同时，还会通过简单实现一个<em>Echo Service</em>的RPC调用来说明<code>service</code>的三个抽象对象是如何协作的。</p>
<p>同样的，我们从前面的proto文件编译出的py代码开始进行分析。其中对应<code>service</code>接口的两个抽象类的定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleService</span><span class="params">(_service.Service)</span>:</span></span><br><span class="line">    __metaclass__ = service_reflection.GeneratedServiceType</span><br><span class="line">    DESCRIPTOR = _SAMPLESERVICE</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleService_Stub</span><span class="params">(SampleService)</span>:</span></span><br><span class="line">    __metaclass__ = service_reflection.GeneratedServiceStubType</span><br><span class="line">    DESCRIPTOR = _SAMPLESERVICE</span><br></pre></td></tr></table></figure>
<p><code>SampleService</code>是为服务的<strong>被调用端</strong>提供的抽象接口，被调用段通过继承该接口并实现相应方法为调用端提供服务。</p>
<p><code>SampleService_Stub</code>则是为<strong>调用端</strong>提供的<code>stub</code>的抽象接口。调用端需要做的事情则是继承该接口，将RPC函数接口的调用转化为数据流，并通过通信管道传递到被调用一端。</p>
<p>和<code>message</code>一样，这两个类只是一个骨架，其真正的实现是通过<code>__metaclass__</code>以及<code>Descriptor</code>进行实现。</p>
<p>我们首先来看一下<code>service</code>的<code>Descriptor</code>是什么样子的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_SAMPLESERVICE = _descriptor.ServiceDescriptor(</span><br><span class="line">  name=<span class="string">'SampleService'</span>,</span><br><span class="line">  full_name=<span class="string">'sample.SampleService'</span>,</span><br><span class="line">  file=DESCRIPTOR,</span><br><span class="line">  index=<span class="number">0</span>,</span><br><span class="line">  options=<span class="keyword">None</span>,</span><br><span class="line">  serialized_start=<span class="number">66</span>,</span><br><span class="line">  serialized_end=<span class="number">126</span>,</span><br><span class="line">  methods=[</span><br><span class="line">  _descriptor.MethodDescriptor(</span><br><span class="line">    name=<span class="string">'echo'</span>,</span><br><span class="line">    full_name=<span class="string">'sample.SampleService.echo'</span>,</span><br><span class="line">    index=<span class="number">0</span>,</span><br><span class="line">    containing_service=<span class="keyword">None</span>,</span><br><span class="line">    input_type=_SAMPLEMESSAGE,</span><br><span class="line">    output_type=_VOID,</span><br><span class="line">    options=<span class="keyword">None</span>,</span><br><span class="line">  ),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>这个<code>Descriptor</code>依然包含了许多属性，但是我们其实更多的只需要关注<code>methods</code>这个属性，它是一个<code>list</code>，包含了我们在<code>service</code>中的定义的所有方法。之所以要关注<code>methods</code>，是因为在后续做RPC底层通信的具体实现的时候，主要需要传递的数据就是我们所调用的RPC方法及相应参数的描述。</p>
<p>接下来我们看一下被调用端的<code>Service</code>的元类<strong><code>GeneratedServiceType</code></strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratedServiceType</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    _DESCRIPTOR_KEY = <span class="string">'DESCRIPTOR'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dictionary)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> GeneratedServiceType._DESCRIPTOR_KEY <span class="keyword">not</span> <span class="keyword">in</span> dictionary:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        descriptor = dictionary[GeneratedServiceType._DESCRIPTOR_KEY]</span><br><span class="line">        service_builder = _ServiceBuilder(descriptor)</span><br><span class="line">        service_builder.BuildService(cls)</span><br></pre></td></tr></table></figure>
<p>这一层的定义依然非常简单，具体的细节我们需要进一步向前追溯到<code>_ServiceBuilder.BuildService</code>的代码才能一探究竟：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ServiceBuilder</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, service_descriptor)</span>:</span></span><br><span class="line">        self.descriptor = service_descriptor</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BuildService</span><span class="params">(self, cls)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_WrapCallMethod</span><span class="params">(srvc, method_descriptor,</span><br><span class="line">                            rpc_controller, request, callback)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self._CallMethod(srvc, method_descriptor,</span><br><span class="line">                           rpc_controller, request, callback)</span><br><span class="line">        self.cls = cls</span><br><span class="line">        cls.CallMethod = _WrapCallMethod</span><br><span class="line">        cls.GetDescriptor = staticmethod(<span class="keyword">lambda</span>: self.descriptor)</span><br><span class="line">        cls.GetDescriptor.__doc__ = <span class="string">"Returns the service descriptor."</span></span><br><span class="line">        cls.GetRequestClass = self._GetRequestClass</span><br><span class="line">        cls.GetResponseClass = self._GetResponseClass</span><br><span class="line">        <span class="keyword">for</span> method <span class="keyword">in</span> self.descriptor.methods:</span><br><span class="line">            setattr(cls, method.name, self._GenerateNonImplementedMethod(method))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_CallMethod</span><span class="params">(self, srvc, method_descriptor,</span><br><span class="line">                    rpc_controller, request, callback)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> method_descriptor.containing_service != self.descriptor:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                <span class="string">'CallMethod() given method descriptor for wrong service type.'</span>)</span><br><span class="line">        method = getattr(srvc, method_descriptor.name)</span><br><span class="line">        <span class="keyword">return</span> method(rpc_controller, request, callback)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_GetRequestClass</span><span class="params">(self, method_descriptor)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> method_descriptor.containing_service != self.descriptor:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                <span class="string">'GetRequestClass() given method descriptor for wrong service type.'</span>)</span><br><span class="line">        <span class="keyword">return</span> method_descriptor.input_type._concrete_class</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_GetResponseClass</span><span class="params">(self, method_descriptor)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> method_descriptor.containing_service != self.descriptor:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                <span class="string">'GetResponseClass() given method descriptor for wrong service type.'</span>)</span><br><span class="line">        <span class="keyword">return</span> method_descriptor.output_type._concrete_class</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_GenerateNonImplementedMethod</span><span class="params">(self, method)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> inst, rpc_controller, request, callback: (</span><br><span class="line">            self._NonImplementedMethod(method.name, rpc_controller, callback))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_NonImplementedMethod</span><span class="params">(self, method_name, rpc_controller, callback)</span>:</span></span><br><span class="line">        rpc_controller.SetFailed(<span class="string">'Method %s not implemented.'</span> % method_name)</span><br><span class="line">        callback(<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<p><code>BuildService</code>函数主要做了两件事情：</p>
<ol>
<li><p>将自身的<code>_CallMethod</code>、<code>_GetRequestClass</code>、<code>_GetResponseClass</code>等公用方法的引用赋给新生成的类。其内部有一个<code>_WrapCallMethod</code>的嵌套函数，该嵌套函数存在的目的只是为了在使用<code>Service</code>实例对象进行方法调用<code>CallMethod</code>的时候可以把自身作为<code>srvc</code>参数传递给<code>_CallMethod</code>方法。</p>
</li>
<li><p>将我们在proto中定义的<code>service</code>的RPC调用接口通过<code>setattr</code>“注入”到类的定义中。</p>
</li>
</ol>
<p>这里尤其需要注意的是<code>_CallMethod</code>方法，可以看到这个方法主要的作用是讲传入的<code>method_descriptor</code>转化解析成为对<code>srvc</code>中相应方法的调用。因此，只要我们可以通过反序列化从通信的数据流中解析出RPC调用的<code>MethodDescriptor</code>，即可直接利用<code>_CallMethod</code>方法调用到相应的服务。这一点正是被调用端抽象接口需要实现的关键部分。</p>
<p>而调用端的<strong><code>GeneratedServiceStubType</code></strong>结构也是类似的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratedServiceStubType</span><span class="params">(GeneratedServiceType)</span>:</span></span><br><span class="line"></span><br><span class="line">    _DESCRIPTOR_KEY = <span class="string">'DESCRIPTOR'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dictionary)</span>:</span></span><br><span class="line">        super(GeneratedServiceStubType, cls).__init__(name, bases, dictionary)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> GeneratedServiceStubType._DESCRIPTOR_KEY <span class="keyword">not</span> <span class="keyword">in</span> dictionary:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        descriptor = dictionary[GeneratedServiceStubType._DESCRIPTOR_KEY]</span><br><span class="line">        service_stub_builder = _ServiceStubBuilder(descriptor)</span><br><span class="line">        service_stub_builder.BuildServiceStub(cls)</span><br></pre></td></tr></table></figure>
<p><code>GeneratedServiceStubType</code>不仅包含了<code>GeneratedServiceType</code>对类对象的全部定义，还在此基础上通过<code>_ServiceStubBuilder</code>增加了<code>stub</code>所特有的属性。<code>_ServiceStubBuilder</code>的实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ServiceStubBuilder</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, service_descriptor)</span>:</span></span><br><span class="line">        self.descriptor = service_descriptor</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BuildServiceStub</span><span class="params">(self, cls)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_ServiceStubInit</span><span class="params">(stub, rpc_channel)</span>:</span></span><br><span class="line">            stub.rpc_channel = rpc_channel</span><br><span class="line">        self.cls = cls</span><br><span class="line">        cls.__init__ = _ServiceStubInit</span><br><span class="line">        <span class="keyword">for</span> method <span class="keyword">in</span> self.descriptor.methods:</span><br><span class="line">            setattr(cls, method.name, self._GenerateStubMethod(method))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_GenerateStubMethod</span><span class="params">(self, method)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">lambda</span> inst, rpc_controller, request, callback=<span class="keyword">None</span>:</span><br><span class="line">            self._StubMethod(inst, method, rpc_controller, request, callback))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_StubMethod</span><span class="params">(self, stub, method_descriptor,</span><br><span class="line">                    rpc_controller, request, callback)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> stub.rpc_channel.CallMethod(</span><br><span class="line">            method_descriptor, rpc_controller, request,</span><br><span class="line">            method_descriptor.output_type._concrete_class, callback)</span><br></pre></td></tr></table></figure>
<p>其主要作用是实现对<code>RpcChannel</code>的包裹，从而将远端的RPC调用伪装成一个本地调用。这段代码里比较关键的两步：</p>
<ol>
<li><code>_GenerateStubMethod</code>生成的包裹方法将所有对<code>stub</code>方法的调用统一转换为对<code>_StubMethod</code>方法的调用，同时还将对具体方法的调用转化为了传入一个<code>MethodDescriptor</code>，使得后续进行通信的时候可以将调用行为序列化。</li>
<li><code>_StubMethod</code>方法则进一步将方法的调用传递给了<code>RpcChannel.CallMethod</code>，从而可以通过<code>RpcChannel</code>将调用行为通过通信管道传递出去。也就是说，调用端抽象接口实现主要需要关注的是<code>RpcChannel.CallMethod</code>如何处理调用行为以及参数的序列化以及数据的传递。</li>
</ol>
<p>既然如此，我们就来继续看一下<code>RpcChannel</code>的定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RpcChannel</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CallMethod</span><span class="params">(self, method_descriptor, rpc_controller,</span><br><span class="line">                   request, response_class, done)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure>
<p>RpcChannel接口非常简单明了，就是一个有待我们实现的<code>CallMethod</code>方法。回想一下<code>GeneratedServiceType</code>为我们的<code>Service</code>会添加一个非常相似的<code>CallMethod</code>方法。区别只在于被调用端的<code>CallMethod</code>会直接通过返回值传回<code>response</code>，而这里通过函数参数指定<code>response</code>的类型。所以，只要讲调用端的<code>CallMethod</code>和被调用端的<code>CallMethod</code>通过通信管道链接在一起，即可完成一个RPC过程！</p>
<p>目前为止，我们还遗漏了一项：<code>RpcController</code>。这个类主要是为了我们可以捕获RPC调用过程中的一些异常情况，并提供了一些额外的控制。具体实现方式因人而异，其定义也非常简单，仅仅是提供了一些基本的函数接口。这里不再赘述，具体要实现的内容可参看<em>protobuf Python API</em> <code>service.py</code>文件中<code>RpcController</code>代码的注释。</p>
<p>到目前为止，我们掌握的信息已经足以去利用<code>protobuf</code>具体实现一套PRC机制。在下一篇博文《Implement an Asynchronous RPC Basing on Protocol Buffers》中将基于本文的内容，具体说明如何构建一个可供RPC调用的<code>Echo Service</code>:)</p>
</div><div class="tags"><a href="/tags/Python/">Python</a><a href="/tags/protobuf/">protobuf</a></div><div class="post-nav"><a href="/2013/12/15/implement-an-asynchronous-rpc-basing-on-protocol-buffers/" class="pre"><i class="icon-previous">Implement an Asynchronous RPC Basing on Protocol Buffers</i></a><a href="/2013/12/12/python-meta-programming/" class="next">Python Meta-programming<i class="icon-next"></i></a></div><div id="disqus_thread"><script>var disqus_shortname = 'nightfade';
var disqus_identifier = '2013/12/13/dive-into-protocol-buffers-python-api/';
var disqus_title = 'Dive into Protocol Buffers Python API';
var disqus_url = 'http://nightfade.github.io/2013/12/13/dive-into-protocol-buffers-python-api/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//nightfade.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://nightfade.github.io"/></form></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Operating-System/" style="font-size: 15px;">Operating System</a> <a href="/tags/CMake/" style="font-size: 15px;">CMake</a> <a href="/tags/CPP/" style="font-size: 15px;">CPP</a> <a href="/tags/Multithreading/" style="font-size: 15px;">Multithreading</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/ReactiveCocoa/" style="font-size: 15px;">ReactiveCocoa</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/SQLite/" style="font-size: 15px;">SQLite</a> <a href="/tags/HLS/" style="font-size: 15px;">HLS</a> <a href="/tags/qiniu/" style="font-size: 15px;">qiniu</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/GameDev/" style="font-size: 15px;">GameDev</a> <a href="/tags/Actor/" style="font-size: 15px;">Actor</a> <a href="/tags/protobuf/" style="font-size: 15px;">protobuf</a> <a href="/tags/RPC/" style="font-size: 15px;">RPC</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2015/09/15/cpp1x-atomic/">多线程内存模型和C++1x Atomic</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/01/reactivecocoa3-basic/">ReactiveCocoa 3.0 初步</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/28/notes-on-using-swift-with-cocoa-and-objective-c/">《Using Swift with Cocoa and Objective-C》学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/12/ios-promise/">iOS开发中的Promise模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/09/ios-in-app-purchase/">iOS应用内购买IAP接入</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/02/sql-summary/">SQLite中的常用SQL语法、锁机制和WAL</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/26/ios-markdown-rendering/">iOS开发中的Markdown渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/24/dynamic-height-cell/">可变高度的UITableViewCell</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/05/10/qiniu-hls/">使用七牛云存储实现HLS在线视频授权播放</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/12/20/actor-model-and-game-development/">关于Actor模型与游戏编程的一点想法</a></li></ul></div><div class="widget"><div class="widget-title">最近评论</div><script type="text/javascript" src="//nightfade.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title">友情链接</div></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">Nightfade's Techlog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"></div></body></html>