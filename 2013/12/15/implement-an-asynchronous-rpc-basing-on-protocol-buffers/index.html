<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Implement an Asynchronous RPC Basing on Protocol Buffers | Nightfade's Techlog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Implement an Asynchronous RPC Basing on Protocol Buffers</h1><a id="logo" href="/.">Nightfade's Techlog</a><p class="description">Programming</p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">Implement an Asynchronous RPC Basing on Protocol Buffers</h1><div class="post-meta">Dec 15 2013 | </div><span data-disqus-identifier="2013/12/15/implement-an-asynchronous-rpc-basing-on-protocol-buffers/" class="disqus-comment-count"></span><div class="post-content"><p>在前一篇博文《Dive Into Protocol Buffers Python API》中对<em>protobuf</em>的Python API的代码进行了分析。现在进入实践阶段，利用<em>protobuf</em>的<code>service</code> API实现一套异步RPC机制。</p>
<p>严谨起见，从<em>wikipedia</em>上摘录下一般情况下一次RPC调用的过程：</p>
<blockquote>
<ol>
<li>The client calls the client stub. The call is a <strong>local procedure call</strong>, with parameters pushed on to the stack in the normal way.</li>
<li>The client stub packs the parameters into a message and makes a system call to send the message. Packing the parameters is called <strong>marshalling</strong>.</li>
<li>The client’s local operating system <strong>sends</strong> the message from the client machine to the server machine.</li>
<li>The local operating system on the server machine passes the <strong>incoming</strong> packets to the server stub.</li>
<li>The server stub unpacks the parameters from the message. Unpacking the parameters is called <strong>unmarshalling</strong>.</li>
<li>Finally, the server stub calls <strong>the server procedure</strong>. The reply traces the same steps in the reverse direction.</li>
</ol>
</blockquote>
<p>上面过程中的第1和第6步已经由<em>protobuf</em>的<code>service</code> API为我们实现好了，我们只需要在proto文件中定义所需的具体调用接口即可。</p>
<p>对于第2和第5步的<em>marshalling</em>和<em>unmarshalling</em>步骤，<code>service</code> API虽然没有为我们完全实现，但是<em>protobuf</em>为方法以及参数已经准备好了完善的<em>serialization</em>的机制，我们只需要自己决定如何用这些序列化的数据拼装数据包即可。</p>
<p>最后，第3和第4步的通信机制则是完全需要由我们自己来实现的，这也是<em>protobuf</em>设计的初衷，在最多变的部分（多种多样的网络结构、协议和通信机制）留出足够的空间让程序员可以针对特定场景自己实现，使得<em>protobuf</em>可以应用在更多的场景。</p>
<p>回到标题所说的<em>Asynchronous RPC</em>。一次函数调用通常包含了输入和输出两个过程。对于RPC来说，我们可以像大多数本地函数那样，在进行调用之后一直等待，直到计算结果返回才继续向下执行。但是由于网络传输的过程相对比较耗时，采取这样的策略无疑是非常低效的。因此我们采取另外一种策略：调用者发送调用请求之后不等待结果的返回就立即继续执行后续的操作，当收到RPC返回的计算结果之后再回来处理。这里将前一种策略称为<em>Synchronous RPC</em>，而后一种就是本文要实现的<em>Asynchronous RPC</em>。</p>
<p>实现的方式其实也很简单，就是把客户端发起的一次RPC调用拆分成两次来处理：首先由客户端发起RPC调用，之后无需等待继续向后执行；而服务端接收到RPC调用请求并处理完成之后，再向客户端发起另外一次RPC调用，将计算结果通过参数通知客户端。</p>
<p>关于RPC需要说明的东西大概就到这里，接下来我们首先解决第3和第4步的通信机制的实现。</p>
<h2 id="u5B9E_u73B0_u901A_u4FE1_u5C42"><a href="#u5B9E_u73B0_u901A_u4FE1_u5C42" class="headerlink" title="实现通信层"></a>实现通信层</h2><p>我们选择使用asyncore和TCP协议实现RPC的通信层。关于asyncore的具体用法可以参考<a href="http://docs.python.org/2/library/asyncore.html" target="_blank" rel="external">asyncore的文档</a>。</p>
<p>首先将端到端的链接和传输抽象出来，一个端到端的通信可以用下面这样一个<code>TcpConnection</code>来进行封装：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpConnection</span><span class="params">(asyncore.dispatcher)</span>:</span></span><br><span class="line"></span><br><span class="line">    ST_INIT = <span class="number">0</span></span><br><span class="line">    ST_ESTABLISHED = <span class="number">1</span></span><br><span class="line">    ST_DISCONNECTED = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sock)</span>:</span></span><br><span class="line">        asyncore.dispatcher.__init__(self, sock)</span><br><span class="line">        self.peername = peername</span><br><span class="line">        self.writebuff = <span class="string">''</span></span><br><span class="line">        self.status = TcpConnection.ST_ESTABLISHED <span class="keyword">if</span> sock <span class="keyword">else</span> TcpConnection.ST_INIT</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_read</span><span class="params">(self)</span>:</span></span><br><span class="line">        data = self.recv(<span class="number">4096</span>)</span><br><span class="line">        <span class="comment"># process data here</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_write</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.writebuff:</span><br><span class="line">            size = self.send(self.writebuff)</span><br><span class="line">            self.writebuff = self.writebuff[size:]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">writable</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.status == TcpConnection.ST_ESTABLISHED:</span><br><span class="line">            <span class="keyword">return</span> len(self.writebuff) &gt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.writebuff += data</span><br></pre></td></tr></table></figure>
<p>客户端负责主动向服务端发起连接请求，在请求成功后维护自己到服务端的<strong>一条</strong>连接。因此我们可以通过继承<code>TcpConnection</code>并增加<code>connect</code>行为得到通信的客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpClient</span><span class="params">(TcpConnection)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ip, port)</span>:</span></span><br><span class="line">        TcpConnection.__init__(self, <span class="keyword">None</span>)</span><br><span class="line">        self.ip = ip</span><br><span class="line">        self.port = port</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">async_connect</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.connect(self.peername)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_connect</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.status = TcpConnection.ST_ESTABLISHED</span><br></pre></td></tr></table></figure>
<p>服务端则负责监听并接受客户端的连接请求，并为每一个客户维护一条连接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span><span class="params">(asyncore.dispatcher)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ip, port)</span>:</span></span><br><span class="line">        asyncore.dispatcher.__init__(self)</span><br><span class="line">        self.ip = ip</span><br><span class="line">        self.port = port</span><br><span class="line"></span><br><span class="line">        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.set_reuse_addr()</span><br><span class="line">        self.bind((self.ip, self.port))</span><br><span class="line">        self.listen(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_accept</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sock, addr = self.accept()</span><br><span class="line">        <span class="keyword">except</span> socket.error, e:</span><br><span class="line">            self.logger.warning(<span class="string">'accept error: '</span> + e.message)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">except</span> TypeError, e:</span><br><span class="line">            self.logger.warning(<span class="string">'accept error: '</span> + e.message)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        conn = TcpConnection(sock, addr)</span><br><span class="line">        self.handle_new_connection(conn)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_new_connection</span><span class="params">(self, conn)</span>:</span></span><br><span class="line">    	<span class="string">""" handle new connection here """</span></span><br><span class="line">    	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>至此，我们就完成了一个简陋但有效的C/S模式的通信层。</p>
<h2 id="u5B9E_u73B0Echo_u670D_u52A1"><a href="#u5B9E_u73B0Echo_u670D_u52A1" class="headerlink" title="实现Echo服务"></a>实现Echo服务</h2><p>有了通信层，我们就可以继续向下进行。既然是RPC，那么就不可能脱离具体的业务，因此这里以经典的<em>Echo</em>服务为例，利用<em>protobuf</em>实现RPC。</p>
<p>我们为Echo定义proto如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package nightfade;</span><br><span class="line"></span><br><span class="line">option py_generic_services = true;</span><br><span class="line"></span><br><span class="line">message Void &#123;&#125;</span><br><span class="line"></span><br><span class="line">message EchoString &#123;</span><br><span class="line">    required string message = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service IEchoService &#123;</span><br><span class="line">    rpc echo(EchoString) returns(Void);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service IEchoClient &#123;</span><br><span class="line">    rpc respond(EchoString) returns(Void);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如前所述，因为要实现的是<em>Asynchronous RPC</em>，所以RPC调用分为两部分：</p>
<p>客户端首先调用<code>echo</code>，之后服务端接收到RPC请求并处理之后再调用<code>respond</code>将结果通知客户端。</p>
<p>使用<em>protoc</em>编译proto文件以及对生成的文件的分析这里就不在赘述，可以参考《Dive Into Protocol Buffers Python API》。这里需要关注的问题有两个：</p>
<ol>
<li>如何实现<em>Service</em>。</li>
<li>如何将实现好的<em>Service</em>与我们的通信层关联起来。</li>
</ol>
<p>因为Echo服务本身非常简单，所以第一个问题可以轻易解决：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoService</span><span class="params">(IEchoService)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(self, rpc_controller, echo_string, callback=None)</span>:</span></span><br><span class="line">        client_stub = IEchoClient_Stub(rpc_controller.rpc_channel)</span><br><span class="line">        client_stub.respond(rpc_controller, echo_string, callback=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<p>接下来我们需要考虑的就是与通信层的关联问题。</p>
<p>要将<em>protobuf</em>的<code>service</code>与通信层关联的关键在于<code>RpcChannel</code>。</p>
<p>首先来看调用端这一边。</p>
<p>调用端通过<em>stub</em>对RPC过程的调用最终会转向对<code>RpcChannel.CallMethod()</code>的调用，而这个方法也正是<em>protobuf</em>留给我们实现调用端进行<strong>marshalling</strong>和数据发送的地方。这样一来问题就很容易解决了，我们为RpcChannel实现<code>CallMethod</code>方法：</p>
<ol>
<li>无论是调用端还是被调用端，一个<code>method_descriptor</code>在其所在<em>Service</em>内的<em>index</em>是一致的。因此<em>method_descriptor</em>的部分只需要对其<em>index</em>进行<em>marshalling</em>即可。</li>
<li>RPC调用的参数可以直接使用<em>protobuf</em>的<code>SerializeToString()</code>方法进行<em>marshalling</em>，进而在接收端通过<code>ParseFromString()</code>方法<em>unmarshalling</em>。</li>
<li>数据包的<em>Framing</em>问题，则使用一个简单的方案：在数据包之前发送一个32位整数的<em>HEAD</em>用来告知接收端后续数据包的大小。</li>
</ol>
<p>具体实现来看代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RpcChannel</span><span class="params">(service.RpcChannel)</span>:</span></span><br><span class="line"></span><br><span class="line">    HEAD_FMT = <span class="string">'!I'</span></span><br><span class="line">    INDEX_FMT = <span class="string">'!H'</span></span><br><span class="line">    HEAD_LEN = struct.calcsize(HEAD_FMT)</span><br><span class="line">    INDEX_LEN = struct.calcsize(INDEX_FMT)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, conn)</span>:</span></span><br><span class="line">        super(RpcChannel, self).__init__()</span><br><span class="line">        self.conn = conn</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CallMethod</span><span class="params">(self,</span><br><span class="line">                   method_descriptor,</span><br><span class="line">                   rpc_controller,</span><br><span class="line">                   request,</span><br><span class="line">                   response_class,</span><br><span class="line">                   done)</span>:</span></span><br><span class="line">        index = method_descriptor.index</span><br><span class="line">        data = request.SerializeToString()</span><br><span class="line">        size = RpcChannel.INDEX_LEN + len(data)</span><br><span class="line"></span><br><span class="line">        self.conn.send_data(struct.pack(RpcChannel.HEAD_FMT, size))</span><br><span class="line">        self.conn.send_data(struct.pack(RpcChannel.INDEX_FMT, index))</span><br><span class="line">        self.conn.send_data(data)</span><br></pre></td></tr></table></figure>
<p>接下来实现被调用端。</p>
<p><em>protobuf</em>的<code>service</code> API在被调用端为我们完成的工作是，当使用合适的<code>method_descriptor</code>和<code>request</code>参数调用<code>IEchoService.CallMethod()</code>时，会自动调用我们对相应方法接口的具体实现。因此在服务端需要做的工作主要由：</p>
<ol>
<li>接受调用端发来的数据。</li>
<li>对接收到的数据包进行<em>unmashalling</em>，解析得到<code>method_descriptor</code>和<code>request</code>参数。</li>
<li>调用<code>EchoService.CallMethod()</code>。</li>
</ol>
<p>我们实现的<code>TcpConnection</code>可以完成接受数据的工作，只是还没能与后续的步骤关联起来。既然<em>marshalling</em>的工作是由<code>RpcChannel</code>来完成的，<em>unmarshalling</em>的功能我们也同样在<code>RpcChannel</code>中实现，为其增加<code>receive</code>方法。当<code>TcpConnection</code>接受到数据之后，就交给<code>RpcChannel.receive</code>进行处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rpc_calls = self.rpc_parser.feed(data)</span><br><span class="line">    <span class="keyword">except</span> (AttributeError, IndexError), e:</span><br><span class="line">        self.close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> method_descriptor, request <span class="keyword">in</span> rpc_calls:</span><br><span class="line">        self.service_local.CallMethod(method_descriptor, self.rpc_controller, request, callback=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure>
<p>其中<code>rpc_parser</code>负责将数据流<em>unmarshalling</em>成一系列的<code>method_descriptor</code>和<code>request</code>参数，具体实现就不再贴代码了。<code>service_local</code>则是服务端提供的服务<code>EchoService</code>。</p>
<p>至此，我们的整个RPC调用的的基本实现就已经完成了！限于篇幅，所以只贴了一些代码片段，完整的代码可以查看我的repository：<a href="https://github.com/nightfade/protobuf-RPC" target="_blank" rel="external">https://github.com/nightfade/protobuf-RPC</a>。</p>
<h2 id="u5176_u4ED6"><a href="#u5176_u4ED6" class="headerlink" title="其他"></a>其他</h2><p>在这个RPC的实现中，其实还欠缺了一个重要部分<code>RpcController</code>。这个部分是干什么用的呢？依然引用<em>wikipedia</em>的一段说明：</p>
<blockquote>
<p>An important difference between remote procedure calls and local calls is that remote calls can fail because of unpredictable network problems. Also, callers generally must deal with such failures without knowing whether the remote procedure was actually invoked. Idempotent procedures (those that have no additional effects if called more than once) are easily handled, but enough difficulties remain that code to call remote procedures is often confined to carefully written low-level subsystems.</p>
</blockquote>
<p>简单来说，RPC过程总是可能由于网络问题等不可预测的原因出错的，我们需要有一种途径来捕获并处理RPC过程中所发生的错误。<code>RpcController</code>就是为此而存在的，它定义了一些常用的错误处理的抽象接口，可以根据具体的场景进行实现。</p>
<p>鉴于<code>RpcController</code>的定义非常简单明确，并且是和具体场景紧密关联的，这里就不在上面花费更多精力了。以后业务逻辑逐渐复杂的时候，再根据需要case by case的进行实现即可。</p>
</div><div class="tags"><a href="/tags/Network/">Network</a><a href="/tags/RPC/">RPC</a><a href="/tags/protobuf/">protobuf</a></div><div class="post-nav"><a href="/2013/12/20/actor-model-and-game-development/" class="pre"><i class="icon-previous">关于Actor模型与游戏编程的一点想法</i></a><a href="/2013/12/13/dive-into-protocol-buffers-python-api/" class="next">Dive into Protocol Buffers Python API<i class="icon-next"></i></a></div><div id="disqus_thread"><script>var disqus_shortname = 'nightfade';
var disqus_identifier = '2013/12/15/implement-an-asynchronous-rpc-basing-on-protocol-buffers/';
var disqus_title = 'Implement an Asynchronous RPC Basing on Protocol Buffers';
var disqus_url = 'http://nightfade.github.io/2013/12/15/implement-an-asynchronous-rpc-basing-on-protocol-buffers/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//nightfade.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://nightfade.github.io"/></form></div><div class="widget"><div class="widget-title">分类</div></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/HLS/" style="font-size: 15px;">HLS</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/CPP/" style="font-size: 15px;">CPP</a> <a href="/tags/Multithreading/" style="font-size: 15px;">Multithreading</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/ReactiveCocoa/" style="font-size: 15px;">ReactiveCocoa</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/SQLite/" style="font-size: 15px;">SQLite</a> <a href="/tags/CMake/" style="font-size: 15px;">CMake</a> <a href="/tags/qiniu/" style="font-size: 15px;">qiniu</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/GameDev/" style="font-size: 15px;">GameDev</a> <a href="/tags/Actor/" style="font-size: 15px;">Actor</a> <a href="/tags/protobuf/" style="font-size: 15px;">protobuf</a> <a href="/tags/RPC/" style="font-size: 15px;">RPC</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Operating-System/" style="font-size: 15px;">Operating System</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2015/09/15/cpp1x-atomic/">多线程内存模型和C++1x Atomic</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/01/reactivecocoa3-basic/">ReactiveCocoa 3.0 初步</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/28/notes-on-using-swift-with-cocoa-and-objective-c/">《Using Swift with Cocoa and Objective-C》学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/12/ios-promise/">iOS开发中的Promise模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/09/ios-in-app-purchase/">iOS应用内购买IAP接入</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/02/sql-summary/">SQLite中的常用SQL语法、锁机制和WAL</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/26/ios-markdown-rendering/">iOS开发中的Markdown渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/24/dynamic-height-cell/">可变高度的UITableViewCell</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/05/10/qiniu-hls/">使用七牛云存储实现HLS在线视频授权播放</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/12/20/actor-model-and-game-development/">关于Actor模型与游戏编程的一点想法</a></li></ul></div><div class="widget"><div class="widget-title">最近评论</div><script type="text/javascript" src="//nightfade.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title">友情链接</div></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">Nightfade's Techlog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"></div></body></html>